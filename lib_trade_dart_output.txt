\n\n// ====== lib/core/di/trade_provider.dart ======\n
\n\n// ====== lib/core/network/websocket/clients/trade_ws_client.dart ======\n
\n\n// ====== lib/core/network/websocket/trade_ws_client_total.dart ======\n

// TODO: ì„ì‹œ ë¹„í™œì„±í™”
/*

import 'dart:convert';
import 'dart:math';
import '../../config/app_config.dart';
import '../../../domain/entities/trade.dart';
import '../../utils/logger.dart';
import 'base_ws_client.dart';

/// ğŸš€ ë°”ì´ë‚¸ìŠ¤ Futures í† íƒˆ ì™„ì „ì²´ WebSocket í´ë¼ì´ì–¸íŠ¸
/// 25ê°œ ëª¨ë“  ìŠ¤íŠ¸ë¦¼ íƒ€ì… ì§€ì› + ê³ ë¥´ê²Œ ë¶„ë°° ì „ëµ
class TradeWsClient extends BaseWsClient<Trade> {
  
  /// êµ¬ë…í•  ìŠ¤íŠ¸ë¦¼ êµ¬ì„± ì„¤ì • (í† íƒˆ ì™„ì „ì²´)
  final TotalStreamSubscriptionConfig config;
  final bool enableVerboseLogging;

  TradeWsClient({
    void Function(WsStatus status)? onStatusChange,
    this.enableVerboseLogging = false,
    TotalStreamSubscriptionConfig? config,
  }) : config = config ?? TotalStreamSubscriptionConfig.totalBalanced(),
        super(
          url: AppConfig.streamUrl,
          onStatusChange: onStatusChange,
          pongTimeout: AppConfig.wsPongTimeout,
          encodeSubscribe: (markets) => _encodeSubscribeMessage(markets, config ?? TotalStreamSubscriptionConfig.totalBalanced()),
          decode: (json) => _decodeTradeMessage(json, enableVerboseLogging),
        );

  // ===================================================================
  // ğŸ“¨ í† íƒˆ ë©€í‹° ìŠ¤íŠ¸ë¦¼ êµ¬ë… ë©”ì‹œì§€ ì¸ì½”ë”© (25ê°œ ìŠ¤íŠ¸ë¦¼ ì§€ì›)
  // ===================================================================

  static String _encodeSubscribeMessage(List<String> markets, TotalStreamSubscriptionConfig config) {
    final params = <String>[];
    
    // ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜ ê³„ì‚° ë° ì œí•œ ì²´í¬
    final totalStreams = _calculateTotalStreams(markets.length, config);
    if (totalStreams > AppConfig.wsMaxStreams) {
      throw ArgumentError('Too many streams: $totalStreams. '
          'Binance limit: ${AppConfig.wsMaxStreams} streams per connection.');
    }

    // ===================================================================
    // ğŸ¯ ê±°ë˜ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ë“¤
    // ===================================================================
    
    if (config.aggTradeCount > 0) {
      final symbols = markets.take(config.aggTradeCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@aggTrade'));
      log.i('[TradeWS] ğŸ“ˆ Added ${symbols.length} aggTrade streams');
    }

    if (config.tradeCount > 0) {
      final symbols = markets.take(config.tradeCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@trade'));
      log.i('[TradeWS] ğŸ’± Added ${symbols.length} trade streams');
    }

    // ===================================================================
    // ğŸ“Š 24ì‹œê°„ í†µê³„ ìŠ¤íŠ¸ë¦¼ë“¤
    // ===================================================================
    
    if (config.tickerCount > 0) {
      final symbols = markets.take(config.tickerCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@ticker'));
      log.i('[TradeWS] ğŸ“Š Added ${symbols.length} ticker streams');
    }

    if (config.miniTickerCount > 0) {
      final symbols = markets.take(config.miniTickerCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@miniTicker'));
      log.i('[TradeWS] ğŸ“ˆ Added ${symbols.length} miniTicker streams');
    }

    // ===================================================================
    // ğŸ’° í˜¸ê°€ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ë“¤
    // ===================================================================
    
    if (config.bookTickerCount > 0) {
      final symbols = markets.take(config.bookTickerCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@bookTicker'));
      log.i('[TradeWS] ğŸ’° Added ${symbols.length} bookTicker streams');
    }

    if (config.depth5Count > 0) {
      final symbols = markets.take(config.depth5Count);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@depth5'));
      log.i('[TradeWS] ğŸ“‹ Added ${symbols.length} depth5 streams');
    }

    if (config.depth10Count > 0) {
      final symbols = markets.take(config.depth10Count);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@depth10'));
      log.i('[TradeWS] ğŸ“‹ Added ${symbols.length} depth10 streams');
    }

    if (config.depth20Count > 0) {
      final symbols = markets.take(config.depth20Count);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@depth20'));
      log.i('[TradeWS] ğŸ“‹ Added ${symbols.length} depth20 streams');
    }

    if (config.depthCount > 0) {
      final symbols = markets.take(config.depthCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@depth'));
      log.i('[TradeWS] âš¡ Added ${symbols.length} depth (full) streams');
    }

    if (config.depthSpeedCount > 0) {
      final symbols = markets.take(config.depthSpeedCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@depth@100ms'));
      log.i('[TradeWS] ğŸš¨ Added ${symbols.length} depth@100ms streams (HIGH VOLUME!)');
    }

    // ===================================================================
    // ğŸ•¯ï¸ ìº”ë“¤ìŠ¤í‹± ìŠ¤íŠ¸ë¦¼ë“¤
    // ===================================================================
    
    if (config.klineCount > 0) {
      final symbols = markets.take(config.klineCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@kline_1m')); // ê¸°ë³¸ 1ë¶„ë´‰
      log.i('[TradeWS] ğŸ•¯ï¸ Added ${symbols.length} kline streams');
    }

    if (config.continuousKlineCount > 0) {
      final symbols = markets.take(config.continuousKlineCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}_PERP@continuousKline_1m'));
      log.i('[TradeWS] ğŸ”„ Added ${symbols.length} continuousKline streams');
    }

    // ===================================================================
    // âš¡ Futures ì „ìš© ìŠ¤íŠ¸ë¦¼ë“¤
    // ===================================================================
    
    if (config.markPriceCount > 0) {
      final symbols = markets.take(config.markPriceCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@markPrice'));
      log.i('[TradeWS] âš¡ Added ${symbols.length} markPrice streams');
    }

    if (config.fundingRateCount > 0) {
      final symbols = markets.take(config.fundingRateCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@markPrice@1s')); // 1ì´ˆ ë§ˆí¬ê°€ê²©ìœ¼ë¡œ í€ë”© ì¶”ì 
      log.i('[TradeWS] ğŸ’¸ Added ${symbols.length} fundingRate streams');
    }

    // ===================================================================
    // ğŸš¨ íŠ¹ìˆ˜ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ë“¤
    // ===================================================================
    
    if (config.liquidationCount > 0) {
      final symbols = markets.take(config.liquidationCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@forceOrder'));
      log.i('[TradeWS] ğŸš¨ Added ${symbols.length} liquidation streams');
    }

    if (config.compositeIndexCount > 0) {
      final symbols = markets.take(config.compositeIndexCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@compositeIndex'));
      log.i('[TradeWS] ğŸ“ˆ Added ${symbols.length} compositeIndex streams');
    }

    // ===================================================================
    // ğŸ¯ BLVT ìŠ¤íŠ¸ë¦¼ë“¤
    // ===================================================================
    
    if (config.blvtNavCount > 0) {
      // BLVTëŠ” íŠ¹ë³„í•œ ë„¤ì´ë° (ì˜ˆ: BTCUP, BTCDOWN)
      final blvtSymbols = markets.where((s) => s.endsWith('UP') || s.endsWith('DOWN')).take(config.blvtNavCount);
      params.addAll(blvtSymbols.map((s) => '${s.toLowerCase()}@tokenNav'));
      log.i('[TradeWS] ğŸ¯ Added ${blvtSymbols.length} BLVT NAV streams');
    }

    if (config.blvtKlineCount > 0) {
      final blvtSymbols = markets.where((s) => s.endsWith('UP') || s.endsWith('DOWN')).take(config.blvtKlineCount);
      params.addAll(blvtSymbols.map((s) => '${s.toLowerCase()}@nav_kline_1m'));
      log.i('[TradeWS] ğŸ¯ Added ${blvtSymbols.length} BLVT Kline streams');
    }

    // ===================================================================
    // ğŸŒ ì „ì²´ ì‹œì¥ ìŠ¤íŠ¸ë¦¼ë“¤ (ì‹¬ë³¼ ë¬´ê´€)
    // ===================================================================
    
    if (config.allMarketTickerCount > 0) {
      params.add('!ticker@arr');
      log.i('[TradeWS] ğŸŒ Added all market ticker stream');
    }

    if (config.allMarketMiniCount > 0) {
      params.add('!miniTicker@arr');
      log.i('[TradeWS] ğŸŒ Added all market miniTicker stream');
    }

    if (config.allBookTickerCount > 0) {
      params.add('!bookTicker@arr');
      log.i('[TradeWS] ğŸŒ Added all market bookTicker stream');
    }

    if (config.allMarkPriceCount > 0) {
      params.add('!markPrice@arr');
      log.i('[TradeWS] ğŸŒ Added all market markPrice stream');
    }

    if (config.allLiquidationCount > 0) {
      params.add('!forceOrder@arr');
      log.i('[TradeWS] ğŸŒ Added all market liquidation stream');
    }

    final messageId = _generateUniqueMessageId();
    final subscribeMessage = {
      'method': 'SUBSCRIBE',
      'params': params,
      'id': messageId,
    };

    final jsonMessage = jsonEncode(subscribeMessage);

    log.i('[TradeWS] ğŸš€ ì´ ${params.length}ê°œ ìŠ¤íŠ¸ë¦¼ êµ¬ë… ì™„ë£Œ! (Markets: ${markets.length})');
    log.d('[TradeWS] Subscription message: $jsonMessage');

    return jsonMessage;
  }

  /// ì´ ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜ ê³„ì‚°
  static int _calculateTotalStreams(int marketCount, TotalStreamSubscriptionConfig config) {
    final symbolBasedStreams = [
      config.aggTradeCount,
      config.tradeCount,
      config.tickerCount,
      config.miniTickerCount,
      config.bookTickerCount,
      config.depth5Count,
      config.depth10Count,
      config.depth20Count,
      config.depthCount,
      config.depthSpeedCount,
      config.klineCount,
      config.continuousKlineCount,
      config.markPriceCount,
      config.fundingRateCount,
      config.liquidationCount,
      config.compositeIndexCount,
      config.blvtNavCount,
      config.blvtKlineCount,
    ].map((count) => count > marketCount ? marketCount : count).fold(0, (a, b) => a + b);

    final globalStreams = config.allMarketTickerCount +
                         config.allMarketMiniCount +
                         config.allBookTickerCount +
                         config.allMarkPriceCount +
                         config.allLiquidationCount;

    return symbolBasedStreams + globalStreams;
  }

  /// ë°”ì´ë‚¸ìŠ¤ í˜¸í™˜ ê³ ìœ  ë©”ì‹œì§€ ID ìƒì„±
  static String _generateUniqueMessageId() {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final randomPart = Random().nextInt(99999).toString().padLeft(5, '0');
    return '$timestamp$randomPart';
  }

  // ===================================================================
  // ğŸ“¥ í† íƒˆ ë©€í‹° ìŠ¤íŠ¸ë¦¼ ë©”ì‹œì§€ ë””ì½”ë”© (25ê°œ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬)
  // ===================================================================

  static Trade? _decodeTradeMessage(Map<String, dynamic> json, bool verboseLogging) {
    if (json.isEmpty) {
      if (verboseLogging) log.w('[TradeWS] Empty message received');
      return null;
    }

    // êµ¬ë… í™•ì¸ ë©”ì‹œì§€ ì²˜ë¦¬
    if (json.containsKey('result')) {
      if (json['result'] == null) {
        log.i('[TradeWS] âœ… Subscription confirmed: ${json['id']}');
      } else if (json['result'] is List) {
        final subscriptions = json['result'] as List;
        log.i('[TradeWS] ğŸ“‹ Active subscriptions: ${subscriptions.length}');
        if (verboseLogging) {
          log.d('[TradeWS] Subscriptions: $subscriptions');
        }
      }
      return null;
    }

    // Combined Stream ë©”ì‹œì§€ ì²˜ë¦¬
    if (json.containsKey('stream') && json.containsKey('data')) {
      final streamName = json['stream'] as String?;
      final data = json['data'];

      if (streamName == null || data == null) return null;
      return _parseStreamData(streamName, data, verboseLogging);
    }

    // Direct Stream ë©”ì‹œì§€ ì²˜ë¦¬
    if (json.containsKey('e')) {
      final eventType = json['e'] as String;
      return _parseDirectStreamData(eventType, json, verboseLogging);
    }

    // ì „ì²´ ì‹œì¥ ë°°ì—´ ë°ì´í„° ì²˜ë¦¬
    if (json.containsKey('data') && json['data'] is List) {
      return _parseAllMarketArrayData(json, verboseLogging);
    }

    if (verboseLogging) {
      log.w('[TradeWS] Unknown message type: ${json.keys.join(', ')}');
    }
    return null;
  }

  /// Combined Stream ë°ì´í„° íŒŒì‹± (25ê°œ ìŠ¤íŠ¸ë¦¼ íƒ€ì… ì§€ì›)
  static Trade? _parseStreamData(String streamName, dynamic data, bool verboseLogging) {
    try {
      if (data is! Map<String, dynamic>) return null;

      // ìŠ¤íŠ¸ë¦¼ íƒ€ì… íŒë³„ ë° íŒŒì‹±
      if (streamName.endsWith('@aggTrade')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.aggTrade);
      } else if (streamName.endsWith('@trade')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.trade);
      } else if (streamName.endsWith('@ticker')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.ticker);
      } else if (streamName.endsWith('@miniTicker')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.miniTicker);
      } else if (streamName.endsWith('@bookTicker')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.bookTicker);
      } else if (streamName.endsWith('@depth5')) {
        final symbol = _extractSymbolFromStreamName(streamName);
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.depth5, symbol: symbol, levels: 5);
      } else if (streamName.endsWith('@depth10')) {
        final symbol = _extractSymbolFromStreamName(streamName);
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.depth10, symbol: symbol, levels: 10);
      } else if (streamName.endsWith('@depth20')) {
        final symbol = _extractSymbolFromStreamName(streamName);
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.depth20, symbol: symbol, levels: 20);
      } else if (streamName.endsWith('@depth@100ms')) {
        final symbol = _extractSymbolFromStreamName(streamName);
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.depthSpeed, symbol: symbol);
      } else if (streamName.endsWith('@depth')) {
        final symbol = _extractSymbolFromStreamName(streamName);
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.depth, symbol: symbol);
      } else if (streamName.contains('@kline_')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.kline);
      } else if (streamName.contains('@continuousKline_')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.continuousKline);
      } else if (streamName.endsWith('@markPrice') || streamName.endsWith('@markPrice@1s')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.markPrice);
      } else if (streamName.endsWith('@forceOrder')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.liquidation);
      } else if (streamName.endsWith('@compositeIndex')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.compositeIndex);
      } else if (streamName.endsWith('@tokenNav')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.blvtNav);
      } else if (streamName.contains('@nav_kline_')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.blvtKline);
      }

      if (verboseLogging) {
        log.w('[TradeWS] Unsupported stream type: $streamName');
      }
      return null;
    } catch (e, st) {
      log.e('[TradeWS] Stream parsing failed ($streamName)', e, st);
      return null;
    }
  }

  /// Direct Stream ë°ì´í„° íŒŒì‹±
  static Trade? _parseDirectStreamData(String eventType, Map<String, dynamic> data, bool verboseLogging) {
    try {
      switch (eventType) {
        case 'aggTrade':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.aggTrade);
        case 'trade':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.trade);
        case '24hrTicker':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.ticker);
        case '24hrMiniTicker':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.miniTicker);
        case 'kline':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.kline);
        case 'continuous_kline':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.continuousKline);
        case 'markPriceUpdate':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.markPrice);
        case 'forceOrder':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.liquidation);
        case 'compositeIndex':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.compositeIndex);
        case 'nav':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.blvtNav);
        default:
          if (verboseLogging) {
            log.w('[TradeWS] Unsupported event type: $eventType');
          }
          return null;
      }
    } catch (e, st) {
      log.e('[TradeWS] Direct stream parsing failed ($eventType)', e, st);
      return null;
    }
  }

  /// ì „ì²´ ì‹œì¥ ë°°ì—´ ë°ì´í„° íŒŒì‹± (ì²« ë²ˆì§¸ í•­ëª©ë§Œ ë°˜í™˜)
  static Trade? _parseAllMarketArrayData(Map<String, dynamic> json, bool verboseLogging) {
    try {
      final data = json['data'] as List;
      if (data.isEmpty) return null;

      // ìŠ¤íŠ¸ë¦¼ ì´ë¦„ìœ¼ë¡œ íƒ€ì… íŒë³„
      final stream = json['stream'] as String?;
      if (stream == null) return null;

      BinanceStreamType streamType;
      if (stream.contains('ticker@arr')) {
        streamType = BinanceStreamType.allMarketTicker;
      } else if (stream.contains('miniTicker@arr')) {
        streamType = BinanceStreamType.allMarketMini;
      } else if (stream.contains('bookTicker@arr')) {
        streamType = BinanceStreamType.allBookTicker;
      } else if (stream.contains('markPrice@arr')) {
        streamType = BinanceStreamType.allMarkPrice;
      } else if (stream.contains('forceOrder@arr')) {
        streamType = BinanceStreamType.allLiquidation;
      } else {
        return null;
      }

      // ì²« ë²ˆì§¸ í•­ëª©ë§Œ ë°˜í™˜ (ì „ì²´ ì‹œì¥ ë°ì´í„°ëŠ” ë§¤ìš° í´ ìˆ˜ ìˆìŒ)
      final firstItem = data[0] as Map<String, dynamic>;
      return Trade.fromBinanceStream(json: firstItem, streamType: streamType);
    } catch (e, st) {
      log.e('[TradeWS] All market array parsing failed', e, st);
      return null;
    }
  }

  /// ìŠ¤íŠ¸ë¦¼ ì´ë¦„ì—ì„œ ì‹¬ë³¼ ì¶”ì¶œ
  static String _extractSymbolFromStreamName(String streamName) {
    if (streamName.contains('@')) {
      return streamName.split('@')[0].toUpperCase();
    }
    return 'UNKNOWN';
  }

  // ===================================================================
  // ğŸ“Š ë””ë²„ê·¸ ë° ëª¨ë‹ˆí„°ë§
  // ===================================================================

  /// í˜„ì¬ êµ¬ë… ì„¤ì • ì •ë³´
  Map<String, dynamic> getSubscriptionInfo() {
    return {
      'config': config.toMap(),
      'estimatedStreams': _calculateTotalStreams(100, config), // ê°€ì •: 100ê°œ ë§ˆì¼“
      'estimatedMessageRate': _estimateMessageRate(),
      'verboseLogging': enableVerboseLogging,
      'totalStreamTypes': 25,
      'isSafeConfiguration': config.isSafeConfiguration(),
    };
  }

  /// ì˜ˆìƒ ë©”ì‹œì§€ ì†ë„ ê³„ì‚°
  int _estimateMessageRate() {
    return config.aggTradeCount * 50 +       // aggTrade
           config.tradeCount * 100 +         // trade (ë§¤ìš° ë¹ ë¦„)
           config.tickerCount * 1 +          // ticker
           config.miniTickerCount * 1 +      // miniTicker
           config.bookTickerCount * 10 +     // bookTicker
           config.depth5Count * 10 +         // depth5
           config.depth10Count * 10 +        // depth10
           config.depth20Count * 10 +        // depth20
           config.depthCount * 100 +         // depth (ë¹ ë¦„)
           config.depthSpeedCount * 500 +    // depth@100ms (ë§¤ìš° ë¹ ë¦„)
           config.klineCount * 4 +           // kline
           config.continuousKlineCount * 4 + // continuousKline
           config.markPriceCount * 1 +       // markPrice
           config.fundingRateCount * 1 +     // fundingRate
           config.liquidationCount * 5 +     // liquidation
           config.compositeIndexCount * 1 +  // compositeIndex
           config.blvtNavCount * 1 +         // blvtNav
           config.blvtKlineCount * 4 +       // blvtKline
           config.allMarketTickerCount * 200 +   // ì „ì²´ ì‹œì¥ (ë§ì€ ì‹¬ë³¼)
           config.allMarketMiniCount * 200 +     // ì „ì²´ ì‹œì¥
           config.allBookTickerCount * 2000 +    // ì „ì²´ ì‹œì¥ (ë§¤ìš° ë¹ ë¦„)
           config.allMarkPriceCount * 200 +      // ì „ì²´ ì‹œì¥
           config.allLiquidationCount * 100;     // ì „ì²´ ì‹œì¥
  }
}

// ===================================================================
// ğŸ¯ í† íƒˆ ìŠ¤íŠ¸ë¦¼ êµ¬ë… ì„¤ì • í´ë˜ìŠ¤ (25ê°œ ìŠ¤íŠ¸ë¦¼ ì§€ì›)
// ===================================================================

class TotalStreamSubscriptionConfig {
  // === ê±°ë˜ ë°ì´í„° ===
  final int aggTradeCount;        // ì§‘ê³„ ê±°ë˜
  final int tradeCount;           // ê°œë³„ ê±°ë˜
  
  // === 24ì‹œê°„ í†µê³„ ===
  final int tickerCount;          // 24ì‹œê°„ ì „ì²´ í†µê³„
  final int miniTickerCount;      // 24ì‹œê°„ ê°„ì†Œ í†µê³„
  
  // === í˜¸ê°€ ë°ì´í„° ===
  final int bookTickerCount;      // ìµœê³  í˜¸ê°€
  final int depth5Count;          // 5ë‹¨ê³„ í˜¸ê°€ì°½
  final int depth10Count;         // 10ë‹¨ê³„ í˜¸ê°€ì°½
  final int depth20Count;         // 20ë‹¨ê³„ í˜¸ê°€ì°½
  final int depthCount;           // ì „ì²´ í˜¸ê°€ì°½
  final int depthSpeedCount;      // ê³ ì† í˜¸ê°€ì°½ (100ms)
  
  // === ìº”ë“¤ìŠ¤í‹± ===
  final int klineCount;           // ì¼ë°˜ ìº”ë“¤
  final int continuousKlineCount; // ì—°ì† ê³„ì•½ ìº”ë“¤
  
  // === Futures ì „ìš© ===
  final int markPriceCount;       // ë§ˆí¬ ê°€ê²©
  final int fundingRateCount;     // í€ë”© ë¹„ìœ¨
  
  // === íŠ¹ìˆ˜ ë°ì´í„° ===
  final int liquidationCount;     // ê°•ì œì²­ì‚°
  final int compositeIndexCount;  // ë³µí•© ì§€ìˆ˜
  
  // === BLVT ===
  final int blvtNavCount;         // BLVT NAV
  final int blvtKlineCount;       // BLVT ìº”ë“¤
  
  // === ì „ì²´ ì‹œì¥ ===
  final int allMarketTickerCount;    // ì „ì²´ 24h í†µê³„
  final int allMarketMiniCount;      // ì „ì²´ ê°„ì†Œ í†µê³„
  final int allBookTickerCount;      // ì „ì²´ í˜¸ê°€
  final int allMarkPriceCount;       // ì „ì²´ ë§ˆí¬ê°€ê²©
  final int allLiquidationCount;     // ì „ì²´ ê°•ì œì²­ì‚°

  const TotalStreamSubscriptionConfig({
    this.aggTradeCount = 0,
    this.tradeCount = 0,
    this.tickerCount = 0,
    this.miniTickerCount = 0,
    this.bookTickerCount = 0,
    this.depth5Count = 0,
    this.depth10Count = 0,
    this.depth20Count = 0,
    this.depthCount = 0,
    this.depthSpeedCount = 0,
    this.klineCount = 0,
    this.continuousKlineCount = 0,
    this.markPriceCount = 0,
    this.fundingRateCount = 0,
    this.liquidationCount = 0,
    this.compositeIndexCount = 0,
    this.blvtNavCount = 0,
    this.blvtKlineCount = 0,
    this.allMarketTickerCount = 0,
    this.allMarketMiniCount = 0,
    this.allBookTickerCount = 0,
    this.allMarkPriceCount = 0,
    this.allLiquidationCount = 0,
  });

  /// ğŸš€ í† íƒˆ ë°¸ëŸ°ìŠ¤ ì„¤ì • (745ê°œ ìŠ¤íŠ¸ë¦¼, ê³ ë¥´ê²Œ ë¶„ë°°)
  factory TotalStreamSubscriptionConfig.totalBalanced() {
    return const TotalStreamSubscriptionConfig(
      // === ê±°ë˜ ë°ì´í„° (60ê°œ) ===
      aggTradeCount: 30,       // ì§‘ê³„ ê±°ë˜
      tradeCount: 30,          // ê°œë³„ ê±°ë˜
      
      // === 24ì‹œê°„ í†µê³„ (60ê°œ) ===  
      tickerCount: 30,         // ì „ì²´ í†µê³„
      miniTickerCount: 30,     // ê°„ì†Œ í†µê³„
      
      // === í˜¸ê°€ ë°ì´í„° (120ê°œ) ===
      bookTickerCount: 30,     // ìµœê³  í˜¸ê°€
      depth5Count: 30,         // 5ë‹¨ê³„ í˜¸ê°€
      depth10Count: 30,        // 10ë‹¨ê³„ í˜¸ê°€
      depth20Count: 30,        // 20ë‹¨ê³„ í˜¸ê°€
      
      // === ìº”ë“¤ìŠ¤í‹± (60ê°œ) ===
      klineCount: 30,          // ì¼ë°˜ ìº”ë“¤
      continuousKlineCount: 30, // ì—°ì† ê³„ì•½ ìº”ë“¤
      
      // === Futures ì „ìš© (60ê°œ) ===
      markPriceCount: 30,      // ë§ˆí¬ ê°€ê²©
      fundingRateCount: 30,    // í€ë”© ë¹„ìœ¨
      
      // === íŠ¹ìˆ˜ ë°ì´í„° (60ê°œ) ===
      liquidationCount: 30,    // ê°•ì œì²­ì‚°
      compositeIndexCount: 30, // ë³µí•© ì§€ìˆ˜
      
      // === BLVT (60ê°œ) ===
      blvtNavCount: 30,        // BLVT NAV
      blvtKlineCount: 30,      // BLVT ìº”ë“¤
      
      // === ì „ì²´ ì‹œì¥ (5ê°œ) ===
      allMarketTickerCount: 1,     // ì „ì²´ í‹°ì»¤
      allMarketMiniCount: 1,       // ì „ì²´ ë¯¸ë‹ˆ
      allBookTickerCount: 1,       // ì „ì²´ ë¶í‹°ì»¤
      allMarkPriceCount: 1,        // ì „ì²´ ë§ˆí¬ê°€ê²©
      allLiquidationCount: 1,      // ì „ì²´ ì²­ì‚°
      
      // === ìœ„í—˜ ìŠ¤íŠ¸ë¦¼ (0ê°œ) ===
      depthCount: 0,           // ì „ì²´ í˜¸ê°€ (ë¹ ë¦„)
      depthSpeedCount: 0,      // 100ms í˜¸ê°€ (ë§¤ìš° ìœ„í—˜)
    );
  }

  /// ë³´ìˆ˜ì  ì„¤ì • (ì•ˆì „í•œ ìŠ¤íŠ¸ë¦¼ë“¤ë§Œ)
  factory TotalStreamSubscriptionConfig.conservative() {
    return const TotalStreamSubscriptionConfig(
      aggTradeCount: 20,
      tickerCount: 20,
      bookTickerCount: 20,
      depth5Count: 20,
      markPriceCount: 20,
      klineCount: 10,
      liquidationCount: 10,
      // ìœ„í—˜í•œ ìŠ¤íŠ¸ë¦¼ë“¤ì€ 0
      tradeCount: 0,
      depthCount: 0,
      depthSpeedCount: 0,
      allBookTickerCount: 0,
    );
  }

  /// ê±°ë˜ ì¤‘ì‹¬ ì„¤ì • (íŠ¸ë ˆì´ë”©ìš©)
  factory TotalStreamSubscriptionConfig.tradingFocused() {
    return const TotalStreamSubscriptionConfig(
      aggTradeCount: 50,       // ê±°ë˜ ë°ì´í„° ì¤‘ì‹¬
      bookTickerCount: 50,     // í˜¸ê°€ ë°ì´í„°
      depth5Count: 30,         // í˜¸ê°€ì°½
      markPriceCount: 30,      // ë§ˆí¬ê°€ê²©
      tickerCount: 20,         // ê¸°ë³¸ í†µê³„
      liquidationCount: 20,    // ì²­ì‚° ëª¨ë‹ˆí„°ë§
    );
  }

  /// ë¶„ì„ ì¤‘ì‹¬ ì„¤ì • (ë¦¬ì„œì¹˜ìš©)
  factory TotalStreamSubscriptionConfig.analysisFocused() {
    return const TotalStreamSubscriptionConfig(
      tickerCount: 50,         // í†µê³„ ë°ì´í„°
      klineCount: 50,          // ìº”ë“¤ ë°ì´í„°
      markPriceCount: 30,      // ê°€ê²© ë°ì´í„°
      liquidationCount: 30,    // ì‹œì¥ ë™í–¥
      compositeIndexCount: 20, // ì§€ìˆ˜ ë¶„ì„
      allMarketTickerCount: 1, // ì „ì²´ ì‹œì¥
      allMarkPriceCount: 1,    // ì „ì²´ ë§ˆí¬ê°€ê²©
    );
  }

  /// ê¸°ì¡´ í˜¸í™˜ìš© (aggTradeë§Œ)
  factory TotalStreamSubscriptionConfig.aggTradeOnly(int count) {
    return TotalStreamSubscriptionConfig(aggTradeCount: count);
  }

  /// ì´ ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜
  int get totalCount {
    return aggTradeCount + tradeCount + tickerCount + miniTickerCount +
           bookTickerCount + depth5Count + depth10Count + depth20Count +
           depthCount + depthSpeedCount + klineCount + continuousKlineCount +
           markPriceCount + fundingRateCount + liquidationCount + compositeIndexCount +
           blvtNavCount + blvtKlineCount + allMarketTickerCount + allMarketMiniCount +
           allBookTickerCount + allMarkPriceCount + allLiquidationCount;
  }

  /// ìœ„í—˜í•œ ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜
  int get highVolumeStreamCount {
    return tradeCount + depthCount + depthSpeedCount + allBookTickerCount;
  }

  /// ì•ˆì „í•œ êµ¬ì„±ì¸ì§€ í™•ì¸
  bool isSafeConfiguration() {
    final hasHighVolumeStreams = highVolumeStreamCount > 0;
    final totalStreams = totalCount;
    
    return !hasHighVolumeStreams && 
           totalStreams <= AppConfig.wsMaxStreams * 0.8; // 80% ì´í•˜
  }

  /// ì˜ˆìƒ ë©”ì‹œì§€ ì†ë„ (ê°„ë‹¨ ê³„ì‚°)
  int get estimatedMessageRate {
    return aggTradeCount * 50 + tradeCount * 100 + tickerCount * 1 +
           miniTickerCount * 1 + bookTickerCount * 10 + depth5Count * 10 +
           depth10Count * 10 + depth20Count * 10 + depthCount * 100 +
           depthSpeedCount * 500 + klineCount * 4 + continuousKlineCount * 4 +
           markPriceCount * 1 + fundingRateCount * 1 + liquidationCount * 5 +
           compositeIndexCount * 1 + blvtNavCount * 1 + blvtKlineCount * 4 +
           allMarketTickerCount * 200 + allMarketMiniCount * 200 +
           allBookTickerCount * 2000 + allMarkPriceCount * 200 +
           allLiquidationCount * 100;
  }

  /// ë§µìœ¼ë¡œ ë³€í™˜
  Map<String, dynamic> toMap() {
    return {
      // ê±°ë˜ ë°ì´í„°
      'aggTradeCount': aggTradeCount,
      'tradeCount': tradeCount,
      
      // 24ì‹œê°„ í†µê³„
      'tickerCount': tickerCount,
      'miniTickerCount': miniTickerCount,
      
      // í˜¸ê°€ ë°ì´í„°
      'bookTickerCount': bookTickerCount,
      'depth5Count': depth5Count,
      'depth10Count': depth10Count,
      'depth20Count': depth20Count,
      'depthCount': depthCount,
      'depthSpeedCount': depthSpeedCount,
      
      // ìº”ë“¤ìŠ¤í‹±
      'klineCount': klineCount,
      'continuousKlineCount': continuousKlineCount,
      
      // Futures ì „ìš©
      'markPriceCount': markPriceCount,
      'fundingRateCount': fundingRateCount,
      
      // íŠ¹ìˆ˜ ë°ì´í„°
      'liquidationCount': liquidationCount,
      'compositeIndexCount': compositeIndexCount,
      
      // BLVT
      'blvtNavCount': blvtNavCount,
      'blvtKlineCount': blvtKlineCount,
      
      // ì „ì²´ ì‹œì¥
      'allMarketTickerCount': allMarketTickerCount,
      'allMarketMiniCount': allMarketMiniCount,
      'allBookTickerCount': allBookTickerCount,
      'allMarkPriceCount': allMarkPriceCount,
      'allLiquidationCount': allLiquidationCount,
      
      // ìš”ì•½ ì •ë³´
      'totalCount': totalCount,
      'highVolumeStreamCount': highVolumeStreamCount,
      'estimatedMessageRate': estimatedMessageRate,
      'isSafe': isSafeConfiguration(),
    };
  }

  /// ìŠ¤íŠ¸ë¦¼ ì¹´í…Œê³ ë¦¬ë³„ ê°œìˆ˜
  Map<String, int> getCategoryBreakdown() {
    return {
      'Trade Data': aggTradeCount + tradeCount,
      '24h Statistics': tickerCount + miniTickerCount,
      'Order Book': bookTickerCount + depth5Count + depth10Count + depth20Count + depthCount + depthSpeedCount,
      'Candlestick': klineCount + continuousKlineCount,
      'Futures Price': markPriceCount + fundingRateCount,
      'Special Data': liquidationCount + compositeIndexCount,
      'BLVT': blvtNavCount + blvtKlineCount,
      'All Market': allMarketTickerCount + allMarketMiniCount + allBookTickerCount + allMarkPriceCount + allLiquidationCount,
    };
  }

  @override
  String toString() {
    return 'TotalStreamConfig(ì´ ${totalCount}ê°œ ìŠ¤íŠ¸ë¦¼, ì˜ˆìƒ ${estimatedMessageRate}msg/sec, ì•ˆì „ì„±: ${isSafeConfiguration() ? "ì•ˆì „" : "ì£¼ì˜"})';
  }
}

// ì „ì²´ ì½”ë“œê°€ ì—¬ê¸°ì—...
*/\n\n// ====== lib/core/network/websocket/trade_ws_client.dart ======\n
import 'dart:convert';
import 'dart:math';
import '../../config/app_config.dart';
import '../../../domain/entities/trade.dart';
import '../../utils/logger.dart';
import 'base_ws_client.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ ë©€í‹° ìŠ¤íŠ¸ë¦¼ í´ë¼ì´ì–¸íŠ¸ (ë°±ì„œ 100% ì¤€ìˆ˜)
/// aggTrade + ticker + bookTicker + depth5 í†µí•© ì§€ì›
class TradeWsClient extends BaseWsClient<Trade> {
  
  /// âœ… [ì¶”ê°€] êµ¬ë…í•  ìŠ¤íŠ¸ë¦¼ êµ¬ì„± ì„¤ì •
  final StreamSubscriptionConfig config;
  final bool enableVerboseLogging;

  TradeWsClient({
    void Function(WsStatus status)? onStatusChange,
    this.enableVerboseLogging = false,
    StreamSubscriptionConfig? config,
  }) : config = config ?? StreamSubscriptionConfig.defaultConfig(),
        super(
          url: AppConfig.streamUrl,
          onStatusChange: onStatusChange,
          pongTimeout: AppConfig.wsPongTimeout,
          // âœ… maxStreams, maxMessagesPerSec ì œê±° (AppConfig ê¸°ë³¸ê°’ ìë™ ì‚¬ìš©)
          encodeSubscribe: (markets) => _encodeSubscribeMessage(markets, config ?? StreamSubscriptionConfig.defaultConfig()),
          decode: (json) => _decodeTradeMessage(json, enableVerboseLogging),
        );

  // ===================================================================
  // ğŸ“¨ ê³„ì¸µì  ë©€í‹° ìŠ¤íŠ¸ë¦¼ êµ¬ë… ë©”ì‹œì§€ ì¸ì½”ë”© (ì¤‘ë³µ ë°©ì§€)
  // ===================================================================

  static String _encodeSubscribeMessage(List<String> markets, StreamSubscriptionConfig config) {
    final params = <String>[];
    
    // ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜ ê³„ì‚° ë° ì œí•œ ì²´í¬
    final totalStreams = _calculateTotalStreams(markets.length, config);
    if (totalStreams > AppConfig.wsMaxStreams) {
      throw ArgumentError('Too many streams: $totalStreams. '
          'Binance limit: ${AppConfig.wsMaxStreams} streams per connection.');
    }

    // ===================================================================
    // ğŸ¯ ê³„ì¸µì  êµ¬ë… ì „ëµ (Tiered Subscription)
    // ===================================================================
    
    // ìƒìœ„ ì‹¬ë³¼ë“¤: ëª¨ë“  ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì™„ì „ ë¶„ì„
    final coreSymbols = markets.take(config.aggTradeCount);
    final coreSymbolsList = coreSymbols.toList();
    
    log.i('[TradeWS] ğŸ¯ Core symbols (ì™„ì „ ë¶„ì„): ${coreSymbolsList.length}ê°œ');
    
    // âœ… 1. aggTrade ìŠ¤íŠ¸ë¦¼ (ìƒìœ„ ì‹¬ë³¼ë§Œ - ìƒì„¸ ê±°ë˜ ë°ì´í„°)
    if (config.aggTradeCount > 0) {
      params.addAll(
        coreSymbolsList.map((symbol) => '${symbol.toLowerCase()}@aggTrade'),
      );
      log.i('[TradeWS] ğŸ“ˆ Added ${coreSymbolsList.length} aggTrade streams (Core tier)');
    }

    // âœ… 2. ticker ìŠ¤íŠ¸ë¦¼ (ìƒìœ„ + ì¤‘ìœ„ ì‹¬ë³¼ë“¤)
    if (config.tickerCount > 0) {
      final tickerSymbols = markets.take(config.tickerCount).toList();
      params.addAll(
        tickerSymbols.map((symbol) => '${symbol.toLowerCase()}@ticker'),
      );
      log.i('[TradeWS] ğŸ“Š Added ${tickerSymbols.length} ticker streams (Core + Mid tier)');
    }

    // âœ… 3. bookTicker ìŠ¤íŠ¸ë¦¼ (ìƒìœ„ ì‹¬ë³¼ë§Œ - ì •ë°€ í˜¸ê°€ ë°ì´í„°)
    if (config.bookTickerCount > 0) {
      final bookTickerSymbols = coreSymbolsList.take(config.bookTickerCount).toList();
      params.addAll(
        bookTickerSymbols.map((symbol) => '${symbol.toLowerCase()}@bookTicker'),
      );
      log.i('[TradeWS] ğŸ’° Added ${bookTickerSymbols.length} bookTicker streams (Core tier only)');
    }

    // âœ… 4. depth5 ìŠ¤íŠ¸ë¦¼ (ìƒìœ„ ì‹¬ë³¼ë§Œ - ì„¸ë¶€ í˜¸ê°€ì°½)
    if (config.depth5Count > 0) {
      final depth5Symbols = coreSymbolsList.take(config.depth5Count).toList();
      params.addAll(
        depth5Symbols.map((symbol) => '${symbol.toLowerCase()}@depth5'),
      );
      log.i('[TradeWS] ğŸ“‹ Added ${depth5Symbols.length} depth5 streams (Core tier only)');
    }

    final messageId = _generateUniqueMessageId();
    final subscribeMessage = {
      'method': 'SUBSCRIBE',
      'params': params,
      'id': messageId,
    };

    final jsonMessage = jsonEncode(subscribeMessage);

    log.i('[TradeWS] ğŸ¯ ê³„ì¸µì  êµ¬ë… ì™„ë£Œ - ì´ ${params.length}ê°œ ìŠ¤íŠ¸ë¦¼');
    log.i('[TradeWS] - Core tier (${coreSymbolsList.length}ê°œ): ëª¨ë“  ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì™„ì „ ë¶„ì„');
    log.i('[TradeWS] - Mid tier (${config.tickerCount - coreSymbolsList.length}ê°œ): tickerë¡œ ê¸°ë³¸ ëª¨ë‹ˆí„°ë§');
    log.d('[TradeWS] Subscription message: $jsonMessage');

    return jsonMessage;
  }

  /// ì´ ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜ ê³„ì‚° (ê³„ì¸µì  êµ¬ë… ê³ ë ¤)
  static int _calculateTotalStreams(int marketCount, StreamSubscriptionConfig config) {
    // Core tier: aggTrade ê°œìˆ˜ë§Œí¼ì˜ ì‹¬ë³¼ì´ ëª¨ë“  ìŠ¤íŠ¸ë¦¼ êµ¬ë…
    final coreSymbolCount = config.aggTradeCount > marketCount ? marketCount : config.aggTradeCount;
    final coreStreams = coreSymbolCount * 4; // aggTrade + ticker + bookTicker + depth5
    
    // Mid tier: tickerë§Œ ì¶”ê°€ êµ¬ë… (core tier ì œì™¸)
    final midSymbolCount = (config.tickerCount - coreSymbolCount).clamp(0, marketCount - coreSymbolCount);
    final midStreams = midSymbolCount; // tickerë§Œ
    
    return coreStreams + midStreams;
  }

  /// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ í˜¸í™˜ ê³ ìœ  ë©”ì‹œì§€ ID ìƒì„± (String ë°˜í™˜)
  static String _generateUniqueMessageId() {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final randomPart = Random().nextInt(99999).toString().padLeft(5, '0');
    return '$timestamp$randomPart';
  }

  // ===================================================================
  // ğŸ“¥ ë©€í‹° ìŠ¤íŠ¸ë¦¼ ë©”ì‹œì§€ ë””ì½”ë”© (ë°”ì´ë‚¸ìŠ¤ Combined Stream ì²˜ë¦¬)
  // ===================================================================

  static Trade? _decodeTradeMessage(Map<String, dynamic> json, bool verboseLogging) {
    if (json.isEmpty) {
      if (verboseLogging) log.w('[TradeWS] Empty message received');
      return null;
    }

    // êµ¬ë… í™•ì¸ ë©”ì‹œì§€ ì²˜ë¦¬
    if (json.containsKey('result')) {
      if (json['result'] == null) {
        log.i('[TradeWS] âœ… Subscription confirmed: ${json['id']}');
      } else if (json['result'] is List) {
        final subscriptions = json['result'] as List;
        log.i('[TradeWS] ğŸ“‹ Active subscriptions: ${subscriptions.length}');
        if (verboseLogging) {
          log.d('[TradeWS] Subscriptions: $subscriptions');
        }
      }
      return null;
    }

    // Combined Stream ë©”ì‹œì§€ ì²˜ë¦¬
    if (json.containsKey('stream') && json.containsKey('data')) {
      final streamName = json['stream'] as String?;
      final data = json['data'];

      if (streamName == null || data == null) {
        return null;
      }

      return _parseStreamData(streamName, data, verboseLogging);
    }

    // Direct Stream ë©”ì‹œì§€ ì²˜ë¦¬ (Combined ì•„ë‹Œ ê²½ìš°)
    if (json.containsKey('e')) {
      final eventType = json['e'] as String;
      return _parseDirectStreamData(eventType, json, verboseLogging);
    }

    if (verboseLogging) {
      log.w('[TradeWS] Unknown message type: ${json.keys.join(', ')}');
    }
    return null;
  }

  /// âœ… Combined Stream ë°ì´í„° íŒŒì‹±
  static Trade? _parseStreamData(String streamName, dynamic data, bool verboseLogging) {
    try {
      if (data is! Map<String, dynamic>) {
        return null;
      }

      // ìŠ¤íŠ¸ë¦¼ íƒ€ì… íŒë³„
      if (streamName.endsWith('@aggTrade')) {
        return _parseAggTradeData(data, streamName, verboseLogging);
      } else if (streamName.endsWith('@ticker')) {
        return _parseTickerData(data, streamName, verboseLogging);
      } else if (streamName.endsWith('@bookTicker')) {
        return _parseBookTickerData(data, streamName, verboseLogging);
      } else if (streamName.endsWith('@depth5')) {
        return _parseDepth5Data(data, streamName, verboseLogging);
      }

      if (verboseLogging) {
        log.w('[TradeWS] Unsupported stream type: $streamName');
      }
      return null;
    } catch (e, st) {
      log.e('[TradeWS] Stream parsing failed ($streamName)', e, st);
      return null;
    }
  }

  /// âœ… Direct Stream ë°ì´í„° íŒŒì‹±
  static Trade? _parseDirectStreamData(String eventType, Map<String, dynamic> data, bool verboseLogging) {
    try {
      switch (eventType) {
        case 'aggTrade':
          return _parseAggTradeData(data, 'direct', verboseLogging);
        case '24hrTicker':
          return _parseTickerData(data, 'direct', verboseLogging);
        default:
          if (verboseLogging) {
            log.w('[TradeWS] Unsupported event type: $eventType');
          }
          return null;
      }
    } catch (e, st) {
      log.e('[TradeWS] Direct stream parsing failed ($eventType)', e, st);
      return null;
    }
  }

  /// ğŸ¯ aggTrade ë°ì´í„° íŒŒì‹±
  static Trade? _parseAggTradeData(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    if (data['e'] != 'aggTrade') return null;

    final trade = Trade.fromAggTrade(data);

    if (verboseLogging) {
      final symbol = data['s'] as String? ?? 'UNKNOWN';
      final price = data['p'] as String? ?? '0';
      final quantity = data['q'] as String? ?? '0';
      log.d('[TradeWS] ğŸ’° $symbol: $price Ã— $quantity (aggTrade: $streamInfo)');
    }

    return trade;
  }

  /// âœ… ticker ë°ì´í„° íŒŒì‹±
  static Trade? _parseTickerData(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    if (data['e'] != '24hrTicker') return null;

    final trade = Trade.fromTicker(data);

    if (verboseLogging) {
      final symbol = data['s'] as String? ?? 'UNKNOWN';
      final price = data['c'] as String? ?? '0';
      final change = data['P'] as String? ?? '0';
      log.d('[TradeWS] ğŸ“Š $symbol: $price ($change%) (ticker: $streamInfo)');
    }

    return trade;
  }

  /// âœ… bookTicker ë°ì´í„° íŒŒì‹±
  static Trade? _parseBookTickerData(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    // bookTickerì—ëŠ” 'e' í•„ë“œê°€ ì—†ìŒ
    if (!data.containsKey('u') || !data.containsKey('s')) return null;

    final trade = Trade.fromBookTicker(data);

    if (verboseLogging) {
      final symbol = data['s'] as String? ?? 'UNKNOWN';
      final bidPrice = data['b'] as String? ?? '0';
      final askPrice = data['a'] as String? ?? '0';
      log.d('[TradeWS] ğŸ’° $symbol: bid $bidPrice / ask $askPrice (bookTicker: $streamInfo)');
    }

    return trade;
  }

  /// âœ… depth5 ë°ì´í„° íŒŒì‹±
  static Trade? _parseDepth5Data(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    if (!data.containsKey('bids') || !data.containsKey('asks')) return null;

    // streamInfoì—ì„œ ì‹¬ë³¼ ì¶”ì¶œ
    final symbol = _extractSymbolFromStreamName(streamInfo);
    final trade = Trade.fromDepth5(data, symbol);

    if (verboseLogging) {
      final bids = data['bids'] as List;
      final asks = data['asks'] as List;
      final bestBid = bids.isNotEmpty ? bids[0][0] : '0';
      final bestAsk = asks.isNotEmpty ? asks[0][0] : '0';
      log.d('[TradeWS] ğŸ“‹ $symbol: bid $bestBid / ask $bestAsk (depth5: $streamInfo)');
    }

    return trade;
  }

  /// ìŠ¤íŠ¸ë¦¼ ì´ë¦„ì—ì„œ ì‹¬ë³¼ ì¶”ì¶œ
  static String _extractSymbolFromStreamName(String streamName) {
    if (streamName.contains('@')) {
      return streamName.split('@')[0].toUpperCase();
    }
    return 'UNKNOWN';
  }

  // ===================================================================
  // ğŸ“Š ë””ë²„ê·¸ ë° ëª¨ë‹ˆí„°ë§
  // ===================================================================

  /// í˜„ì¬ êµ¬ë… ì„¤ì • ì •ë³´
  Map<String, dynamic> getSubscriptionInfo() {
    return {
      'config': config.toMap(),
      'estimatedStreams': _calculateTotalStreams(100, config), // ê°€ì •: 100ê°œ ë§ˆì¼“
      'estimatedMessageRate': _estimateMessageRate(),
      'verboseLogging': enableVerboseLogging,
    };
  }

  /// ì˜ˆìƒ ë©”ì‹œì§€ ì†ë„ ê³„ì‚°
  int _estimateMessageRate() {
    return config.aggTradeCount * 50 +    // aggTrade: ~50/ì´ˆ
           config.tickerCount * 1 +       // ticker: ~1/ì´ˆ
           config.bookTickerCount * 10 +  // bookTicker: ~10/ì´ˆ
           config.depth5Count * 10;       // depth5: ~10/ì´ˆ
  }
}

/// âœ… ê³„ì¸µì  ìŠ¤íŠ¸ë¦¼ êµ¬ë… ì„¤ì • í´ë˜ìŠ¤
class StreamSubscriptionConfig {
  final int aggTradeCount;     // Core tier ì‹¬ë³¼ ìˆ˜ (ëª¨ë“  ìŠ¤íŠ¸ë¦¼ êµ¬ë…)
  final int tickerCount;       // Core + Mid tier ì‹¬ë³¼ ìˆ˜ (ticker êµ¬ë…)  
  final int bookTickerCount;   // Core tierì—ì„œ bookTicker êµ¬ë…í•  ì‹¬ë³¼ ìˆ˜
  final int depth5Count;       // Core tierì—ì„œ depth5 êµ¬ë…í•  ì‹¬ë³¼ ìˆ˜

  const StreamSubscriptionConfig({
    this.aggTradeCount = 0,
    this.tickerCount = 0,
    this.bookTickerCount = 0,
    this.depth5Count = 0,
  });

  /// ğŸ¯ ê³„ì¸µì  ê¸°ë³¸ ì„¤ì • (Core 30ê°œ ì™„ì „ë¶„ì„ + Mid 120ê°œ ê¸°ë³¸ëª¨ë‹ˆí„°ë§)
  factory StreamSubscriptionConfig.defaultConfig() {
  return const StreamSubscriptionConfig(
    aggTradeCount: 1,     // 30 â†’ 5 (250 msg/sec)
    tickerCount: 1,      // 150 â†’ 20 (20 msg/sec)  
    bookTickerCount: 1,   // 30 â†’ 5 (50 msg/sec)
    depth5Count: 1,       // 30 â†’ 0 (0 msg/sec)
  );
    // ê²°ê³¼: Core 30ê°œëŠ” 4ê°œ ìŠ¤íŠ¸ë¦¼, Mid 120ê°œëŠ” 1ê°œ ìŠ¤íŠ¸ë¦¼
    // ì´ ìŠ¤íŠ¸ë¦¼: (30 * 4) + (120 * 1) = 240ê°œ
  }

  /// ë³´ìˆ˜ì  ì„¤ì • (Core 20ê°œ + Mid 30ê°œ)
  factory StreamSubscriptionConfig.conservative() {
    return const StreamSubscriptionConfig(
      aggTradeCount: 20,    // Core: ìƒìœ„ 20ê°œë§Œ
      tickerCount: 50,      // Core 20ê°œ + Mid 30ê°œ
      bookTickerCount: 20,  // Core 20ê°œë§Œ
      depth5Count: 20,      // Core 20ê°œë§Œ
    );
    // ì´ ìŠ¤íŠ¸ë¦¼: (20 * 4) + (30 * 1) = 110ê°œ
  }

  /// ì§‘ì¤‘ ë¶„ì„ ì„¤ì • (Core 50ê°œ ì™„ì „ë¶„ì„)
  factory StreamSubscriptionConfig.intensive() {
    return const StreamSubscriptionConfig(
      aggTradeCount: 50,    // Core: ìƒìœ„ 50ê°œ ì‹¬ë³¼
      tickerCount: 100,     // Core 50ê°œ + Mid 50ê°œ
      bookTickerCount: 50,  // Core 50ê°œ ì „ì²´
      depth5Count: 50,      // Core 50ê°œ ì „ì²´  
    );
    // ì´ ìŠ¤íŠ¸ë¦¼: (50 * 4) + (50 * 1) = 250ê°œ
  }

  /// aggTradeë§Œ êµ¬ë… (ê¸°ì¡´ í˜¸í™˜)
  factory StreamSubscriptionConfig.aggTradeOnly(int count) {
    return StreamSubscriptionConfig(
      aggTradeCount: count,
      tickerCount: count,    // aggTradeì™€ ê°™ì€ ì‹¬ë³¼ì— tickerë„ ì¶”ê°€
      bookTickerCount: 0,
      depth5Count: 0,
    );
  }

  /// Core tier ì‹¬ë³¼ ê°œìˆ˜ (ëª¨ë“  ìŠ¤íŠ¸ë¦¼ êµ¬ë…)
  int get coreSymbolCount => aggTradeCount;
  
  /// Mid tier ì‹¬ë³¼ ê°œìˆ˜ (tickerë§Œ êµ¬ë…)
  int get midSymbolCount => (tickerCount - aggTradeCount).clamp(0, double.infinity).toInt();

  /// ì´ êµ¬ë… ì‹¬ë³¼ ê°œìˆ˜
  int get totalSymbolCount => tickerCount;

  /// ì´ ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜ (ê³„ì¸µì  ê³„ì‚°)
  int get totalStreamCount {
    final coreStreams = coreSymbolCount * 4; // 4ê°œ ìŠ¤íŠ¸ë¦¼ì”©
    final midStreams = midSymbolCount * 1;   // 1ê°œ ìŠ¤íŠ¸ë¦¼ì”©
    return coreStreams + midStreams;
  }

  /// ê³„ì¸µë³„ êµ¬ì„± ì •ë³´
  Map<String, dynamic> getTierBreakdown() {
    return {
      'core': {
        'symbolCount': coreSymbolCount,
        'streams': ['aggTrade', 'ticker', 'bookTicker', 'depth5'],
        'streamCount': coreSymbolCount * 4,
        'description': 'ì™„ì „ ë¶„ì„ (ëª¨ë“  ìŠ¤íŠ¸ë¦¼)',
      },
      'mid': {
        'symbolCount': midSymbolCount,
        'streams': ['ticker'],
        'streamCount': midSymbolCount * 1,
        'description': 'ê¸°ë³¸ ëª¨ë‹ˆí„°ë§ (tickerë§Œ)',
      },
    };
  }

  /// ë§µìœ¼ë¡œ ë³€í™˜
  Map<String, dynamic> toMap() {
    return {
      'aggTradeCount': aggTradeCount,
      'tickerCount': tickerCount,
      'bookTickerCount': bookTickerCount,
      'depth5Count': depth5Count,
      'coreSymbolCount': coreSymbolCount,
      'midSymbolCount': midSymbolCount,
      'totalSymbolCount': totalSymbolCount,
      'totalStreamCount': totalStreamCount,
      'tierBreakdown': getTierBreakdown(),
    };
  }

  @override
  String toString() {
    return 'StreamConfig(Core: ${coreSymbolCount}ê°œ ì™„ì „ë¶„ì„, Mid: ${midSymbolCount}ê°œ ê¸°ë³¸ëª¨ë‹ˆí„°ë§, ì´ ${totalStreamCount}ê°œ ìŠ¤íŠ¸ë¦¼)';
  }
}\n\n// ====== lib/core/network/websocket/trade_ws_client copy.dart ======\n
import 'dart:convert';
import 'dart:math';
import '../../config/app_config.dart';
import '../../../domain/entities/trade.dart';
import '../../utils/logger.dart';
import 'base_ws_client.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ ë©€í‹° ìŠ¤íŠ¸ë¦¼ í´ë¼ì´ì–¸íŠ¸ (ë°±ì„œ 100% ì¤€ìˆ˜)
/// aggTrade + ticker + bookTicker + depth5 í†µí•© ì§€ì›
class TradeWsClient extends BaseWsClient<Trade> {
  
  /// âœ… [ì¶”ê°€] êµ¬ë…í•  ìŠ¤íŠ¸ë¦¼ êµ¬ì„± ì„¤ì •
  final StreamSubscriptionConfig config;
  final bool enableVerboseLogging;

  TradeWsClient({
    void Function(WsStatus status)? onStatusChange,
    this.enableVerboseLogging = false,
    StreamSubscriptionConfig? config,
  }) : config = config ?? StreamSubscriptionConfig.defaultConfig(),
        super(
          url: AppConfig.streamUrl,
          onStatusChange: onStatusChange,
          pongTimeout: AppConfig.wsPongTimeout,
          // âœ… maxStreams, maxMessagesPerSec ì œê±° (AppConfig ê¸°ë³¸ê°’ ìë™ ì‚¬ìš©)
          encodeSubscribe: (markets) => _encodeSubscribeMessage(markets, config ?? StreamSubscriptionConfig.defaultConfig()),
          decode: (json) => _decodeTradeMessage(json, enableVerboseLogging),
        );

  // ===================================================================
  // ğŸ“¨ ë©€í‹° ìŠ¤íŠ¸ë¦¼ êµ¬ë… ë©”ì‹œì§€ ì¸ì½”ë”© (ë°”ì´ë‚¸ìŠ¤ ë°±ì„œ ì¤€ìˆ˜)
  // ===================================================================

  static String _encodeSubscribeMessage(List<String> markets, StreamSubscriptionConfig config) {
    final params = <String>[];
    
    // ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜ ê³„ì‚° ë° ì œí•œ ì²´í¬
    final totalStreams = _calculateTotalStreams(markets.length, config);
    if (totalStreams > AppConfig.wsMaxStreams) {
      throw ArgumentError('Too many streams: $totalStreams. '
          'Binance limit: ${AppConfig.wsMaxStreams} streams per connection.');
    }

    // âœ… 1. aggTrade ìŠ¤íŠ¸ë¦¼ (ìƒì„¸ ê±°ë˜ ë°ì´í„°)
    if (config.aggTradeCount > 0) {
      final aggTradeMarkets = markets.take(config.aggTradeCount);
      params.addAll(
        aggTradeMarkets.map((symbol) => '${symbol.toLowerCase()}@aggTrade'),
      );
      log.i('[TradeWS] ğŸ“ˆ Added ${aggTradeMarkets.length} aggTrade streams');
    }

    // âœ… 2. ticker ìŠ¤íŠ¸ë¦¼ (24ì‹œê°„ í†µê³„)
    if (config.tickerCount > 0) {
      final tickerMarkets = markets.take(config.tickerCount);
      params.addAll(
        tickerMarkets.map((symbol) => '${symbol.toLowerCase()}@ticker'),
      );
      log.i('[TradeWS] ğŸ“Š Added ${tickerMarkets.length} ticker streams');
    }

    // âœ… 3. bookTicker ìŠ¤íŠ¸ë¦¼ (ìµœê³  í˜¸ê°€)
    if (config.bookTickerCount > 0) {
      final bookTickerMarkets = markets.take(config.bookTickerCount);
      params.addAll(
        bookTickerMarkets.map((symbol) => '${symbol.toLowerCase()}@bookTicker'),
      );
      log.i('[TradeWS] ğŸ’° Added ${bookTickerMarkets.length} bookTicker streams');
    }

    // âœ… 4. depth5 ìŠ¤íŠ¸ë¦¼ (5ë‹¨ê³„ í˜¸ê°€ì°½)
    if (config.depth5Count > 0) {
      final depth5Markets = markets.take(config.depth5Count);
      params.addAll(
        depth5Markets.map((symbol) => '${symbol.toLowerCase()}@depth5'),
      );
      log.i('[TradeWS] ğŸ“‹ Added ${depth5Markets.length} depth5 streams');
    }

    final messageId = _generateUniqueMessageId();
    final subscribeMessage = {
      'method': 'SUBSCRIBE',
      'params': params,
      'id': messageId,
    };

    final jsonMessage = jsonEncode(subscribeMessage);

    log.i('[TradeWS] ğŸ¯ ì´ ${params.length}ê°œ ìŠ¤íŠ¸ë¦¼ êµ¬ë… (Markets: ${markets.length})');
    log.d('[TradeWS] Subscription message: $jsonMessage');

    return jsonMessage;
  }

  /// ì´ ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜ ê³„ì‚°
  static int _calculateTotalStreams(int marketCount, StreamSubscriptionConfig config) {
    return [
      config.aggTradeCount,
      config.tickerCount,
      config.bookTickerCount,
      config.depth5Count,
    ].map((count) => count > marketCount ? marketCount : count).fold(0, (a, b) => a + b);
  }

  /// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ í˜¸í™˜ ê³ ìœ  ë©”ì‹œì§€ ID ìƒì„± (String ë°˜í™˜)
  static String _generateUniqueMessageId() {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final randomPart = Random().nextInt(99999).toString().padLeft(5, '0');
    return '$timestamp$randomPart';
  }

  // ===================================================================
  // ğŸ“¥ ë©€í‹° ìŠ¤íŠ¸ë¦¼ ë©”ì‹œì§€ ë””ì½”ë”© (ë°”ì´ë‚¸ìŠ¤ Combined Stream ì²˜ë¦¬)
  // ===================================================================

  static Trade? _decodeTradeMessage(Map<String, dynamic> json, bool verboseLogging) {
    if (json.isEmpty) {
      if (verboseLogging) log.w('[TradeWS] Empty message received');
      return null;
    }

    // êµ¬ë… í™•ì¸ ë©”ì‹œì§€ ì²˜ë¦¬
    if (json.containsKey('result')) {
      if (json['result'] == null) {
        log.i('[TradeWS] âœ… Subscription confirmed: ${json['id']}');
      } else if (json['result'] is List) {
        final subscriptions = json['result'] as List;
        log.i('[TradeWS] ğŸ“‹ Active subscriptions: ${subscriptions.length}');
        if (verboseLogging) {
          log.d('[TradeWS] Subscriptions: $subscriptions');
        }
      }
      return null;
    }

    // Combined Stream ë©”ì‹œì§€ ì²˜ë¦¬
    if (json.containsKey('stream') && json.containsKey('data')) {
      final streamName = json['stream'] as String?;
      final data = json['data'];

      if (streamName == null || data == null) {
        return null;
      }

      return _parseStreamData(streamName, data, verboseLogging);
    }

    // Direct Stream ë©”ì‹œì§€ ì²˜ë¦¬ (Combined ì•„ë‹Œ ê²½ìš°)
    if (json.containsKey('e')) {
      final eventType = json['e'] as String;
      return _parseDirectStreamData(eventType, json, verboseLogging);
    }

    if (verboseLogging) {
      log.w('[TradeWS] Unknown message type: ${json.keys.join(', ')}');
    }
    return null;
  }

  /// âœ… Combined Stream ë°ì´í„° íŒŒì‹±
  static Trade? _parseStreamData(String streamName, dynamic data, bool verboseLogging) {
    try {
      if (data is! Map<String, dynamic>) {
        return null;
      }

      // ìŠ¤íŠ¸ë¦¼ íƒ€ì… íŒë³„
      if (streamName.endsWith('@aggTrade')) {
        return _parseAggTradeData(data, streamName, verboseLogging);
      } else if (streamName.endsWith('@ticker')) {
        return _parseTickerData(data, streamName, verboseLogging);
      } else if (streamName.endsWith('@bookTicker')) {
        return _parseBookTickerData(data, streamName, verboseLogging);
      } else if (streamName.endsWith('@depth5')) {
        return _parseDepth5Data(data, streamName, verboseLogging);
      }

      if (verboseLogging) {
        log.w('[TradeWS] Unsupported stream type: $streamName');
      }
      return null;
    } catch (e, st) {
      log.e('[TradeWS] Stream parsing failed ($streamName)', e, st);
      return null;
    }
  }

  /// âœ… Direct Stream ë°ì´í„° íŒŒì‹±
  static Trade? _parseDirectStreamData(String eventType, Map<String, dynamic> data, bool verboseLogging) {
    try {
      switch (eventType) {
        case 'aggTrade':
          return _parseAggTradeData(data, 'direct', verboseLogging);
        case '24hrTicker':
          return _parseTickerData(data, 'direct', verboseLogging);
        default:
          if (verboseLogging) {
            log.w('[TradeWS] Unsupported event type: $eventType');
          }
          return null;
      }
    } catch (e, st) {
      log.e('[TradeWS] Direct stream parsing failed ($eventType)', e, st);
      return null;
    }
  }

  /// ğŸ¯ aggTrade ë°ì´í„° íŒŒì‹±
  static Trade? _parseAggTradeData(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    if (data['e'] != 'aggTrade') return null;

    final trade = Trade.fromAggTrade(data);

    if (verboseLogging) {
      final symbol = data['s'] as String? ?? 'UNKNOWN';
      final price = data['p'] as String? ?? '0';
      final quantity = data['q'] as String? ?? '0';
      log.d('[TradeWS] ğŸ’° $symbol: $price Ã— $quantity (aggTrade: $streamInfo)');
    }

    return trade;
  }

  /// âœ… ticker ë°ì´í„° íŒŒì‹±
  static Trade? _parseTickerData(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    if (data['e'] != '24hrTicker') return null;

    final trade = Trade.fromTicker(data);

    if (verboseLogging) {
      final symbol = data['s'] as String? ?? 'UNKNOWN';
      final price = data['c'] as String? ?? '0';
      final change = data['P'] as String? ?? '0';
      log.d('[TradeWS] ğŸ“Š $symbol: $price ($change%) (ticker: $streamInfo)');
    }

    return trade;
  }

  /// âœ… bookTicker ë°ì´í„° íŒŒì‹±
  static Trade? _parseBookTickerData(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    // bookTickerì—ëŠ” 'e' í•„ë“œê°€ ì—†ìŒ
    if (!data.containsKey('u') || !data.containsKey('s')) return null;

    final trade = Trade.fromBookTicker(data);

    if (verboseLogging) {
      final symbol = data['s'] as String? ?? 'UNKNOWN';
      final bidPrice = data['b'] as String? ?? '0';
      final askPrice = data['a'] as String? ?? '0';
      log.d('[TradeWS] ğŸ’° $symbol: bid $bidPrice / ask $askPrice (bookTicker: $streamInfo)');
    }

    return trade;
  }

  /// âœ… depth5 ë°ì´í„° íŒŒì‹±
  static Trade? _parseDepth5Data(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    if (!data.containsKey('bids') || !data.containsKey('asks')) return null;

    // streamInfoì—ì„œ ì‹¬ë³¼ ì¶”ì¶œ
    final symbol = _extractSymbolFromStreamName(streamInfo);
    final trade = Trade.fromDepth5(data, symbol);

    if (verboseLogging) {
      final bids = data['bids'] as List;
      final asks = data['asks'] as List;
      final bestBid = bids.isNotEmpty ? bids[0][0] : '0';
      final bestAsk = asks.isNotEmpty ? asks[0][0] : '0';
      log.d('[TradeWS] ğŸ“‹ $symbol: bid $bestBid / ask $bestAsk (depth5: $streamInfo)');
    }

    return trade;
  }

  /// ìŠ¤íŠ¸ë¦¼ ì´ë¦„ì—ì„œ ì‹¬ë³¼ ì¶”ì¶œ
  static String _extractSymbolFromStreamName(String streamName) {
    if (streamName.contains('@')) {
      return streamName.split('@')[0].toUpperCase();
    }
    return 'UNKNOWN';
  }

  // ===================================================================
  // ğŸ“Š ë””ë²„ê·¸ ë° ëª¨ë‹ˆí„°ë§
  // ===================================================================

  /// í˜„ì¬ êµ¬ë… ì„¤ì • ì •ë³´
  Map<String, dynamic> getSubscriptionInfo() {
    return {
      'config': config.toMap(),
      'estimatedStreams': _calculateTotalStreams(100, config), // ê°€ì •: 100ê°œ ë§ˆì¼“
      'estimatedMessageRate': _estimateMessageRate(),
      'verboseLogging': enableVerboseLogging,
    };
  }

  /// ì˜ˆìƒ ë©”ì‹œì§€ ì†ë„ ê³„ì‚°
  int _estimateMessageRate() {
    return config.aggTradeCount * 50 +    // aggTrade: ~50/ì´ˆ
           config.tickerCount * 1 +       // ticker: ~1/ì´ˆ
           config.bookTickerCount * 10 +  // bookTicker: ~10/ì´ˆ
           config.depth5Count * 10;       // depth5: ~10/ì´ˆ
  }
}

/// âœ… ìŠ¤íŠ¸ë¦¼ êµ¬ë… ì„¤ì • í´ë˜ìŠ¤
class StreamSubscriptionConfig {
  final int aggTradeCount;     // aggTrade ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜
  final int tickerCount;       // ticker ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜  
  final int bookTickerCount;   // bookTicker ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜
  final int depth5Count;       // depth5 ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜

  const StreamSubscriptionConfig({
    this.aggTradeCount = 0,
    this.tickerCount = 0,
    this.bookTickerCount = 0,
    this.depth5Count = 0,
  });

  /// ê¸°ë³¸ ì„¤ì • (ìš°ë¦¬ê°€ ê³„íší•œ 400ê°œ ìŠ¤íŠ¸ë¦¼)
  factory StreamSubscriptionConfig.defaultConfig() {
    return const StreamSubscriptionConfig(
      aggTradeCount: 100,    // Trade + Volumeìš©
      tickerCount: 150,      // Surgeìš©
      bookTickerCount: 100,  // í˜¸ê°€ìš©
      depth5Count: 50,       // ì„¸ë¶€ í˜¸ê°€ìš©
    );
  }

  /// aggTradeë§Œ êµ¬ë… (ê¸°ì¡´ ë°©ì‹ í˜¸í™˜)
  factory StreamSubscriptionConfig.aggTradeOnly(int count) {
    return StreamSubscriptionConfig(aggTradeCount: count);
  }

  /// ë³´ìˆ˜ì  ì„¤ì • (ì ì€ ìŠ¤íŠ¸ë¦¼)
  factory StreamSubscriptionConfig.conservative() {
    return const StreamSubscriptionConfig(
      aggTradeCount: 30,
      tickerCount: 50,
      bookTickerCount: 30,
      depth5Count: 20,
    );
  }

  /// ì´ ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜
  int get totalCount => aggTradeCount + tickerCount + bookTickerCount + depth5Count;

  /// ë§µìœ¼ë¡œ ë³€í™˜
  Map<String, dynamic> toMap() {
    return {
      'aggTradeCount': aggTradeCount,
      'tickerCount': tickerCount,
      'bookTickerCount': bookTickerCount,
      'depth5Count': depth5Count,
      'totalCount': totalCount,
    };
  }

  @override
  String toString() {
    return 'StreamConfig(aggTrade: $aggTradeCount, ticker: $tickerCount, '
           'bookTicker: $bookTickerCount, depth5: $depth5Count, total: $totalCount)';
  }
}\n\n// ====== lib/data/datasources/trade_remote_ds.dart ======\n
// lib/data/datasources/trade_remote_ds.dart

import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import '../../../core/bridge/signal_bus.dart';
import '../../../core/event/app_event.dart';
import '../../../core/network/websocket/trade_ws_client.dart';
import '../../domain/entities/trade.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ ì‹¤ì‹œê°„ Trade ë°ì´í„° ì†ŒìŠ¤ (ì—…ë¹„íŠ¸ ìŠ¤íƒ€ì¼ ë¸Œë¡œë“œìºìŠ¤íŠ¸)
/// - ë©€í‹° ìŠ¤íŠ¸ë¦¼ ì§€ì› (aggTrade, ticker, bookTicker, depth5)
/// - ë¸Œë¡œë“œìºìŠ¤íŠ¸ë¡œ ì—¬ëŸ¬ Repository ë™ì‹œ êµ¬ë… ê°€ëŠ¥
/// - ì—ëŸ¬ ì‹œ ìë™ í´ë°±ìœ¼ë¡œ ì•ˆì •ì„± í™•ë³´
class TradeRemoteDataSource {
  final TradeWsClient _ws;
  final SignalBus _signalBus;
  final bool _useTestData;

  // ğŸ†• ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì‹œìŠ¤í…œ
  StreamController<Trade>? _masterController;
  StreamSubscription<Trade>? _wsSub; // âœ… íƒ€ì… ìˆ˜ì •: Tradeë¡œ ì§ì ‘ ë°›ê¸°
  bool _disposed = false;
  List<String>? _currentMarkets; // í˜„ì¬ êµ¬ë… ì¤‘ì¸ ë§ˆì¼“ë“¤
  int _subscriberCount = 0; // êµ¬ë…ì ìˆ˜ ì¶”ì 

  // ğŸ“Š ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
  int _messageCount = 0;
  DateTime? _lastMessageTime;
  Timer? _performanceTimer;

  TradeRemoteDataSource(
    this._ws,
    this._signalBus, {
    bool useTestData = false,
  }) : _useTestData = useTestData {
    _startPerformanceMonitoring();
  }

  /// ğŸ†• ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì œê³µ - ì—¬ëŸ¬ Repositoryê°€ êµ¬ë… ê°€ëŠ¥
  Stream<Trade> watch(List<String> markets) {
    if (_useTestData) return _testStream();

    // dispose í›„ ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ë„ë¡ ì´ˆê¸°í™”
    if (_disposed) {
      debugPrint('TradeRemoteDataSource: resetting after dispose');
      _disposed = false;
    }

    // ğŸ†• ë™ì¼í•œ ë§ˆì¼“ì´ë©´ ê¸°ì¡´ ìŠ¤íŠ¸ë¦¼ ì¬ì‚¬ìš©
    if (_masterController != null && 
        _currentMarkets != null && 
        _marketsEqual(_currentMarkets!, markets)) {
      debugPrint('TradeRemoteDataSource: reusing existing broadcast stream for ${markets.length} markets');
      return _masterController!.stream;
    }

    // ğŸ†• ìƒˆë¡œìš´ ë§ˆì¼“ì´ë©´ ê¸°ì¡´ ìŠ¤íŠ¸ë¦¼ ì •ë¦¬í•˜ê³  ìƒˆë¡œ ìƒì„±
    _cleanupMasterStream();
    _initializeMasterStream(markets);

    return _masterController!.stream;
  }

  /// ğŸ†• ë§ˆìŠ¤í„° ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
  void _initializeMasterStream(List<String> markets) {
    debugPrint('TradeRemoteDataSource: initializing master broadcast stream for ${markets.length} markets');
    
    _currentMarkets = List<String>.from(markets);
    
    _masterController = StreamController<Trade>.broadcast(
      onListen: () {
        _subscriberCount++;
        debugPrint('TradeRemoteDataSource: subscriber added (total: $_subscriberCount)');
        
        // ì²« ë²ˆì§¸ êµ¬ë…ìì¼ ë•Œë§Œ WebSocket ì‹œì‘
        if (_subscriberCount == 1 && !_disposed) {
          _startWebSocket(markets);
        }
      },
      onCancel: () {
        _subscriberCount--;
        debugPrint('TradeRemoteDataSource: subscriber removed (remaining: $_subscriberCount)');
        
        // ëª¨ë“  êµ¬ë…ìê°€ ë– ë‚˜ë©´ WebSocket ì •ë¦¬ (5ì´ˆ ì§€ì—°)
        if (_subscriberCount <= 0) {
          Timer(const Duration(seconds: 5), () {
            if (_subscriberCount <= 0 && !_disposed) {
              debugPrint('TradeRemoteDataSource: no subscribers, cleaning up WebSocket');
              _cleanupWebSocket();
            }
          });
        }
      },
    );
  }

  /// ğŸ†• WebSocket ì—°ê²° ì‹œì‘
  void _startWebSocket(List<String> markets) {
    if (_disposed) return;

    try {
      debugPrint('TradeRemoteDataSource: starting WebSocket for ${markets.length} markets');
      
      _ws.connect(markets);
      
      // âœ… ë‹¨ìˆœí™”: Trade ìŠ¤íŠ¸ë¦¼ì„ ì§ì ‘ êµ¬ë…
      _wsSub = _ws.stream.listen(
        (trade) {
          // controllerê°€ ë‹«í˜”ê±°ë‚˜ disposedë©´ ì²˜ë¦¬ ì•ˆí•¨
          if (_disposed || _masterController == null || _masterController!.isClosed) {
            debugPrint('TradeRemoteDataSource: skipping data - disposed or closed');
            return;
          }

          // âœ… ë°ì´í„° ê²€ì¦ ì¶”ê°€
          if (!trade.isValidData) {
            debugPrint('TradeRemoteDataSource: invalid trade data for ${trade.market}');
            return;
          }

          // ğŸ¯ ì„±ëŠ¥ ì¹´ìš´í„° ì—…ë°ì´íŠ¸
          _messageCount++;
          _lastMessageTime = DateTime.now();

          // ğŸ†• ë§ˆìŠ¤í„° ì»¨íŠ¸ë¡¤ëŸ¬ì— ë¸Œë¡œë“œìºìŠ¤íŠ¸
          if (!_disposed && _masterController != null && !_masterController!.isClosed) {
            _masterController!.add(trade);
          }

          // ğŸ¯ ìŠ¤íŠ¸ë¦¼ íƒ€ì…ë³„ ì´ë²¤íŠ¸ ë°œìƒ (SignalBus í™œìš©)
          _fireSignalBusEvent(trade);
        },
        onError: (error, stackTrace) {
          debugPrint('WebSocket error: $error');
          // âœ… ì—ëŸ¬ ì‹œ í´ë°± ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì „í™˜
          if (!_disposed && _masterController != null && !_masterController!.isClosed) {
            debugPrint('TradeRemoteDataSource: switching to fallback stream');
            _masterController!.addStream(_testStream());
          }
        },
        onDone: () {
          debugPrint('WebSocket done - connection closed');
          // âœ… ì—°ê²° ì¢…ë£Œ ì‹œ í´ë°± ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì „í™˜
          if (!_disposed && _masterController != null && !_masterController!.isClosed) {
            debugPrint('TradeRemoteDataSource: switching to fallback stream');
            _masterController!.addStream(_testStream());
          }
        },
        cancelOnError: false, // ì—ëŸ¬ê°€ ë‚˜ë„ ìŠ¤íŠ¸ë¦¼ ìœ ì§€
      );
      
      debugPrint('TradeRemoteDataSource: WebSocket stream subscription established');
      
    } catch (e, st) {
      debugPrint('WS connection failed: $e');
      debugPrint('Stack trace: $st');
      
      // âœ… ì—°ê²° ì‹¤íŒ¨ ì‹œ ì¦‰ì‹œ í´ë°± ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì „í™˜
      if (!_disposed && _masterController != null && !_masterController!.isClosed) {
        debugPrint('TradeRemoteDataSource: connection failed, using fallback stream');
        _masterController!.addStream(_testStream());
      }
    }
  }

  /// ğŸ¯ ìŠ¤íŠ¸ë¦¼ íƒ€ì…ë³„ SignalBus ì´ë²¤íŠ¸ ë°œìƒ
  void _fireSignalBusEvent(Trade trade) {
    try {
      // Trade ê°ì²´ë¥¼ JSONìœ¼ë¡œ ë³€í™˜
      final tradeData = trade.toDebugMap();
      
      // ìŠ¤íŠ¸ë¦¼ íƒ€ì…ë³„ë¡œ ë‹¤ë¥¸ ì´ë²¤íŠ¸ ë°œìƒ
      switch (trade.streamType) {
        case BinanceStreamType.aggTrade:
          _signalBus.fireAggTrade(tradeData);
          break;
        case BinanceStreamType.ticker:
          _signalBus.fireTicker(tradeData);
          break;
        case BinanceStreamType.bookTicker:
          _signalBus.fireBookTicker(tradeData);
          break;
        case BinanceStreamType.depth5:
          _signalBus.fireDepth5(tradeData);
          break;
      }
      
      // âœ… ê¸°ì¡´ í˜¸í™˜ì„±ì„ ìœ„í•œ ì¼ë°˜ trade ì´ë²¤íŠ¸ë„ ë°œìƒ
      final appEvent = AppEvent.now(tradeData);
      _signalBus.fireTradeEvent(appEvent);
      
    } catch (e) {
      debugPrint('SignalBus event firing failed: $e');
    }
  }

  /// ğŸ†• WebSocketë§Œ ì •ë¦¬ (ì»¨íŠ¸ë¡¤ëŸ¬ëŠ” ìœ ì§€)
  void _cleanupWebSocket() {
    debugPrint('TradeRemoteDataSource: cleaning up WebSocket');
    _wsSub?.cancel();
    _wsSub = null;
  }

  /// ğŸ†• ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì™„ì „ ì •ë¦¬
  void _cleanupMasterStream() {
    debugPrint('TradeRemoteDataSource: cleaning up master stream');
    
    _cleanupWebSocket();
    
    if (_masterController != null && !_masterController!.isClosed) {
      _masterController!.close();
    }
    _masterController = null;
    _currentMarkets = null;
    _subscriberCount = 0;
  }

  /// ğŸ†• ë§ˆì¼“ ë¦¬ìŠ¤íŠ¸ ë¹„êµ í—¬í¼
  bool _marketsEqual(List<String> a, List<String> b) {
    if (a.length != b.length) return false;
    final setA = Set<String>.from(a);
    final setB = Set<String>.from(b);
    return setA.containsAll(setB) && setB.containsAll(setA);
  }

  /// ğŸ“Š ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œì‘
  void _startPerformanceMonitoring() {
    _performanceTimer = Timer.periodic(const Duration(seconds: 10), (_) {
      if (_messageCount > 0) {
        final rate = _messageCount / 10; // ì´ˆë‹¹ ë©”ì‹œì§€ ìˆ˜
        debugPrint('TradeRemoteDataSource: ${rate.toStringAsFixed(1)} msg/sec, '
                  'subscribers: $_subscriberCount, '
                  'last: ${_lastMessageTime?.toString() ?? "none"}');
        _messageCount = 0; // ì¹´ìš´í„° ë¦¬ì…‹
      }
    });
  }

  /// ğŸ¯ ê°œì„ ëœ í…ŒìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ (ë°”ì´ë‚¸ìŠ¤ í˜•ì‹)
  Stream<Trade> _testStream() async* {
    final rnd = Random();
    const symbols = [
      'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'ADAUSDT', 'SOLUSDT',
      'XRPUSDT', 'DOTUSDT', 'LINKUSDT', 'LTCUSDT', 'MATICUSDT',
    ];

    const streamTypes = BinanceStreamType.values;

    while (!_disposed) {
      await Future.delayed(const Duration(milliseconds: 200)); // 5msg/sec
      if (_disposed) break;
      
      final nowMs = DateTime.now().millisecondsSinceEpoch;
      final symbol = symbols[rnd.nextInt(symbols.length)];
      final streamType = streamTypes[rnd.nextInt(streamTypes.length)];
      final basePrice = 50000.0 + rnd.nextDouble() * 10000; // 50k-60k ë²”ìœ„
      
      // âœ… ìŠ¤íŠ¸ë¦¼ íƒ€ì…ë³„ë¡œ ë‹¤ë¥¸ í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
      late Map<String, dynamic> testData;
      
      switch (streamType) {
        case BinanceStreamType.aggTrade:
          testData = {
            'e': 'aggTrade',
            's': symbol,
            'p': basePrice.toStringAsFixed(2),
            'q': (rnd.nextDouble() * 10).toStringAsFixed(4),
            'T': nowMs,
            'a': rnd.nextInt(1000000),
            'm': rnd.nextBool(),
          };
          break;
        case BinanceStreamType.ticker:
          testData = {
            'e': '24hrTicker',
            's': symbol,
            'c': basePrice.toStringAsFixed(2),
            'P': (rnd.nextDouble() * 10 - 5).toStringAsFixed(2), // -5% ~ +5%
            'h': (basePrice * 1.1).toStringAsFixed(2),
            'l': (basePrice * 0.9).toStringAsFixed(2),
            'v': (rnd.nextDouble() * 1000).toStringAsFixed(2),
            'q': (rnd.nextDouble() * 50000000).toStringAsFixed(2),
            'E': nowMs,
          };
          break;
        case BinanceStreamType.bookTicker:
          testData = {
            's': symbol,
            'b': (basePrice * 0.999).toStringAsFixed(2),
            'a': (basePrice * 1.001).toStringAsFixed(2),
            'B': (rnd.nextDouble() * 100).toStringAsFixed(4),
            'A': (rnd.nextDouble() * 100).toStringAsFixed(4),
            'u': rnd.nextInt(1000000),
          };
          break;
        case BinanceStreamType.depth5:
          testData = {
            'bids': [
              [(basePrice * 0.999).toStringAsFixed(2), (rnd.nextDouble() * 100).toStringAsFixed(4)],
              [(basePrice * 0.998).toStringAsFixed(2), (rnd.nextDouble() * 100).toStringAsFixed(4)],
            ],
            'asks': [
              [(basePrice * 1.001).toStringAsFixed(2), (rnd.nextDouble() * 100).toStringAsFixed(4)],
              [(basePrice * 1.002).toStringAsFixed(2), (rnd.nextDouble() * 100).toStringAsFixed(4)],
            ],
            'lastUpdateId': rnd.nextInt(1000000),
          };
          break;
      }
      
      try {
        final trade = Trade.fromBinanceStream(
          json: testData, 
          streamType: streamType,
          symbol: symbol,
        );
        
        yield trade;
        
        // í…ŒìŠ¤íŠ¸ ë°ì´í„°ë„ SignalBusì— ë°œìƒ
        _fireSignalBusEvent(trade);
        
      } catch (e) {
        debugPrint('Test data creation failed: $e');
      }
    }
  }

  /// ğŸ“Š í˜„ì¬ ìƒíƒœ ì •ë³´
  Map<String, dynamic> getStatus() {
    return {
      'isDisposed': _disposed,
      'subscriberCount': _subscriberCount,
      'currentMarkets': _currentMarkets?.length ?? 0,
      'hasMasterController': _masterController != null,
      'hasWebSocketSub': _wsSub != null,
      'messageCount': _messageCount,
      'lastMessageTime': _lastMessageTime?.toIso8601String(),
      'useTestData': _useTestData,
    };
  }

  /// Clean up resources when no longer needed.
  Future<void> dispose() async {
    if (_disposed) return;
    
    _disposed = true;
    
    debugPrint('TradeRemoteDataSource: disposing...');
    
    // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ íƒ€ì´ë¨¸ ì •ë¦¬
    _performanceTimer?.cancel();
    
    // ëª¨ë“  ë¦¬ì†ŒìŠ¤ ì •ë¦¬
    _cleanupMasterStream();
    
    debugPrint('TradeRemoteDataSource: disposed');
    
    // WebSocket í´ë¼ì´ì–¸íŠ¸ëŠ” ê³µìœ  ë¦¬ì†ŒìŠ¤ì´ë¯€ë¡œ disposeí•˜ì§€ ì•ŠìŒ
  }
}\n\n// ====== lib/data/repositories/trade_repository_impl.dart ======\n
// lib/data/repositories/trade_repository_impl.dart

import 'dart:async';
import 'dart:collection';
import 'package:flutter/foundation.dart';
import '../../core/config/app_config.dart';
import '../../core/common/time_frame_types.dart';
import '../../domain/entities/trade.dart';
import '../../domain/repositories/trade_repository.dart';
import '../datasources/trade_remote_ds.dart';
import '../processors/trade_aggregator.dart';
import '../../core/utils/logger.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ì „ìš© íš¨ìœ¨ì ì¸ ê±°ë˜ Repository (ì—…ë¹„íŠ¸ ìŠ¤íƒ€ì¼ ê°œì„ )
/// - ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë‹¨ì¼ ì†ŒìŠ¤ ê´€ë¦¬
/// - ë©€í‹° ìŠ¤íŠ¸ë¦¼ íƒ€ì… ì§€ì› (aggTrade, ticker, bookTicker, depth5)
/// - ìŠ¤ë§ˆíŠ¸ ë°°ì¹˜ ì²˜ë¦¬ë¡œ UI ì„±ëŠ¥ ìµœì í™”
/// - ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ í•„í„°ë§ ì‹œìŠ¤í…œ
class TradeRepositoryImpl implements TradeRepository {
  final TradeRemoteDataSource _remoteDataSource;
  final TradeAggregator _aggregator;

  // ğŸ¯ ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬ (ì—…ë¹„íŠ¸ ìŠ¤íƒ€ì¼)
  Stream<Trade>? _masterStream;
  StreamSubscription<Trade>? _masterSubscription;
  bool _isInitialized = false;
  List<String>? _currentMarkets;

  // ğŸ“Š í•„í„°ë§ ì‹œìŠ¤í…œ
  final Map<TradeFilter, List<Trade>> _filterCache = {
    for (var filter in TradeFilter.values) filter: []
  };
  double _currentThreshold = TradeFilter.usdt50k.value;

  // ğŸ¯ ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤
  final StreamController<List<Trade>> _filteredTradesController = 
      StreamController<List<Trade>>.broadcast();
  final StreamController<Trade> _aggregatedController = 
      StreamController<Trade>.broadcast();

  // ğŸ§¹ ë©”ëª¨ë¦¬ ê´€ë¦¬
  final LinkedHashSet<String> _seenIds = LinkedHashSet<String>();
  Timer? _batchUpdateTimer;
  Timer? _memoryCleanupTimer;

  // ğŸ“ˆ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
  int _processedCount = 0;
  int _filteredCount = 0;
  DateTime? _lastUpdateTime;

  // ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
  static const int _maxTradesPerFilter = 100;
  static const int _maxSeenIdsCache = 5000;
  static const Duration _batchUpdateInterval = Duration(milliseconds: 100);
  static const Duration _memoryCleanupInterval = Duration(seconds: 30);

  TradeRepositoryImpl(this._remoteDataSource) : _aggregator = TradeAggregator() {
    _startMemoryCleanup();
    log.i('[TradeRepository] Initialized');
  }

  /// ğŸ”¥ í•µì‹¬: ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™” (í•œ ë²ˆë§Œ ì‹¤í–‰)
  void _initializeMasterStream(List<String> markets) {
    if (_isInitialized && _marketsEqual(_currentMarkets, markets)) {
      return; // ì´ë¯¸ ê°™ì€ ë§ˆì¼“ìœ¼ë¡œ ì´ˆê¸°í™”ë¨
    }

    log.i('[TradeRepository] Initializing master stream for ${markets.length} markets');
    
    // ê¸°ì¡´ ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
    _cleanupMasterStream();
    
    _currentMarkets = List<String>.from(markets);
    _isInitialized = true;

    // âœ… ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ìƒì„± (TradeRemoteDataSourceì˜ watch ì‚¬ìš©)
    _masterStream = _remoteDataSource.watch(markets);
    
    // âœ… ë‹¨ì¼ êµ¬ë…ìœ¼ë¡œ ëª¨ë“  ë°ì´í„° ì²˜ë¦¬
    _masterSubscription = _masterStream!.listen(
      _processRawTrade,
      onError: (error, stackTrace) {
        log.e('[TradeRepository] Master stream error', error, stackTrace);
      },
      onDone: () {
        log.w('[TradeRepository] Master stream done');
      },
      cancelOnError: false,
    );

    // âœ… Aggregator ìŠ¤íŠ¸ë¦¼ êµ¬ë…
    _aggregator.stream.listen(
      _handleAggregatedTrade,
      onError: (error, stackTrace) {
        log.e('[TradeRepository] Aggregator stream error', error, stackTrace);
      },
      cancelOnError: false,
    );

    log.i('[TradeRepository] Master stream initialized successfully');
  }

  /// ğŸ“¥ ì›ì‹œ ê±°ë˜ ë°ì´í„° ì²˜ë¦¬ (ìŠ¤íŠ¸ë¦¼ë³„ ë¶„ê¸°)
void _processRawTrade(Trade trade) {
  try {
    // âœ… ë°ì´í„° ê²€ì¦
    if (!trade.isValidData) {
      log.w('[TradeRepository] Invalid trade data: ${trade.market}');
      return;
    }

    // âœ… ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€
    if (!_seenIds.add(trade.tradeId)) {
      return;
    }

    _processedCount++;
    _lastUpdateTime = DateTime.now();

    // âœ… [í•µì‹¬] ìŠ¤íŠ¸ë¦¼ íƒ€ì…ë³„ ì²˜ë¦¬ ì „ëµ
    switch (trade.streamType) {
      case BinanceStreamType.aggTrade:
        // aggTradeë§Œ ì§‘ê³„ê¸°ë¡œ ì „ë‹¬ (ì‹¤ì œ ê±°ë˜ ë°ì´í„°)
        _aggregator.process(trade);
        break;
        
      case BinanceStreamType.ticker:
        // ğŸš¨ tickerëŠ” íŠ¸ë ˆì´ë“œë¼ì¸ì—ì„œ ì œì™¸! (24ì‹œê°„ ëˆ„ì  ë°ì´í„°)
        // _handleAggregatedTrade(trade); â† ì´ê±° ì£¼ì„ì²˜ë¦¬!
        return;
        
      case BinanceStreamType.bookTicker:
      case BinanceStreamType.depth5:
        // í˜¸ê°€ ë°ì´í„°ëŠ” ë³„ë„ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì²˜ë¦¬ (í•„í„°ë§ ì œì™¸)
        if (!_aggregatedController.isClosed) {
          _aggregatedController.add(trade);
        }
        break;
    }

  } catch (e, st) {
    log.e('[TradeRepository] Raw trade processing error', e, st);
  }
}

  /// ğŸ¯ ì§‘ê³„ëœ ê±°ë˜ ì²˜ë¦¬: í•„í„°ë³„ ìºì‹œì— ì €ì¥
  void _handleAggregatedTrade(Trade trade) {
    try {
      // âœ… ì§‘ê³„ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ì— ì¶”ê°€
      if (!_aggregatedController.isClosed) {
        _aggregatedController.add(trade);
      }

      // âœ… [ê°œì„ ] aggTradeì™€ tickerë§Œ í•„í„°ë§ ëŒ€ìƒ
      if (trade.streamType == BinanceStreamType.aggTrade || 
          trade.streamType == BinanceStreamType.ticker) {
        
        // ê° í•„í„°ì— í•´ë‹¹í•˜ëŠ” ê±°ë˜ ì¶”ê°€
        for (final filter in TradeFilter.values) {
          if (trade.totalValue >= filter.value) {
            final list = _filterCache[filter]!;
            list.insert(0, trade);
            
            // ìµœëŒ€ ê±°ë˜ ìˆ˜ ìœ ì§€
            if (list.length > _maxTradesPerFilter) {
              list.removeLast();
            }
          }
        }

        _filteredCount++;
        
        // ğŸš€ ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§ (ê³¼ë„í•œ UI ì—…ë°ì´íŠ¸ ë°©ì§€)
        _scheduleBatchUpdate();
      }

    } catch (e, st) {
      log.e('[TradeRepository] Aggregated trade handling error', e, st);
    }
  }

  /// â° ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§ (ì—…ë¹„íŠ¸ ìŠ¤íƒ€ì¼)
  void _scheduleBatchUpdate() {
    // ì´ë¯¸ ìŠ¤ì¼€ì¤„ëœ ì—…ë°ì´íŠ¸ê°€ ìˆìœ¼ë©´ ì·¨ì†Œí•˜ê³  ìƒˆë¡œ ìŠ¤ì¼€ì¤„
    _batchUpdateTimer?.cancel();
    
    _batchUpdateTimer = Timer(_batchUpdateInterval, () {
      _performBatchUpdate();
    });
  }

  /// ğŸ“Š ì‹¤ì œ UI ì—…ë°ì´íŠ¸ ìˆ˜í–‰
  void _performBatchUpdate() {
    try {
      // í˜„ì¬ ì„ê³„ê°’ì— í•´ë‹¹í•˜ëŠ” í•„í„° ì°¾ê¸°
      final targetFilter = TradeFilter.values.firstWhere(
        (f) => f.value == _currentThreshold,
        orElse: () => TradeFilter.usdt50k,
      );

      final filteredList = _filterCache[targetFilter] ?? <Trade>[];
      
      // ğŸš€ UIì— ì—…ë°ì´íŠ¸ ì „ì†¡
      if (!_filteredTradesController.isClosed) {
        _filteredTradesController.add(List<Trade>.from(filteredList));
        
        if (kDebugMode && filteredList.isNotEmpty) {
          log.d('[TradeRepository] Batch update: ${filteredList.length} filtered trades '
                '(threshold: ${_currentThreshold.toStringAsFixed(0)})');
        }
      }

    } catch (e, st) {
      log.e('[TradeRepository] Batch update error', e, st);
    }
  }

  /// ğŸ§¹ ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹œì‘
  void _startMemoryCleanup() {
    _memoryCleanupTimer = Timer.periodic(_memoryCleanupInterval, (_) {
      _cleanupMemory();
    });
  }

  /// ğŸ§¹ ë©”ëª¨ë¦¬ ì •ë¦¬ ìˆ˜í–‰
  void _cleanupMemory() {
    try {
      // SeenIds ìºì‹œ í¬ê¸° ì œí•œ
      if (_seenIds.length > _maxSeenIdsCache) {
        final removeCount = (_seenIds.length * 0.3).ceil(); // 30% ì œê±°
        final toRemove = _seenIds.take(removeCount).toList();
        _seenIds.removeAll(toRemove);
        
        if (kDebugMode) {
          log.d('[TradeRepository] Memory cleanup: removed $removeCount seen IDs');
        }
      }

      // í•„í„° ìºì‹œ ì •ë¦¬ (ê° í•„í„°ë‹¹ ìµœëŒ€ í¬ê¸° ì¬í™•ì¸)
      for (final entry in _filterCache.entries) {
        final list = entry.value;
        if (list.length > _maxTradesPerFilter) {
          final excess = list.length - _maxTradesPerFilter;
          list.removeRange(_maxTradesPerFilter, list.length);
          
          if (kDebugMode) {
            log.d('[TradeRepository] Filter cache cleanup: removed $excess trades from ${entry.key}');
          }
        }
      }

    } catch (e, st) {
      log.e('[TradeRepository] Memory cleanup error', e, st);
    }
  }

  /// ğŸ”„ ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
  void _cleanupMasterStream() {
    _masterSubscription?.cancel();
    _masterSubscription = null;
    _masterStream = null;
    _isInitialized = false;
  }

  /// ğŸ” ë§ˆì¼“ ë¦¬ìŠ¤íŠ¸ ë¹„êµ
  bool _marketsEqual(List<String>? a, List<String>? b) {
    if (a == null || b == null) return false;
    if (a.length != b.length) return false;
    return Set<String>.from(a).containsAll(b);
  }

  // ===================================================================
  // TradeRepository ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
  // ===================================================================

  @override
  Stream<Trade> watchTrades(List<String> markets) {
    log.d('[TradeRepository] watchTrades() called with ${markets.length} markets');
    
    _initializeMasterStream(markets);
    
    // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ë°˜í™˜ (ëª¨ë“  ìŠ¤íŠ¸ë¦¼ íƒ€ì… í¬í•¨)
    return _masterStream!;
  }

  @override
  Stream<List<Trade>> watchFilteredTrades(double threshold, List<String> markets) {
    log.d('[TradeRepository] watchFilteredTrades() called with threshold: $threshold');
    
    // ì„ê³„ê°’ ì—…ë°ì´íŠ¸
    _currentThreshold = threshold;
    
    // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
    _initializeMasterStream(markets);
    
    // ì„ê³„ê°’ ë³€ê²½ìœ¼ë¡œ ì¸í•œ ì¦‰ì‹œ ì¬í•„í„°ë§
    _scheduleBatchUpdate();
    
    // í•„í„°ë§ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜
    return _filteredTradesController.stream;
  }

  @override
  Stream<Trade> watchAggregatedTrades() {
    log.d('[TradeRepository] watchAggregatedTrades() called');
    
    // ì§‘ê³„ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜ (ëª¨ë“  ìŠ¤íŠ¸ë¦¼ íƒ€ì… í¬í•¨)
    return _aggregatedController.stream;
  }

  @override
  void updateThreshold(double threshold) {
    if (_currentThreshold == threshold) return;
    
    final oldThreshold = _currentThreshold;
    _currentThreshold = threshold;
    
    log.i('[TradeRepository] Threshold updated: ${oldThreshold.toStringAsFixed(0)} â†’ ${threshold.toStringAsFixed(0)}');
    
    // ì„ê³„ê°’ ë³€ê²½ ì‹œ ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸
    _performBatchUpdate();
  }

  /// âœ… [ì¶”ê°€] í˜„ì¬ ìƒíƒœ ì¡°íšŒ
  Map<String, dynamic> getStatus() {
    return {
      'isInitialized': _isInitialized,
      'currentMarkets': _currentMarkets?.length ?? 0,
      'currentThreshold': _currentThreshold,
      'processedCount': _processedCount,
      'filteredCount': _filteredCount,
      'seenIdsCount': _seenIds.length,
      'filterCacheSize': _filterCache.values.map((list) => list.length).reduce((a, b) => a + b),
      'lastUpdateTime': _lastUpdateTime?.toIso8601String(),
    };
  }

  /// âœ… [ì¶”ê°€] íŠ¹ì • í•„í„°ì˜ ê±°ë˜ ìˆ˜ ì¡°íšŒ
  int getTradeCountForFilter(TradeFilter filter) {
    return _filterCache[filter]?.length ?? 0;
  }

  @override
  Future<void> dispose() async {
    log.i('[TradeRepository] Disposing... Status: ${getStatus()}');
    
    // íƒ€ì´ë¨¸ë“¤ ì •ë¦¬
    _batchUpdateTimer?.cancel();
    _memoryCleanupTimer?.cancel();
    
    // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
    _cleanupMasterStream();
    
    // Aggregator ì •ë¦¬
    _aggregator.dispose();
    
    // ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ ì •ë¦¬
    await _filteredTradesController.close();
    await _aggregatedController.close();
    
    // ë©”ëª¨ë¦¬ ì •ë¦¬
    _filterCache.clear();
    _seenIds.clear();
    _currentMarkets = null;
    
    log.i('[TradeRepository] Disposed successfully');
  }
}\n\n// ====== lib/data/processors/trade_aggregator.dart ======\n
// lib/data/processors/trade_aggregator.dart

import 'dart:async';
import 'package:flutter/foundation.dart';
import '../../domain/entities/trade.dart';
import '../../core/config/app_config.dart';
import '../../core/utils/logger.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ì „ìš© ì‹¤ì‹œê°„ ê±°ë˜ ì§‘ê³„ê¸° (ì—…ë¹„íŠ¸ ìŠ¤íƒ€ì¼ ê°œì„ )
/// - ë©€í‹° ìŠ¤íŠ¸ë¦¼ ì§€ì› (aggTrade, ticker, bookTicker, depth5)
/// - ìŠ¤íŠ¸ë¦¼ë³„ ë‹¤ë¥¸ ë³‘í•© ì „ëµ ì ìš©
/// - ê°€ì¤‘ í‰ê·  ê°€ê²© ê³„ì‚°ìœ¼ë¡œ ì •í™•ë„ í–¥ìƒ
/// - ì—ëŸ¬ ì²˜ë¦¬ ë° ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì¶”ê°€
class TradeAggregator {
  final Map<String, Trade> _pendingTrades = {};
  final StreamController<Trade> _controller = StreamController<Trade>.broadcast();
  Timer? _flushTimer;
  
  // ğŸ“Š ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
  int _processedCount = 0;
  int _mergedCount = 0;
  int _flushedCount = 0;
  DateTime? _lastActivityTime;

  /// ì§‘ê³„ ì²˜ë¦¬ëœ ê±°ë˜ ë°ì´í„° ìŠ¤íŠ¸ë¦¼
  Stream<Trade> get stream => _controller.stream;

  /// ìŠ¤íŠ¸ë¦¼ë³„ ë³‘í•© ì°½ ì„¤ì • (ë°€ë¦¬ì´ˆ)
  int get mergeWindowMs => AppConfig.mergeWindowMs;

  TradeAggregator() {
    // âœ… [ê°œì„ ] AppConfig ê¸°ë°˜ flush ì£¼ê¸° ì„¤ì •
    final flushInterval = Duration(milliseconds: AppConfig.aggregatorFlushIntervalMs);
    _flushTimer = Timer.periodic(flushInterval, (_) => _flush());
    log.i('[TradeAggregator] Initialized with ${mergeWindowMs}ms merge window, '
          '${AppConfig.aggregatorFlushIntervalMs}ms flush interval');
  }

  /// ğŸ¯ ìƒˆë¡œìš´ ê±°ë˜ë¥¼ ë°›ì•„ ìŠ¤íŠ¸ë¦¼ë³„ ì§‘ê³„ ë¡œì§ ì²˜ë¦¬
  void process(Trade trade) {
    try {
      // âœ… [ì¶”ê°€] ë°ì´í„° ê²€ì¦
      if (!trade.isValidData) {
        if (kDebugMode) {
          log.w('[TradeAggregator] Invalid trade data: ${trade.market}');
        }
        return;
      }

      _processedCount++;
      _lastActivityTime = DateTime.now();

      // âœ… [ê°œì„ ] AppConfig ê¸°ë°˜ ìŠ¤íŠ¸ë¦¼ë³„ ì²˜ë¦¬ ë¶„ê¸°
      final shouldProcessImmediately = AppConfig.shouldProcessImmediately(trade.streamType.name);
      final streamMergeWindow = AppConfig.getMergeWindowForStream(trade.streamType.name);

      switch (trade.streamType) {
        case BinanceStreamType.aggTrade:
          _processAggTrade(trade, streamMergeWindow);
          break;
        case BinanceStreamType.ticker:
          _processTicker(trade, shouldProcessImmediately);
          break;
        case BinanceStreamType.bookTicker:
          _processBookTicker(trade, shouldProcessImmediately);
          break;
        case BinanceStreamType.depth5:
          _processDepth5(trade, shouldProcessImmediately);
          break;
      }

    } catch (e, st) {
      log.e('[TradeAggregator] Process error for ${trade.market}', e, st);
    }
  }

  /// âœ… [ì‹ ê·œ] aggTrade ì „ìš© ì²˜ë¦¬ (ê±°ë˜ëŸ‰ ê°€ì¤‘ í‰ê· )
  void _processAggTrade(Trade trade, int mergeWindow) {
    final existing = _pendingTrades[trade.market];

    // í•´ë‹¹ ë§ˆì¼“ì— ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ê°€ ì—†ë‹¤ë©´ ìƒˆë¡œ ì¶”ê°€í•˜ê³  ì¦‰ì‹œ ë°©ì¶œ
    if (existing == null) {
      _pendingTrades[trade.market] = trade;
      _controller.add(trade); // âœ… [ê°œì„ ] ì²« ê±°ë˜ ì¦‰ì‹œ ë°˜ì˜
      if (kDebugMode) {
        log.d('[TradeAggregator] New aggTrade: ${trade.market} ${trade.price} Ã— ${trade.quantity}');
      }
      return;
    }

    // âœ… [ê°œì„ ] ê°™ì€ ìŠ¤íŠ¸ë¦¼ íƒ€ì…ë§Œ ë³‘í•©
    if (existing.streamType != BinanceStreamType.aggTrade) {
      _pendingTrades[trade.market] = trade;
      _controller.add(trade);
      return;
    }

    // ì‹œê°„ ì°½ ë‚´ì˜ ê±°ë˜ë¼ë©´ ê°€ì¤‘ í‰ê· ìœ¼ë¡œ ë³‘í•©
    if (trade.timestamp - existing.timestamp <= mergeWindow) {
      final totalQuantity = existing.quantity + trade.quantity;
      final totalValue = existing.totalValue + trade.totalValue;
      
      // âœ… [í•µì‹¬] AppConfig ì„¤ì • ê¸°ë°˜ ê°€ê²© ê³„ì‚°
      final newPrice = AppConfig.useWeightedAverage() 
          ? totalValue / totalQuantity  // ê°€ì¤‘ í‰ê· 
          : trade.price;                // ìµœì‹  ê°€ê²©

      final mergedTrade = trade.copyWith(
        price: newPrice,
        quantity: totalQuantity,
        totalValue: totalValue,
        timestamp: trade.timestamp, // ìµœì‹  ì‹œê°„ ì‚¬ìš©
      );

      _pendingTrades[trade.market] = mergedTrade;
      _mergedCount++;

      if (kDebugMode && AppConfig.enableMergeLogging) {
        log.d('[TradeAggregator] Merged aggTrade: ${trade.market} '
              'price: ${newPrice.toStringAsFixed(2)}, '
              'total: ${totalQuantity.toStringAsFixed(4)}');
      }
    } else {
      // ì‹œê°„ ì°½ì„ ë²—ì–´ë‚˜ë©´, ê¸°ì¡´ ê±°ë˜ëŠ” ë°©ì¶œí•˜ê³  ìƒˆ ê±°ë˜ë¥¼ ëŒ€ê¸°
      _controller.add(existing);
      _pendingTrades[trade.market] = trade;
      _controller.add(trade); // ìƒˆ ê±°ë˜ë„ ì¦‰ì‹œ ë°©ì¶œ
    }
  }

  /// âœ… [ì‹ ê·œ] ticker ì „ìš© ì²˜ë¦¬ (ìµœì‹ ê°’ ìš°ì„ )
  void _processTicker(Trade trade, bool processImmediately) {
    final existing = _pendingTrades[trade.market];

    // âœ… [ê°œì„ ] AppConfig ì„¤ì •ì— ë”°ë¼ ì¦‰ì‹œ ì²˜ë¦¬ ë˜ëŠ” ë³‘í•©
    if (processImmediately || existing == null || existing.streamType != BinanceStreamType.ticker) {
      _pendingTrades[trade.market] = trade;
      _controller.add(trade);
      return;
    }

    // ì§§ì€ ì‹œê°„ ë‚´ ì—°ì† tickerëŠ” ë§ˆì§€ë§‰ ê²ƒë§Œ ìœ ì§€ (throttling íš¨ê³¼)
    if (trade.timestamp - existing.timestamp <= 1000) { // 1ì´ˆ ë‚´
      _pendingTrades[trade.market] = trade; // ë®ì–´ì“°ê¸°
    } else {
      _controller.add(existing); // ê¸°ì¡´ ê²ƒ ë°©ì¶œ
      _pendingTrades[trade.market] = trade;
      _controller.add(trade); // ìƒˆ ê²ƒë„ ë°©ì¶œ
    }
  }

  /// âœ… [ì‹ ê·œ] bookTicker ì „ìš© ì²˜ë¦¬ (ìŠ¤í”„ë ˆë“œ ì¤‘ì‹¬)
  void _processBookTicker(Trade trade, bool processImmediately) {
    // âœ… [ê°œì„ ] AppConfig ì„¤ì • ê¸°ë°˜ ì²˜ë¦¬
    _pendingTrades[trade.market] = trade;
    if (processImmediately) {
      _controller.add(trade);
    }
    
    if (kDebugMode && AppConfig.enableMergeLogging) {
      final spread = trade.spread;
      log.d('[TradeAggregator] BookTicker: ${trade.market} '
            'spread: ${spread?.toStringAsFixed(4) ?? "N/A"}');
    }
  }

  /// âœ… [ì‹ ê·œ] depth5 ì „ìš© ì²˜ë¦¬ (í˜¸ê°€ì°½ ì—…ë°ì´íŠ¸)
  void _processDepth5(Trade trade, bool processImmediately) {
    // âœ… [ê°œì„ ] AppConfig ì„¤ì • ê¸°ë°˜ ì²˜ë¦¬
    _pendingTrades[trade.market] = trade;
    if (processImmediately) {
      _controller.add(trade);
    }
    
    if (kDebugMode && AppConfig.enableMergeLogging) {
      log.d('[TradeAggregator] Depth5: ${trade.market} mid: ${trade.price.toStringAsFixed(2)}');
    }
  }

  /// âœ… [ê°œì„ ] ëŒ€ê¸° ì¤‘ì¸ ëª¨ë“  ê±°ë˜ë¥¼ ë°©ì¶œ (ì„±ëŠ¥ í–¥ìƒ)
  void _flush() {
    if (_pendingTrades.isEmpty) return;

    try {
      final trades = _pendingTrades.values.toList();
      _flushedCount += trades.length;
      
      // âœ… [ê°œì„ ] ë°°ì¹˜ë¡œ í•œë²ˆì— ì²˜ë¦¬
      for (final trade in trades) {
        if (!_controller.isClosed) {
          _controller.add(trade);
        }
      }
      
      _pendingTrades.clear();

      if (kDebugMode && trades.isNotEmpty) {
        log.d('[TradeAggregator] Flushed ${trades.length} pending trades');
      }
    } catch (e, st) {
      log.e('[TradeAggregator] Flush error', e, st);
    }
  }

  /// âœ… [ì¶”ê°€] ëª¨ë“  ëŒ€ê¸° ê±°ë˜ë¥¼ ì¦‰ì‹œ ë°©ì¶œ (ìˆ˜ë™ flush)
  void flushAll() {
    log.i('[TradeAggregator] Manual flush requested');
    _flush();
  }

  /// âœ… [ì¶”ê°€] ì„±ëŠ¥ í†µê³„ ì¡°íšŒ
  Map<String, dynamic> getStats() {
    return {
      'processedCount': _processedCount,
      'mergedCount': _mergedCount,
      'flushedCount': _flushedCount,
      'pendingTrades': _pendingTrades.length,
      'mergeWindowMs': mergeWindowMs,
      'lastActivityTime': _lastActivityTime?.toIso8601String(),
      'isActive': _flushTimer?.isActive ?? false,
    };
  }

  /// âœ… [ì¶”ê°€] íŠ¹ì • ë§ˆì¼“ì˜ ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ ì¡°íšŒ (ë””ë²„ê¹…ìš©)
  Trade? getPendingTrade(String market) {
    return _pendingTrades[market];
  }

  /// âœ… [ì¶”ê°€] í˜„ì¬ ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ ìˆ˜
  int get pendingTradesCount => _pendingTrades.length;

  /// âœ… [ì¶”ê°€] ì²˜ë¦¬ í†µê³„ ì´ˆê¸°í™” (í…ŒìŠ¤íŠ¸ìš©)
  void resetStats() {
    _processedCount = 0;
    _mergedCount = 0;
    _flushedCount = 0;
    _lastActivityTime = null;
    log.i('[TradeAggregator] Stats reset');
  }

  /// âœ… [ì¶”ê°€] ëª¨ë“  ëŒ€ê¸° ê±°ë˜ í´ë¦¬ì–´ (í…ŒìŠ¤íŠ¸/ë””ë²„ê·¸ìš©)
  void clear() {
    _pendingTrades.clear();
    log.i('[TradeAggregator] All pending trades cleared');
  }

  /// ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  void dispose() {
    log.i('[TradeAggregator] Disposing... Stats: ${getStats()}');
    
    // ë§ˆì§€ë§‰ flush
    _flush();
    
    _flushTimer?.cancel();
    _flushTimer = null;
    
    if (!_controller.isClosed) {
      _controller.close();
    }
    
    _pendingTrades.clear();
    log.i('[TradeAggregator] Disposed');
  }
}\n\n// ====== lib/domain/repositories/trade_repository.dart ======\n
// lib/domain/repositories/trade_repository.dart

import '../entities/trade.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ê±°ë˜ ë°ì´í„° Repository ì¸í„°í˜ì´ìŠ¤
/// - ë©€í‹° ìŠ¤íŠ¸ë¦¼ ì§€ì› (aggTrade, ticker, bookTicker, depth5)
/// - íš¨ìœ¨ì ì¸ í•„í„°ë§ ë° ì§‘ê³„ ì‹œìŠ¤í…œ
/// - ì‹¤ì‹œê°„ ì„ê³„ê°’ ì—…ë°ì´íŠ¸ ì§€ì›
abstract class TradeRepository {
  
  /// ğŸ¯ ì›ì‹œ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ ì œê³µ
  /// ëª¨ë“  ìŠ¤íŠ¸ë¦¼ íƒ€ì…(aggTrade, ticker, bookTicker, depth5)ì„ í¬í•¨í•œ ì‹¤ì‹œê°„ ë°ì´í„°
  /// 
  /// [markets] êµ¬ë…í•  ë§ˆì¼“ ëª©ë¡ (ì˜ˆ: ['BTCUSDT', 'ETHUSDT'])
  /// Returns: Trade ê°ì²´ì˜ ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¼
  Stream<Trade> watchTrades(List<String> markets);

  /// ğŸ“Š í•„í„°ë§ëœ ê±°ë˜ ë¦¬ìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼
  /// ì§€ì •ëœ ì„ê³„ê°’ ì´ìƒì˜ ê±°ë˜ë§Œ í•„í„°ë§í•˜ì—¬ ë¦¬ìŠ¤íŠ¸ë¡œ ì œê³µ
  /// 
  /// [threshold] ìµœì†Œ ê±°ë˜ëŒ€ê¸ˆ ì„ê³„ê°’ (USDT ê¸°ì¤€)
  /// [markets] êµ¬ë…í•  ë§ˆì¼“ ëª©ë¡
  /// Returns: í•„í„°ë§ëœ Trade ë¦¬ìŠ¤íŠ¸ì˜ ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¼
  Stream<List<Trade>> watchFilteredTrades(double threshold, List<String> markets);

  /// ğŸ”„ ì§‘ê³„ ì²˜ë¦¬ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼
  /// TradeAggregatorë¥¼ í†µí•´ ë³‘í•©/ì§‘ê³„ëœ ê±°ë˜ ë°ì´í„° ì œê³µ
  /// 
  /// Returns: ì§‘ê³„ëœ Trade ê°ì²´ì˜ ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¼
  Stream<Trade> watchAggregatedTrades();

  /// âš™ï¸ ì‹¤ì‹œê°„ í•„í„° ì„ê³„ê°’ ì—…ë°ì´íŠ¸
  /// UIì—ì„œ í•„í„° ê°’ì´ ë³€ê²½ë  ë•Œ í˜¸ì¶œí•˜ì—¬ ì¦‰ì‹œ í•„í„°ë§ ê²°ê³¼ ì—…ë°ì´íŠ¸
  /// 
  /// [threshold] ìƒˆë¡œìš´ ì„ê³„ê°’ (USDT ê¸°ì¤€)
  void updateThreshold(double threshold);

  /// ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  /// WebSocket ì—°ê²°, ìŠ¤íŠ¸ë¦¼ êµ¬ë…, ë©”ëª¨ë¦¬ ìºì‹œ ë“± ëª¨ë“  ë¦¬ì†ŒìŠ¤ í•´ì œ
  Future<void> dispose();
}\n\n// ====== lib/domain/usecases/trade_usecase.dart ======\n
// lib/domain/usecases/trade_usecase.dart

import 'dart:async';
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../../core/utils/logger.dart';
import '../entities/trade.dart';
import '../repositories/trade_repository.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ê±°ë˜ ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì œê³µí•˜ëŠ” UseCase
/// - ë©€í‹° ìŠ¤íŠ¸ë¦¼ ì§€ì› (aggTrade, ticker, bookTicker, depth5)
/// - Result íŒ¨í„´ìœ¼ë¡œ íƒ€ì… ì•ˆì „í•œ ì—ëŸ¬ ì²˜ë¦¬
/// - ìŠ¤íŠ¸ë¦¼ë³„ ì°¨ë³„í™”ëœ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì ìš©
/// - ì‹¤ì‹œê°„ í•„í„°ë§ ë° ì§‘ê³„ ê¸°ëŠ¥
class TradeUsecase {
  final TradeRepository _repository;
  
  // ğŸ“Š ë‚´ë¶€ ìƒíƒœ ê´€ë¦¬
  double _currentThreshold = 50000.0; // ê¸°ë³¸ ì„ê³„ê°’: 50K USDT
  List<String> _currentMarkets = [];
  
  // ğŸ”„ ìŠ¤íŠ¸ë¦¼ êµ¬ë… ê´€ë¦¬
  final Map<String, StreamSubscription> _activeSubscriptions = {};
  
  TradeUsecase(this._repository);

  // ===================================================================
  // í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë©”ì„œë“œë“¤
  // ===================================================================

  /// ğŸ¯ ì›ì‹œ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ (ëª¨ë“  ìŠ¤íŠ¸ë¦¼ íƒ€ì… í¬í•¨)
  /// ì‹¤ì‹œê°„ ê±°ë˜ ë°ì´í„°ë¥¼ Result íŒ¨í„´ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ì œê³µ
  /// 
  /// [markets] êµ¬ë…í•  ë§ˆì¼“ ëª©ë¡
  /// Returns: Resultë¡œ ë˜í•‘ëœ Trade ìŠ¤íŠ¸ë¦¼
  Stream<Result<Trade, AppException>> watchRawTrades(List<String> markets) {
    log.d('[TradeUsecase] Starting raw trades stream for ${markets.length} markets');
    
    _currentMarkets = List<String>.from(markets);
    
    return _repository
        .watchTrades(markets)
        .transform(_wrapStream<Trade>('Raw trades stream failed'));
  }

  /// ğŸ“Š í•„í„°ë§ëœ ê±°ë˜ ë¦¬ìŠ¤íŠ¸ (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì ìš©)
  /// thresholdì™€ marketsë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•„í„°ë§ëœ ê±°ë˜ ëª©ë¡ì„ Result íŒ¨í„´ìœ¼ë¡œ ì œê³µ
  /// 
  /// [threshold] ìµœì†Œ ê±°ë˜ëŒ€ê¸ˆ ì„ê³„ê°’ (USDT)
  /// [markets] êµ¬ë…í•  ë§ˆì¼“ ëª©ë¡  
  /// Returns: Resultë¡œ ë˜í•‘ëœ í•„í„°ë§ëœ Trade ë¦¬ìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼
  Stream<Result<List<Trade>, AppException>> filterTrades(
    double threshold,
    List<String> markets,
  ) {
    log.i('[TradeUsecase] Starting filtered trades: threshold=${threshold.toStringAsFixed(0)}, markets=${markets.length}');
    
    // âœ… ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§: ì„ê³„ê°’ ê²€ì¦
    if (threshold < 0) {
      return Stream.value(Err(AppException.business('Invalid threshold: $threshold. Must be >= 0')));
    }
    
    if (markets.isEmpty) {
      return Stream.value(Err(AppException.business('Markets list cannot be empty')));
    }
    
    _currentThreshold = threshold;
    _currentMarkets = List<String>.from(markets);
    
    return _repository
        .watchFilteredTrades(threshold, markets)
        .transform(_wrapStream<List<Trade>>('Filter trades failed'))
        .map((result) => result.map(_applyBusinessLogicToList));
  }

  /// ğŸ”„ ì§‘ê³„ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ (ìŠ¤íŠ¸ë¦¼ë³„ ë¶„ë¦¬)
  /// TradeAggregatorë¥¼ í†µí•´ ë³‘í•©/ì§‘ê³„ëœ ê±°ë˜ ë°ì´í„°ë¥¼ Result íŒ¨í„´ìœ¼ë¡œ ì œê³µ
  /// 
  /// Returns: Resultë¡œ ë˜í•‘ëœ ì§‘ê³„ Trade ìŠ¤íŠ¸ë¦¼
  Stream<Result<Trade, AppException>> aggregateTrades() {
    log.d('[TradeUsecase] Starting aggregated trades stream');
    
    return _repository
        .watchAggregatedTrades()
        .transform(_wrapStream<Trade>('Aggregate trades failed'))
        .map((result) => result.map(_applyBusinessLogicToTrade));
  }

  /// âœ… [ì¶”ê°€] ìŠ¤íŠ¸ë¦¼ë³„ íŠ¹í™”ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ë“¤

  /// aggTradeë§Œ í•„í„°ë§í•œ ìŠ¤íŠ¸ë¦¼
  Stream<Result<Trade, AppException>> watchAggTrades(List<String> markets) {
    return watchRawTrades(markets)
        .map((result) => result.mapWhere(
          (trade) => trade.streamType == BinanceStreamType.aggTrade,
          fallback: () => Err(AppException.business('No aggTrade data available')),
        ));
  }

  /// tickerë§Œ í•„í„°ë§í•œ ìŠ¤íŠ¸ë¦¼  
  Stream<Result<Trade, AppException>> watchTickers(List<String> markets) {
    return watchRawTrades(markets)
        .map((result) => result.mapWhere(
          (trade) => trade.streamType == BinanceStreamType.ticker,
          fallback: () => Err(AppException.business('No ticker data available')),
        ));
  }

  /// bookTickerë§Œ í•„í„°ë§í•œ ìŠ¤íŠ¸ë¦¼
  Stream<Result<Trade, AppException>> watchBookTickers(List<String> markets) {
    return watchRawTrades(markets)
        .map((result) => result.mapWhere(
          (trade) => trade.streamType == BinanceStreamType.bookTicker,
          fallback: () => Err(AppException.business('No bookTicker data available')),
        ));
  }

  // ===================================================================
  // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ í—¬í¼ ë©”ì„œë“œë“¤
  // ===================================================================

  /// ğŸ¯ ê°œë³„ ê±°ë˜ì— ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì ìš©
  Trade _applyBusinessLogicToTrade(Trade trade) {
    // âœ… ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì˜ˆì‹œ: ê±°ë˜ ê²€ì¦ ë° ë³´ê°•
    
    // 1. ë°ì´í„° ê²€ì¦
    if (!trade.isValidData) {
      log.w('[TradeUsecase] Invalid trade data detected: ${trade.market}');
      return trade;
    }
    
    // 2. ìŠ¤íŠ¸ë¦¼ë³„ ì¶”ê°€ ì •ë³´ ê³„ì‚°
    switch (trade.streamType) {
      case BinanceStreamType.aggTrade:
        // aggTrade: ê±°ë˜ í¬ê¸°ë³„ ë“±ê¸‰ ë¶„ë¥˜ ê°€ëŠ¥
        break;
      case BinanceStreamType.ticker:
        // ticker: ë³€ë™ë¥  ê¸°ë°˜ ì•Œë¦¼ ë¡œì§ ê°€ëŠ¥
        break;
      case BinanceStreamType.bookTicker:
        // bookTicker: ìŠ¤í”„ë ˆë“œ ë¶„ì„ ë¡œì§ ê°€ëŠ¥
        break;
      case BinanceStreamType.depth5:
        // depth5: í˜¸ê°€ ë¶ˆê· í˜• ë¶„ì„ ê°€ëŠ¥
        break;
    }
    
    return trade;
  }

  /// ğŸ¯ ê±°ë˜ ë¦¬ìŠ¤íŠ¸ì— ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì ìš©
  List<Trade> _applyBusinessLogicToList(List<Trade> trades) {
    if (trades.isEmpty) return trades;
    
    // âœ… ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì˜ˆì‹œë“¤:
    
    // 1. ë°ì´í„° í’ˆì§ˆ ê²€ì¦
    final validTrades = trades.where((trade) => trade.isValidData).toList();
    
    // 2. ì¤‘ë³µ ì œê±° (tradeId ê¸°ì¤€)
    final seenIds = <String>{};
    final uniqueTrades = validTrades.where((trade) => seenIds.add(trade.tradeId)).toList();
    
    // 3. ì‹œê°„ìˆœ ì •ë ¬ (ìµœì‹  ìˆœ)
    uniqueTrades.sort((a, b) => b.timestamp.compareTo(a.timestamp));
    
    // 4. ì„ê³„ê°’ ì¬ê²€ì¦ (Repository í•„í„°ë§ ì´í›„ ì¶”ê°€ ê²€ì¦)
    final reFilteredTrades = uniqueTrades
        .where((trade) => trade.totalValue >= _currentThreshold)
        .toList();
    
    log.d('[TradeUsecase] Business logic applied: ${trades.length} â†’ ${reFilteredTrades.length} trades');
    
    return reFilteredTrades;
  }

  // ===================================================================
  // ìƒíƒœ ê´€ë¦¬ ë©”ì„œë“œë“¤
  // ===================================================================

  /// âš™ï¸ ì‹¤ì‹œê°„ í•„í„° ì„ê³„ê°’ ì—…ë°ì´íŠ¸
  void updateThreshold(double threshold) {
    if (threshold < 0) {
      log.w('[TradeUsecase] Invalid threshold: $threshold. Ignoring update.');
      return;
    }
    
    if (_currentThreshold == threshold) {
      log.d('[TradeUsecase] Threshold unchanged: $threshold');
      return;
    }
    
    final oldThreshold = _currentThreshold;
    _currentThreshold = threshold;
    
    log.i('[TradeUsecase] Threshold updated: ${oldThreshold.toStringAsFixed(0)} â†’ ${threshold.toStringAsFixed(0)}');
    
    // Repositoryì— ì—…ë°ì´íŠ¸ ì „ë‹¬
    _repository.updateThreshold(threshold);
  }

  /// ğŸ“Š í˜„ì¬ ì„¤ì • ìƒíƒœ ì¡°íšŒ
  Map<String, dynamic> getCurrentState() {
    return {
      'currentThreshold': _currentThreshold,
      'currentMarkets': _currentMarkets,
      'activeSubscriptions': _activeSubscriptions.length,
    };
  }

  /// âœ… [ì¶”ê°€] ì„ê³„ê°’ ì‚¬ì „ ê²€ì¦
  bool isValidThreshold(double threshold) {
    return threshold >= 0 && threshold <= 1000000000; // 10ì–µ USDT ì´í•˜
  }

  /// âœ… [ì¶”ê°€] ë§ˆì¼“ ëª©ë¡ ê²€ì¦  
  bool areValidMarkets(List<String> markets) {
    return markets.isNotEmpty && 
           markets.every((market) => market.isNotEmpty && market.contains('USDT'));
  }

  // ===================================================================
  // ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œë“¤
  // ===================================================================

  /// ğŸ¯ ìŠ¤íŠ¸ë¦¼ì„ Resultë¡œ ë˜í•‘í•˜ëŠ” StreamTransformer
  StreamTransformer<T, Result<T, AppException>> _wrapStream<T>(String errorMsg) {
    return StreamTransformer.fromHandlers(
      handleData: (data, sink) {
        sink.add(Ok(data));
      },
      handleError: (error, stackTrace, sink) {
        final appException = error is AppException 
            ? error 
            : AppException.network('$errorMsg: $error');
        
        log.e('[TradeUsecase] Stream error: $errorMsg', error, stackTrace);
        sink.add(Err(appException));
      },
    );
  }

  /// ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  Future<void> dispose() async {
    log.i('[TradeUsecase] Disposing... Current state: ${getCurrentState()}');
    
    // í™œì„± êµ¬ë…ë“¤ ì •ë¦¬
    for (final subscription in _activeSubscriptions.values) {
      await subscription.cancel();
    }
    _activeSubscriptions.clear();
    
    // Repository ì •ë¦¬
    await _repository.dispose();
    
    // ìƒíƒœ ì´ˆê¸°í™”
    _currentMarkets.clear();
    
    log.i('[TradeUsecase] Disposed successfully');
  }
}

// ===================================================================
// Result í™•ì¥ ë©”ì„œë“œë“¤ (UseCase ì „ìš©)
// ===================================================================

extension ResultTradeExtensions<T, E> on Result<T, E> {
  /// ì¡°ê±´ì— ë§ëŠ” ë°ì´í„°ë§Œ í•„í„°ë§
  Result<T, E> mapWhere(bool Function(T) predicate, {required Result<T, E> Function() fallback}) {
    return when(
      ok: (data) => predicate(data) ? Ok(data) : fallback(),
      err: (error) => Err(error),
    );
  }
}\n\n// ====== lib/domain/entities/trade.dart ======\n
import 'package:equatable/equatable.dart';

/// ë°”ì´ë‚¸ìŠ¤ ìŠ¤íŠ¸ë¦¼ íƒ€ì… ì—´ê±°
enum BinanceStreamType {
  aggTrade,    // ì§‘ê³„ ê±°ë˜ ë°ì´í„°
  ticker,      // 24ì‹œê°„ í†µê³„
  bookTicker,  // ìµœê³  í˜¸ê°€
  depth5,      // 5ë‹¨ê³„ í˜¸ê°€ì°½
}

class Trade extends Equatable {
  /// ì‹¬ë³¼ (e.g., BTCUSDT)
  final String market;
  
  /// ì²´ê²° ê°€ê²©
  final double price;
  
  /// ì²´ê²° ìˆ˜ëŸ‰ (API í•„ë“œëª… 'q'ì— ë§ì¶° volume -> quantityë¡œ ë³€ê²½)
  final double quantity;
  
  /// ì´ ì²´ê²°ì•¡ (price * quantity)
  final double totalValue; // total -> totalValueë¡œ ëª…í™•í™”
  
  /// ë§¤ìˆ˜ ì²´ê²° ì—¬ë¶€
  final bool isBuy;
  
  /// ì²´ê²° ì‹œê° (milliseconds from epoch)
  final int timestamp; // timestampMs -> timestampë¡œ ê°„ì†Œí™”
  
  /// ê±°ë˜ ê³ ìœ  ID (Aggregate trade ID)
  final String tradeId; // id -> tradeIdë¡œ ëª…í™•í™”
  
  /// âœ… [ì¶”ê°€] ìŠ¤íŠ¸ë¦¼ íƒ€ì… êµ¬ë¶„
  final BinanceStreamType streamType;
  
  /// âœ… [ì¶”ê°€] ì›ë³¸ JSON ë°ì´í„° (ë””ë²„ê¹…/í™•ì¥ìš©)
  final Map<String, dynamic>? rawData;

  const Trade({
    required this.market,
    required this.price,
    required this.quantity,
    required this.totalValue,
    required this.isBuy,
    required this.timestamp,
    required this.tradeId,
    this.streamType = BinanceStreamType.aggTrade,
    this.rawData,
  });

  /// UIì—ì„œ ì‚¬ìš©í•˜ê¸° í¸í•œ DateTime ê°ì²´
  DateTime get dateTime => DateTime.fromMillisecondsSinceEpoch(timestamp);

  /// âœ… [ê°œì„ ] ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ `aggTrade` ìŠ¤íŠ¸ë¦¼ ë°ì´í„°ë¡œë¶€í„° Trade ê°ì²´ ìƒì„±
  factory Trade.fromAggTrade(Map<String, dynamic> json) {
    final price = double.parse(json['p'].toString());
    final quantity = double.parse(json['q'].toString());
    
    return Trade(
      market: json['s'] as String,
      price: price,
      quantity: quantity,
      totalValue: price * quantity,
      isBuy: !(json['m'] as bool), // isBuyerMaker(`m`)ê°€ falseì¼ ë•Œê°€ ë§¤ìˆ˜
      timestamp: json['T'] as int,
      tradeId: json['a'].toString(),
      streamType: BinanceStreamType.aggTrade,
      rawData: json,
    );
  }

  /// âœ… [ì¶”ê°€] ë°”ì´ë‚¸ìŠ¤ `ticker` ìŠ¤íŠ¸ë¦¼ ë°ì´í„°ë¡œë¶€í„° Trade ê°ì²´ ìƒì„±
  factory Trade.fromTicker(Map<String, dynamic> json) {
    final lastPrice = double.parse(json['c'].toString());
    final volume = double.parse(json['v'].toString());
    final quoteVolume = double.parse(json['q'].toString());
    
    return Trade(
      market: json['s'] as String,
      price: lastPrice,
      quantity: volume,
      totalValue: quoteVolume,
      isBuy: true, // tickerëŠ” ë°©í–¥ì„± ì—†ìŒ - ê¸°ë³¸ê°’
      timestamp: json['E'] as int, // Event time
      tradeId: 'ticker_${json['s']}_${json['E']}', // ê³ ìœ  ID ìƒì„±
      streamType: BinanceStreamType.ticker,
      rawData: json,
    );
  }

  /// âœ… [ì¶”ê°€] ë°”ì´ë‚¸ìŠ¤ `bookTicker` ìŠ¤íŠ¸ë¦¼ ë°ì´í„°ë¡œë¶€í„° Trade ê°ì²´ ìƒì„±
  factory Trade.fromBookTicker(Map<String, dynamic> json) {
    final bidPrice = double.parse(json['b'].toString());
    final askPrice = double.parse(json['a'].toString());
    final bidQty = double.parse(json['B'].toString());
    final askQty = double.parse(json['A'].toString());
    
    // ì¤‘ê°„ê°€ê²©ì„ priceë¡œ ì‚¬ìš©
    final midPrice = (bidPrice + askPrice) / 2;
    final avgQty = (bidQty + askQty) / 2;
    
    return Trade(
      market: json['s'] as String,
      price: midPrice,
      quantity: avgQty,
      totalValue: midPrice * avgQty,
      isBuy: true, // bookTickerëŠ” ë°©í–¥ì„± ì—†ìŒ
      timestamp: DateTime.now().millisecondsSinceEpoch, // bookTickerì—ëŠ” timestamp ì—†ìŒ
      tradeId: 'book_${json['s']}_${json['u']}', // updateId ì‚¬ìš©
      streamType: BinanceStreamType.bookTicker,
      rawData: json,
    );
  }

  /// âœ… [ì¶”ê°€] ë°”ì´ë‚¸ìŠ¤ `depth5` ìŠ¤íŠ¸ë¦¼ ë°ì´í„°ë¡œë¶€í„° Trade ê°ì²´ ìƒì„±
  factory Trade.fromDepth5(Map<String, dynamic> json, String symbol) {
    final bids = json['bids'] as List;
    final asks = json['asks'] as List;
    
    if (bids.isEmpty || asks.isEmpty) {
      throw ArgumentError('Empty order book data');
    }
    
    // ìµœê³  ë§¤ìˆ˜/ë§¤ë„ í˜¸ê°€
    final bestBid = double.parse(bids[0][0].toString());
    final bestAsk = double.parse(asks[0][0].toString());
    final bidQty = double.parse(bids[0][1].toString());
    final askQty = double.parse(asks[0][1].toString());
    
    // ìŠ¤í”„ë ˆë“œ ì¤‘ê°„ê°€ê²©
    final midPrice = (bestBid + bestAsk) / 2;
    final avgQty = (bidQty + askQty) / 2;
    
    return Trade(
      market: symbol,
      price: midPrice,
      quantity: avgQty,
      totalValue: midPrice * avgQty,
      isBuy: true, // depthëŠ” ë°©í–¥ì„± ì—†ìŒ
      timestamp: DateTime.now().millisecondsSinceEpoch,
      tradeId: 'depth_${symbol}_${json['lastUpdateId']}',
      streamType: BinanceStreamType.depth5,
      rawData: json,
    );
  }

  /// âœ… [ì¶”ê°€] ìŠ¤íŠ¸ë¦¼ íƒ€ì…ì— ë”°ë¥¸ íŒ©í† ë¦¬ ë©”ì„œë“œ (í†µí•© ì¸í„°í˜ì´ìŠ¤)
  factory Trade.fromBinanceStream({
    required Map<String, dynamic> json,
    required BinanceStreamType streamType,
    String? symbol, // depth5ìš©
  }) {
    switch (streamType) {
      case BinanceStreamType.aggTrade:
        return Trade.fromAggTrade(json);
      case BinanceStreamType.ticker:
        return Trade.fromTicker(json);
      case BinanceStreamType.bookTicker:
        return Trade.fromBookTicker(json);
      case BinanceStreamType.depth5:
        return Trade.fromDepth5(json, symbol ?? 'UNKNOWN');
    }
  }

  /// âœ… [ìœ ì§€] ê¸°ì¡´ í˜¸í™˜ì„±ì„ ìœ„í•œ fromBinance (aggTrade ê¸°ë³¸ê°’)
  factory Trade.fromBinance(Map<String, dynamic> json) {
    return Trade.fromAggTrade(json);
  }

  /// âœ… [ì¶”ê°€] ìŠ¤íŠ¸ë¦¼ë³„ ì¶”ê°€ ì •ë³´ ì ‘ê·¼ìë“¤
  
  /// ticker ìŠ¤íŠ¸ë¦¼ ì „ìš©: 24ì‹œê°„ ë³€ë™ë¥ 
  double? get priceChangePercent {
    if (streamType != BinanceStreamType.ticker || rawData == null) return null;
    return double.tryParse(rawData!['P']?.toString() ?? '');
  }
  
  /// ticker ìŠ¤íŠ¸ë¦¼ ì „ìš©: 24ì‹œê°„ ê³ ê°€
  double? get highPrice {
    if (streamType != BinanceStreamType.ticker || rawData == null) return null;
    return double.tryParse(rawData!['h']?.toString() ?? '');
  }
  
  /// ticker ìŠ¤íŠ¸ë¦¼ ì „ìš©: 24ì‹œê°„ ì €ê°€
  double? get lowPrice {
    if (streamType != BinanceStreamType.ticker || rawData == null) return null;
    return double.tryParse(rawData!['l']?.toString() ?? '');
  }
  
  /// bookTicker ìŠ¤íŠ¸ë¦¼ ì „ìš©: ìµœê³  ë§¤ìˆ˜ í˜¸ê°€
  double? get bestBidPrice {
    if (streamType != BinanceStreamType.bookTicker || rawData == null) return null;
    return double.tryParse(rawData!['b']?.toString() ?? '');
  }
  
  /// bookTicker ìŠ¤íŠ¸ë¦¼ ì „ìš©: ìµœê³  ë§¤ë„ í˜¸ê°€
  double? get bestAskPrice {
    if (streamType != BinanceStreamType.bookTicker || rawData == null) return null;
    return double.tryParse(rawData!['a']?.toString() ?? '');
  }
  
  /// bookTicker ìŠ¤íŠ¸ë¦¼ ì „ìš©: ìŠ¤í”„ë ˆë“œ
  double? get spread {
    final bid = bestBidPrice;
    final ask = bestAskPrice;
    if (bid == null || ask == null) return null;
    return ask - bid;
  }

  /// âœ… [ì¶”ê°€] ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œë“¤
  
  /// ìŠ¤íŠ¸ë¦¼ íƒ€ì…ë³„ í‘œì‹œìš© ë¬¸ìì—´
  String get streamTypeDisplayName {
    switch (streamType) {
      case BinanceStreamType.aggTrade:
        return 'Trade';
      case BinanceStreamType.ticker:
        return '24h Stats';
      case BinanceStreamType.bookTicker:
        return 'Best Bid/Ask';
      case BinanceStreamType.depth5:
        return 'Order Book';
    }
  }
  
  /// ë°ì´í„° í’ˆì§ˆ í™•ì¸
  bool get isValidData {
    return market.isNotEmpty && 
           price > 0 && 
           quantity >= 0 && 
           timestamp > 0 &&
           tradeId.isNotEmpty;
  }
  
  /// ë³µì‚¬ ë©”ì„œë“œ (ë¶ˆë³€ ê°ì²´ ìˆ˜ì •ìš©)
  Trade copyWith({
    String? market,
    double? price,
    double? quantity,
    double? totalValue,
    bool? isBuy,
    int? timestamp,
    String? tradeId,
    BinanceStreamType? streamType,
    Map<String, dynamic>? rawData,
  }) {
    return Trade(
      market: market ?? this.market,
      price: price ?? this.price,
      quantity: quantity ?? this.quantity,
      totalValue: totalValue ?? this.totalValue,
      isBuy: isBuy ?? this.isBuy,
      timestamp: timestamp ?? this.timestamp,
      tradeId: tradeId ?? this.tradeId,
      streamType: streamType ?? this.streamType,
      rawData: rawData ?? this.rawData,
    );
  }

  /// ë””ë²„ê·¸ìš© ìƒì„¸ ì •ë³´
  Map<String, dynamic> toDebugMap() {
    return {
      'market': market,
      'price': price,
      'quantity': quantity,
      'totalValue': totalValue,
      'isBuy': isBuy,
      'timestamp': timestamp,
      'dateTime': dateTime.toIso8601String(),
      'tradeId': tradeId,
      'streamType': streamType.name,
      'isValid': isValidData,
      'hasRawData': rawData != null,
    };
  }

  /// Equatableì„ ìœ„í•œ ì„¤ì •. tradeIdë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê°ì²´ì˜ ë™ë“±ì„±ì„ ë¹„êµí•©ë‹ˆë‹¤.
  @override
  List<Object?> get props => [tradeId];
  
  @override
  String toString() => 'Trade($market: $price Ã— $quantity, ${streamType.name})';
}\n\n// ====== lib/presentation/controllers/trade_controller.dart ======\n
// ===================================================================
// lib/presentation/controllers/trade_controller.dart
// í˜„ì¬ Provider ì²´ì œì— ë§ê²Œ ìˆ˜ì •ëœ Trade Controller
// ===================================================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/common/time_frame_types.dart';
import '../../core/di/core_provider.dart';
import '../../domain/entities/trade.dart';
import '../../core/utils/logger.dart';

// ===================================================================
// ğŸ“Š State í´ë˜ìŠ¤ (ê¸°ì¡´ ìœ ì§€)
// ===================================================================

class TradeControllerState {
  final bool isLoading;
  final String? errorMessage;
  final List<Trade> trades;
  final TradeFilter currentFilter;
  final int selectedFilterIndex;

  TradeControllerState({
    this.isLoading = true,
    this.errorMessage,
    this.trades = const [],
    required this.currentFilter,
    required this.selectedFilterIndex,
  });

  TradeControllerState copyWith({
    bool? isLoading,
    String? errorMessage,
    List<Trade>? trades,
    TradeFilter? currentFilter,
    int? selectedFilterIndex,
  }) {
    return TradeControllerState(
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage,
      trades: trades ?? this.trades,
      currentFilter: currentFilter ?? this.currentFilter,
      selectedFilterIndex: selectedFilterIndex ?? this.selectedFilterIndex,
    );
  }
}

// ===================================================================
// ğŸ¯ Controller í´ë˜ìŠ¤ (í˜„ì¬ ì²´ì œì— ë§ê²Œ ìˆ˜ì •)
// ===================================================================

class TradeController extends StateNotifier<TradeControllerState> {
  final Ref _ref;
  
  // âœ… ProviderSubscriptionìœ¼ë¡œ êµ¬ë… ê´€ë¦¬
  ProviderSubscription? _filteredTradesSub;
  ProviderSubscription? _rawStreamSub;

  TradeController(this._ref)
      : super(TradeControllerState(
          currentFilter: _ref.read(tradeFilterProvider),
          selectedFilterIndex: TradeFilter.values.indexOf(_ref.read(tradeFilterProvider)),
        )) {
    log.d('[TradeController] Initializing controller...');
    _listenToTrades();
  }

  // ===================================================================
  // ğŸ§ ìŠ¤íŠ¸ë¦¼ êµ¬ë… ê´€ë¦¬
  // ===================================================================

  void _listenToTrades() {
    log.d('[TradeController] Setting up trade stream listeners...');

    // ğŸ¯ [ìˆ˜ì •] rawTradesProvider ìŠ¤íŠ¸ë¦¼ êµ¬ë… (ë¡œë”©/ì—ëŸ¬ ìƒíƒœ ê°ì§€)
    _rawStreamSub = _ref.listen<AsyncValue<Trade>>(
      rawTradesProvider,
      (previous, next) {
        // ë¡œë”© ìƒíƒœ ë³€ê²½ ê°ì§€
        if (state.isLoading && !next.isLoading) {
          log.d('[TradeController] Raw stream loading completed');
          state = state.copyWith(isLoading: false);
        }

        // ì—ëŸ¬ ìƒíƒœ ì²˜ë¦¬
        if (next.hasError) {
          final errorMsg = next.error.toString();
          log.e('[TradeController] Raw stream error: $errorMsg');
          state = state.copyWith(
            errorMessage: errorMsg,
            isLoading: false,
          );
        }

        // ì„±ê³µì ìœ¼ë¡œ ë°ì´í„° ìˆ˜ì‹  ì‹œ ì—ëŸ¬ ë©”ì‹œì§€ í´ë¦¬ì–´
        if (next.hasValue && state.errorMessage != null) {
          log.d('[TradeController] Raw stream recovered from error');
          state = state.copyWith(errorMessage: null);
        }
      },
      fireImmediately: true,
    );

    // ğŸ¯ [ìˆ˜ì •] filteredTradesProvider ìŠ¤íŠ¸ë¦¼ êµ¬ë… (í•„í„°ë§ëœ ê±°ë˜ ëª©ë¡)
    _filteredTradesSub = _ref.listen<AsyncValue<List<Trade>>>(
      filteredTradesProvider,
      (previous, next) {
        next.when(
          data: (trades) {
            log.d('[TradeController] Received ${trades.length} filtered trades');
            state = state.copyWith(
              trades: trades,
              isLoading: false,
              errorMessage: null,
            );
          },
          loading: () {
            // ì´ë¯¸ ë°ì´í„°ê°€ ìˆë‹¤ë©´ ë¡œë”© ìƒíƒœë¡œ ë³€ê²½í•˜ì§€ ì•ŠìŒ (ë¶€ë“œëŸ¬ìš´ UX)
            if (state.trades.isEmpty) {
              log.d('[TradeController] Filtered trades loading...');
              state = state.copyWith(isLoading: true);
            }
          },
          error: (error, stackTrace) {
            final errorMsg = error.toString();
            log.e('[TradeController] Filtered trades error: $errorMsg', error, stackTrace);
            state = state.copyWith(
              errorMessage: errorMsg,
              isLoading: false,
            );
          },
        );
      },
      fireImmediately: true,
    );

    log.i('[TradeController] âœ… Trade stream listeners configured');
  }

  // ===================================================================
  // ğŸ›ï¸ í•„í„° ì œì–´ ë©”ì„œë“œ
  // ===================================================================

  /// ê±°ë˜ëŒ€ê¸ˆ í•„í„° ë³€ê²½
  void setThreshold(TradeFilter newFilter) {
    if (state.currentFilter == newFilter) {
      log.d('[TradeController] Filter unchanged: ${newFilter.displayName}');
      return;
    }

    log.i('[TradeController] ğŸ”„ Filter change: ${state.currentFilter.displayName} â†’ ${newFilter.displayName}');

    // ğŸ¯ Provider ìƒíƒœ ì—…ë°ì´íŠ¸
    _ref.read(tradeFilterProvider.notifier).state = newFilter;

    // ğŸ¯ Controller ìƒíƒœ ì—…ë°ì´íŠ¸
    state = state.copyWith(
      currentFilter: newFilter,
      selectedFilterIndex: TradeFilter.values.indexOf(newFilter),
      isLoading: true, // ìƒˆ í•„í„° ì ìš© ì¤‘ ë¡œë”© í‘œì‹œ
    );

    log.d('[TradeController] âœ… Filter updated to: ${newFilter.displayName} (${newFilter.value.toStringAsFixed(0)})');
  }

  /// ë‹¤ìŒ í•„í„°ë¡œ ìˆœí™˜
  void nextFilter() {
    final currentIndex = state.selectedFilterIndex;
    final nextIndex = (currentIndex + 1) % TradeFilter.values.length;
    final nextFilter = TradeFilter.values[nextIndex];
    
    log.d('[TradeController] Cycling to next filter: $nextIndex');
    setThreshold(nextFilter);
  }

  /// ì´ì „ í•„í„°ë¡œ ìˆœí™˜
  void previousFilter() {
    final currentIndex = state.selectedFilterIndex;
    final prevIndex = (currentIndex - 1 + TradeFilter.values.length) % TradeFilter.values.length;
    final prevFilter = TradeFilter.values[prevIndex];
    
    log.d('[TradeController] Cycling to previous filter: $prevIndex');
    setThreshold(prevFilter);
  }

  // ===================================================================
  // ğŸ“Š ìƒíƒœ ì¡°íšŒ ë©”ì„œë“œ
  // ===================================================================

  /// ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“  í•„í„° ëª©ë¡
  List<TradeFilter> get availableFilters => TradeFilter.values;

  /// í˜„ì¬ í•„í„°ì˜ í‘œì‹œ ì´ë¦„
  String get currentFilterDisplayName => state.currentFilter.displayName;

  /// í˜„ì¬ í•„í„°ì˜ ê±°ë˜ëŒ€ê¸ˆ ì„ê³„ê°’
  double get currentThreshold => state.currentFilter.value;

  /// í˜„ì¬ ê±°ë˜ ìˆ˜
  int get currentTradeCount => state.trades.length;

  /// ì—ëŸ¬ ìƒíƒœ ì—¬ë¶€
  bool get hasError => state.errorMessage != null;

  /// ë¡œë”© ìƒíƒœ ì—¬ë¶€ (ì‹¤ì œ ë¡œë”© ì¤‘ì´ê±°ë‚˜ ì—ëŸ¬ê°€ ì—†ì„ ë•Œ)
  bool get isActivelyLoading => state.isLoading && !hasError;

  // ===================================================================
  // ğŸ”„ ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨ (í•„ìš”ì‹œ)
  // ===================================================================

  /// ìˆ˜ë™ìœ¼ë¡œ ìŠ¤íŠ¸ë¦¼ ì¬êµ¬ë… (ë¬¸ì œ ë°œìƒ ì‹œ ë³µêµ¬ìš©)
  void refresh() {
    log.i('[TradeController] ğŸ”„ Manual refresh requested');
    
    // ê¸°ì¡´ êµ¬ë… í•´ì œ
    _filteredTradesSub?.close();
    _rawStreamSub?.close();
    
    // ë¡œë”© ìƒíƒœë¡œ ë³€ê²½
    state = state.copyWith(
      isLoading: true,
      errorMessage: null,
    );
    
    // ìŠ¤íŠ¸ë¦¼ ì¬êµ¬ë…
    _listenToTrades();
  }

  /// ì—ëŸ¬ ìƒíƒœ í´ë¦¬ì–´
  void clearError() {
    if (state.errorMessage != null) {
      log.d('[TradeController] Clearing error state');
      state = state.copyWith(errorMessage: null);
    }
  }

  // ===================================================================
  // ğŸ§¹ ì •ë¦¬
  // ===================================================================

  @override
  void dispose() {
    log.d('[TradeController] Disposing controller...');
    
    // âœ… êµ¬ë… í•´ì œ
    _filteredTradesSub?.close();
    _rawStreamSub?.close();
    
    log.i('[TradeController] âœ… Controller disposed');
    super.dispose();
  }
}

// ===================================================================
// ğŸ¯ Provider ì •ì˜ (autoDisposeë¡œ ë©”ëª¨ë¦¬ ê´€ë¦¬)
// ===================================================================

final tradeControllerProvider =
    StateNotifierProvider.autoDispose<TradeController, TradeControllerState>((ref) {
  return TradeController(ref);
});

// ===================================================================
// ğŸ›ï¸ í¸ì˜ìš© Providerë“¤ (UIì—ì„œ ì‰½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡)
// ===================================================================

/// í˜„ì¬ ê±°ë˜ ëª©ë¡ë§Œ ì¡°íšŒ
final currentTradesProvider = Provider.autoDispose<List<Trade>>((ref) {
  return ref.watch(tradeControllerProvider.select((state) => state.trades));
});

/// í˜„ì¬ í•„í„° ì •ë³´ë§Œ ì¡°íšŒ
final currentFilterProvider = Provider.autoDispose<TradeFilter>((ref) {
  return ref.watch(tradeControllerProvider.select((state) => state.currentFilter));
});

/// ë¡œë”© ìƒíƒœë§Œ ì¡°íšŒ
final tradesLoadingProvider = Provider.autoDispose<bool>((ref) {
  return ref.watch(tradeControllerProvider.select((state) => state.isLoading));
});

/// ì—ëŸ¬ ìƒíƒœë§Œ ì¡°íšŒ
final tradesErrorProvider = Provider.autoDispose<String?>((ref) {
  return ref.watch(tradeControllerProvider.select((state) => state.errorMessage));
});

/// Controller ì¸ìŠ¤í„´ìŠ¤ ì§ì ‘ ì ‘ê·¼ (ë©”ì„œë“œ í˜¸ì¶œìš©)
final tradeControllerNotifierProvider = Provider.autoDispose<TradeController>((ref) {
  return ref.watch(tradeControllerProvider.notifier);
});\n\n// ====== lib/presentation/pages/trade_page.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// âœ… ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” import ì œê±°
// import '../../core/common/time_frame_types.dart';
// import '../../core/config/app_config.dart';
// import '../../core/di/core_provider.dart';

import '../controllers/trade_controller.dart';
import '../widgets/trade_tile.dart';

class TradePage extends ConsumerWidget {
  const TradePage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(tradeControllerProvider);
    final controller = ref.read(tradeControllerProvider.notifier);

    final slider = _buildFilterSlider(context, controller, state);
    final tradeList = _buildTradeList(context, state);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Binance Futures - Live Trades'),
        elevation: 1,
      ),
      body: Column(
        children: [
          slider,
          const Divider(height: 1),
          Expanded(child: tradeList),
        ],
      ),
    );
  }

  Widget _buildFilterSlider(
    BuildContext context,
    TradeController controller,
    TradeControllerState state,
  ) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 8, 16, 0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Minimum Value: ${state.currentFilter.displayName}',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
          ),
          Slider(
            value: state.selectedFilterIndex.toDouble(),
            min: 0,
            max: (controller.availableFilters.length - 1).toDouble(),
            divisions: controller.availableFilters.length - 1,
            label: state.currentFilter.displayName,
            onChanged: (value) {
              final newFilter = controller.availableFilters[value.round()];
              controller.setThreshold(newFilter);
            },
            onChangeEnd: (_) {
              HapticFeedback.mediumImpact();
            },
          ),
        ],
      ),
    );
  }

  Widget _buildTradeList(BuildContext context, TradeControllerState state) {
    if (state.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }
    if (state.errorMessage != null) {
      return Center(child: Text('Error: ${state.errorMessage}'));
    }
    if (state.trades.isEmpty) {
      return Center(
        child: Text(
          'No trades captured.\n(Threshold: ${state.currentFilter.displayName})',
          textAlign: TextAlign.center,
          style: TextStyle(color: Theme.of(context).hintColor),
        ),
      );
    }
    
    return RawScrollbar(
      thumbVisibility: true,
      trackVisibility: true,
      interactive: true,
      thickness: 8,
      radius: const Radius.circular(4),
      child: ListView.separated(
        padding: const EdgeInsets.symmetric(vertical: 8.0),
        itemCount: state.trades.length,
        itemBuilder: (context, index) {
          return TradeTile(trade: state.trades[index]);
        },
        separatorBuilder: (context, index) => Divider(
          height: 1,
          thickness: 1,
          // âœ… .withOpacity(0.1) -> .withAlpha(25)ë¡œ ìˆ˜ì • (0.1 * 255 = 25.5)
          color: Theme.of(context).dividerColor.withAlpha(25),
          indent: 16,
          endIndent: 16,
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/widgets/trade_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../domain/entities/trade.dart';

class TradeTile extends ConsumerWidget {
  final Trade trade;

  const TradeTile({Key? key, required this.trade}) : super(key: key);

  static final _timeFormat = DateFormat('HH:mm:ss');
  static final _quantityFormat = NumberFormat('#,##0.###');
  static final _totalFormat = NumberFormat('#,##0');

  String _formatPrice(double price) {
    if (price < 0.01) return price.toStringAsFixed(6);
    if (price < 1) return price.toStringAsFixed(4);
    if (price < 100) return price.toStringAsFixed(2);
    return price.toStringAsFixed(1);
  }

  String _getDisplayName(WidgetRef ref) {
    return trade.market.replaceAll('USDT', '');
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final bool isBuy = trade.isBuy;
    final Color sideColor = isBuy ? Colors.green.shade400 : Colors.red.shade400;

    return Card(
      elevation: 1.5,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 5),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Row(
          children: [
            // âœ… ì‹œê°„ (Flex: 13)
            Expanded(
              flex: 13,
              child: Text(
                _timeFormat.format(trade.dateTime),
                style: theme.textTheme.bodySmall?.copyWith(color: theme.hintColor),
              ),
            ),

            // âœ… í‹°ì»¤ (Flex: 17)
            Expanded(
              flex: 17,
              child: Text(
                _getDisplayName(ref),
                style: theme.textTheme.titleSmall?.copyWith(fontWeight: FontWeight.bold),
                overflow: TextOverflow.ellipsis,
              ),
            ),

            // âœ… ê°€ê²© / ìˆ˜ëŸ‰ (Flex: 20)
            Expanded(
              flex: 20,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    // âœ… ê°€ê²© ì•ì— '$' ê¸°í˜¸ ì¶”ê°€
                    '\$${_formatPrice(trade.price)}',
                    style: theme.textTheme.bodyMedium?.copyWith(fontFamily: 'monospace'),
                  ),
                  const SizedBox(height: 2),
                  Text(
                    _quantityFormat.format(trade.quantity),
                    style: theme.textTheme.bodySmall?.copyWith(color: theme.hintColor),
                  ),
                ],
              ),
            ),

            // âœ… ì´ì•¡ (Flex: 20)
            Expanded(
              flex: 20,
              child: Align(
                alignment: Alignment.centerRight,
                child: Text(
                  // âœ… ì´ì•¡ ì•ì— '$' ê¸°í˜¸ ì¶”ê°€
                  '\$${_totalFormat.format(trade.totalValue)}',
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                    fontFamily: 'monospace',
                    color: sideColor,
                  ),
                ),
              ),
            ),

            // ë°©í–¥ ì•„ì´ì½˜
            Padding(
              padding: const EdgeInsets.only(left: 10.0),
              child: Icon(
                isBuy ? Icons.arrow_upward : Icons.arrow_downward,
                color: sideColor,
                size: 18,
              ),
            ),
          ],
        ),
      ),
    );
  }
}