\n\n// ====== lib/core/di/volume_provider.dart ======\n
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/repositories/volume_repository_impl.dart';
import '../../domain/entities/volume.dart'; // âœ… ëˆ„ë½ëœ import ì¶”ê°€
import '../../domain/repositories/volume_repository.dart';
import '../../domain/usecases/volume_usecase.dart';
import 'core_provider.dart';

// ===================================================================
// 1. Data & Domain Layer Providers
// ===================================================================

final volumeRepositoryProvider = Provider<VolumeRepository>((ref) {
  final remoteDS = ref.watch(tradeRemoteDSProvider); 
  final repo = VolumeRepositoryImpl(remoteDS);
  ref.onDispose(() => repo.dispose());
  return repo;
});

final volumeUsecaseProvider = Provider((ref) {
  final usecase = VolumeUsecase(ref.watch(volumeRepositoryProvider));
  return usecase;
});


// ===================================================================
// 2. UI State & Final Data Provider
// ===================================================================

final volumeTimeFrameProvider = StateProvider<TimeFrame>((ref) => TimeFrame.min5);

final volumeDataProvider = StreamProvider.autoDispose<List<Volume>>((ref) {
  final timeFrame = ref.watch(volumeTimeFrameProvider);
  final marketsAsync = ref.watch(marketsProvider);
  final usecase = ref.read(volumeUsecaseProvider);

  return marketsAsync.when(
    data: (markets) {
      if (markets.isEmpty) return const Stream.empty();
      return usecase.watchVolumeRanking(timeFrame, markets);
    },
    loading: () => const Stream.empty(),
    error: (e, st) => Stream.error(e, st),
  );
});\n\n// ====== lib/data/repositories/volume_repository_impl.dart ======\n
// lib/data/repositories/volume_repository_impl.dart

import 'dart:async';
import 'package:collection/collection.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/trade.dart';
import '../../domain/entities/volume.dart';
import '../../domain/repositories/volume_repository.dart';
import '../datasources/trade_remote_ds.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ì „ìš© ë³¼ë¥¨ Repository (TradeRepositoryImpl ìŠ¤íƒ€ì¼ ì ìš©)
/// - ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ í™œìš©ìœ¼ë¡œ íš¨ìœ¨ì ì¸ ë°ì´í„° ì²˜ë¦¬
/// - ìŠ¤íŠ¸ë¦¼ íƒ€ì…ë³„ ì°¨ë³„í™”ëœ ë³¼ë¥¨ ê³„ì‚°
/// - ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ë°°ì¹˜ ì—…ë°ì´íŠ¸
class VolumeRepositoryImpl implements VolumeRepository {
  final TradeRemoteDataSource _remoteDataSource;
  
  // ğŸ¯ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤
  final Map<TimeFrame, StreamController<List<Volume>>> _controllers = {};
  
  // ğŸ“Š ë³¼ë¥¨ ìºì‹œ ì‹œìŠ¤í…œ
  final Map<TimeFrame, Map<String, double>> _volumeCache = {};
  final Map<TimeFrame, DateTime> _timeFrameStartTimes = {};
  
  // ğŸ”„ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
  StreamSubscription<Trade>? _masterStreamSub;
  bool _isInitialized = false;
  List<String>? _currentMarkets;
  
  // â° íƒ€ì´ë¨¸ë“¤
  Timer? _batchUpdateTimer;
  Timer? _resetCheckTimer;
  
  // ğŸ“ˆ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
  int _processedTradeCount = 0;
  DateTime? _lastUpdateTime;
  
  // ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
  static const Duration _batchUpdateInterval = Duration(milliseconds: 100);
  static const Duration _resetCheckInterval = Duration(seconds: 15);

  VolumeRepositoryImpl(this._remoteDataSource) {
    _initializeControllers();
    _startResetCheckTimer();
    log.i('[VolumeRepository] Initialized');
  }

  /// ğŸš€ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ ì´ˆê¸°í™”
  void _initializeControllers() {
    for (final tf in TimeFrame.values) {
      _controllers[tf] = StreamController<List<Volume>>.broadcast();
      _volumeCache[tf] = <String, double>{};
      _timeFrameStartTimes[tf] = DateTime.now();
    }
  }

  /// ğŸ”¥ ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™” (TradeRepositoryImpl ìŠ¤íƒ€ì¼)
  void _initializeMasterStream(List<String> markets) {
    if (_isInitialized && _marketsEqual(_currentMarkets, markets)) {
      return; // ì´ë¯¸ ê°™ì€ ë§ˆì¼“ìœ¼ë¡œ ì´ˆê¸°í™”ë¨
    }

    log.i('[VolumeRepository] Initializing master stream for ${markets.length} markets');
    
    // ê¸°ì¡´ ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
    _cleanupMasterStream();
    
    _currentMarkets = List<String>.from(markets);
    _isInitialized = true;

    // âœ… TradeRemoteDataSourceì˜ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
    _masterStreamSub = _remoteDataSource.watch(markets).listen(
      _processTrade,
      onError: (error, stackTrace) {
        log.e('[VolumeRepository] Master stream error', error, stackTrace);
      },
      onDone: () {
        log.w('[VolumeRepository] Master stream done');
      },
      cancelOnError: false,
    );

    log.i('[VolumeRepository] Master stream initialized successfully');
  }

  /// ğŸ“¥ ê±°ë˜ ë°ì´í„° ì²˜ë¦¬ (ìŠ¤íŠ¸ë¦¼ íƒ€ì…ë³„ ì°¨ë³„í™”)
  void _processTrade(Trade trade) {
    try {
      // âœ… ë°ì´í„° ê²€ì¦
      if (!trade.isValidData) {
        log.w('[VolumeRepository] Invalid trade data: ${trade.market}');
        return;
      }

      _processedTradeCount++;
      _lastUpdateTime = DateTime.now();

      // âœ… [í•µì‹¬] ìŠ¤íŠ¸ë¦¼ íƒ€ì…ë³„ ë³¼ë¥¨ ê³„ì‚° ì „ëµ
      double volumeToAdd = 0.0;
      
      switch (trade.streamType) {
        case BinanceStreamType.aggTrade:
          // aggTrade: ì‹¤ì œ ê±°ë˜ ë³¼ë¥¨ ì‚¬ìš©
          volumeToAdd = trade.totalValue;
          break;
          
        case BinanceStreamType.ticker:
          // ticker: 24ì‹œê°„ ê±°ë˜ëŸ‰ ì •ë³´ (quoteVolume) ì‚¬ìš©
          volumeToAdd = trade.totalValue; // tickerì˜ ê²½ìš° ì´ë¯¸ ëˆ„ì  ë³¼ë¥¨
          break;
          
        case BinanceStreamType.bookTicker:
        case BinanceStreamType.depth5:
          // í˜¸ê°€ ë°ì´í„°ëŠ” ë³¼ë¥¨ ê³„ì‚°ì—ì„œ ì œì™¸
          return;
      }

      if (volumeToAdd <= 0) return;

      // ëª¨ë“  íƒ€ì„í”„ë ˆì„ì— ë³¼ë¥¨ ì¶”ê°€
      for (final tf in TimeFrame.values) {
        final cache = _volumeCache[tf]!;
        cache[trade.market] = (cache[trade.market] ?? 0.0) + volumeToAdd;
      }

      // ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§
      _scheduleBatchUpdate();

    } catch (e, st) {
      log.e('[VolumeRepository] Trade processing error', e, st);
    }
  }

  /// â° ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§ (TradeRepositoryImpl ìŠ¤íƒ€ì¼)
  void _scheduleBatchUpdate() {
    _batchUpdateTimer?.cancel();
    _batchUpdateTimer = Timer(_batchUpdateInterval, _performBatchUpdate);
  }

  /// ğŸ“Š ì‹¤ì œ UI ì—…ë°ì´íŠ¸ ìˆ˜í–‰
  void _performBatchUpdate() {
    try {
      final now = DateTime.now().millisecondsSinceEpoch;
      
      for (final tf in TimeFrame.values) {
        final cache = _volumeCache[tf]!;
        final startTime = _timeFrameStartTimes[tf]!;
        
        if (cache.isEmpty) continue;
        
        // Volume ê°ì²´ ë¦¬ìŠ¤íŠ¸ ìƒì„± ë° ì •ë ¬
        final volumeList = cache.entries
            .map((entry) => Volume(
                  market: entry.key,
                  totalValue: entry.value,
                  lastUpdated: now,
                  timeFrame: tf,
                  timeFrameStart: startTime.millisecondsSinceEpoch,
                ))
            .sorted((a, b) => b.totalValue.compareTo(a.totalValue));
        
        // ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ì— ì—…ë°ì´íŠ¸ ì „ì†¡
        final controller = _controllers[tf];
        if (controller != null && !controller.isClosed) {
          controller.add(volumeList);
        }
      }

    } catch (e, st) {
      log.e('[VolumeRepository] Batch update error', e, st);
    }
  }

  /// â° íƒ€ì„í”„ë ˆì„ ë¦¬ì…‹ ì²´í¬ íƒ€ì´ë¨¸ ì‹œì‘
  void _startResetCheckTimer() {
    _resetCheckTimer = Timer.periodic(_resetCheckInterval, (_) {
      _checkTimeFrameResets();
    });
  }

  /// ğŸ”„ íƒ€ì„í”„ë ˆì„ ë¦¬ì…‹ ì²´í¬
  void _checkTimeFrameResets() {
    try {
      final now = DateTime.now();
      
      for (final tf in TimeFrame.values) {
        final startTime = _timeFrameStartTimes[tf]!;
        if (now.difference(startTime) >= tf.duration) {
          _resetTimeFrame(tf, now);
          log.d('[VolumeRepository] Auto-reset timeframe: ${tf.name}');
        }
      }
    } catch (e, st) {
      log.e('[VolumeRepository] Reset check error', e, st);
    }
  }

  /// ğŸ”„ íŠ¹ì • íƒ€ì„í”„ë ˆì„ ë¦¬ì…‹
  void _resetTimeFrame(TimeFrame timeFrame, DateTime newStartTime) {
    try {
      _volumeCache[timeFrame]?.clear();
      _timeFrameStartTimes[timeFrame] = newStartTime;
      
      // ì¦‰ì‹œ ì—…ë°ì´íŠ¸ (ë¹ˆ ë¦¬ìŠ¤íŠ¸ ì „ì†¡)
      final controller = _controllers[timeFrame];
      if (controller != null && !controller.isClosed) {
        controller.add(<Volume>[]);
      }
      
      log.i('[VolumeRepository] Reset timeframe: ${timeFrame.name}');
    } catch (e, st) {
      log.e('[VolumeRepository] Reset timeframe error', e, st);
    }
  }

  /// ğŸ”„ ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
  void _cleanupMasterStream() {
    _masterStreamSub?.cancel();
    _masterStreamSub = null;
    _isInitialized = false;
  }

  /// ğŸ” ë§ˆì¼“ ë¦¬ìŠ¤íŠ¸ ë¹„êµ
  bool _marketsEqual(List<String>? a, List<String>? b) {
    if (a == null || b == null) return false;
    if (a.length != b.length) return false;
    return Set<String>.from(a).containsAll(b);
  }

  // ===================================================================
  // VolumeRepository ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
  // ===================================================================

  @override
  Stream<List<Volume>> watchVolumeRanking(TimeFrame timeFrame, List<String> markets) {
    log.d('[VolumeRepository] watchVolumeRanking() called for ${timeFrame.name} with ${markets.length} markets');
    
    // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
    _initializeMasterStream(markets);
    
    // ì¦‰ì‹œ í˜„ì¬ ìƒíƒœ ì—…ë°ì´íŠ¸
    Future.microtask(_performBatchUpdate);
    
    // í•´ë‹¹ íƒ€ì„í”„ë ˆì„ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜
    final controller = _controllers[timeFrame];
    return controller?.stream ?? const Stream.empty();
  }

  @override
  void resetTimeFrame(TimeFrame timeFrame) {
    log.i('[VolumeRepository] Manual reset requested for ${timeFrame.name}');
    _resetTimeFrame(timeFrame, DateTime.now());
  }

  @override
  void resetAllTimeFrames() {
    log.i('[VolumeRepository] Manual reset requested for ALL timeframes');
    final now = DateTime.now();
    for (final tf in TimeFrame.values) {
      _resetTimeFrame(tf, now);
    }
  }

  /// âœ… [ì¶”ê°€] í˜„ì¬ ìƒíƒœ ì¡°íšŒ
  Map<String, dynamic> getStatus() {
    return {
      'isInitialized': _isInitialized,
      'currentMarkets': _currentMarkets?.length ?? 0,
      'processedTradeCount': _processedTradeCount,
      'lastUpdateTime': _lastUpdateTime?.toIso8601String(),
      'timeFrameCacheSize': _volumeCache.map((tf, cache) => MapEntry(tf.name, cache.length)),
      'timeFrameStartTimes': _timeFrameStartTimes.map((tf, time) => MapEntry(tf.name, time.toIso8601String())),
    };
  }

  /// âœ… [ì¶”ê°€] íŠ¹ì • íƒ€ì„í”„ë ˆì„ì˜ ë§ˆì¼“ ìˆ˜ ì¡°íšŒ
  int getMarketCountForTimeFrame(TimeFrame timeFrame) {
    return _volumeCache[timeFrame]?.length ?? 0;
  }

  @override
  Future<void> dispose() async {
    log.i('[VolumeRepository] Disposing... Status: ${getStatus()}');
    
    // íƒ€ì´ë¨¸ë“¤ ì •ë¦¬
    _batchUpdateTimer?.cancel();
    _resetCheckTimer?.cancel();
    
    // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
    _cleanupMasterStream();
    
    // ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ ì •ë¦¬
    for (final controller in _controllers.values) {
      if (!controller.isClosed) {
        await controller.close();
      }
    }
    _controllers.clear();
    
    // ìºì‹œ ì •ë¦¬
    _volumeCache.clear();
    _timeFrameStartTimes.clear();
    _currentMarkets = null;
    
    log.i('[VolumeRepository] Disposed successfully');
  }
}\n\n// ====== lib/data/processors/volume_processor.dart ======\n
\n\n// ====== lib/domain/repositories/volume_repository.dart ======\n
// lib/domain/repositories/volume_repository.dart

import '../entities/trade.dart';
import '../entities/volume.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ì‹œê°„ëŒ€ë³„ ê±°ë˜ëŸ‰ ë°ì´í„° Repository ì¸í„°í˜ì´ìŠ¤
/// - ë©€í‹° ìŠ¤íŠ¸ë¦¼ íƒ€ì… ê¸°ë°˜ ë³¼ë¥¨ ê³„ì‚° (aggTrade, ticker ë“±)
/// - ì‹¤ì‹œê°„ íƒ€ì„í”„ë ˆì„ë³„ ê±°ë˜ëŸ‰ ìˆœìœ„ ì œê³µ
/// - ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ë°°ì¹˜ ì—…ë°ì´íŠ¸ ì‹œìŠ¤í…œ
abstract class VolumeRepository {
  /// ğŸ“Š ì§€ì •ëœ ì‹œê°„ëŒ€ì˜ ê±°ë˜ëŸ‰ ìˆœìœ„ ìŠ¤íŠ¸ë¦¼ì„ ì œê³µí•©ë‹ˆë‹¤.
  /// 
  /// [timeFrame] ì§‘ê³„ ì‹œê°„ ë‹¨ìœ„ (1ë¶„, 5ë¶„, 1ì‹œê°„ ë“±)
  /// [markets] êµ¬ë…í•  ë§ˆì¼“ ëª©ë¡ (ì˜ˆ: ['BTCUSDT', 'ETHUSDT'])
  /// Returns: ê±°ë˜ëŸ‰ ìˆœìœ¼ë¡œ ì •ë ¬ëœ Volume ë¦¬ìŠ¤íŠ¸ì˜ ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¼
  Stream<List<Volume>> watchVolumeRanking(TimeFrame timeFrame, List<String> markets);

  /// ğŸ”„ íŠ¹ì • ì‹œê°„ëŒ€ì˜ ëˆ„ì  ê±°ë˜ëŸ‰ì„ ìˆ˜ë™ìœ¼ë¡œ ë¦¬ì…‹í•©ë‹ˆë‹¤.
  /// 
  /// [timeFrame] ë¦¬ì…‹í•  íƒ€ì„í”„ë ˆì„
  void resetTimeFrame(TimeFrame timeFrame);

  /// ğŸ”„ ëª¨ë“  ì‹œê°„ëŒ€ì˜ ëˆ„ì  ê±°ë˜ëŸ‰ì„ ìˆ˜ë™ìœ¼ë¡œ ë¦¬ì…‹í•©ë‹ˆë‹¤.
  /// 
  /// ëª¨ë“  íƒ€ì„í”„ë ˆì„ì˜ ë³¼ë¥¨ ìºì‹œë¥¼ ì¦‰ì‹œ ì´ˆê¸°í™”
  void resetAllTimeFrames();

  /// âœ… [ì¶”ê°€] í˜„ì¬ ìƒíƒœ ì¡°íšŒ
  /// 
  /// Repositoryì˜ í˜„ì¬ ìƒíƒœ ì •ë³´ë¥¼ ì œê³µ (ë””ë²„ê¹…/ëª¨ë‹ˆí„°ë§ìš©)
  /// Returns: ì´ˆê¸°í™” ìƒíƒœ, ì²˜ë¦¬ëœ ê±°ë˜ ìˆ˜, ìºì‹œ í¬ê¸° ë“±ì˜ ìƒíƒœ ì •ë³´
  Map<String, dynamic> getStatus();

  /// âœ… [ì¶”ê°€] íŠ¹ì • íƒ€ì„í”„ë ˆì„ì˜ ë§ˆì¼“ ìˆ˜ ì¡°íšŒ
  /// 
  /// [timeFrame] ì¡°íšŒí•  íƒ€ì„í”„ë ˆì„
  /// Returns: í•´ë‹¹ íƒ€ì„í”„ë ˆì„ì—ì„œ ê±°ë˜ëŸ‰ì´ ê¸°ë¡ëœ ë§ˆì¼“ ìˆ˜
  int getMarketCountForTimeFrame(TimeFrame timeFrame);

  /// ğŸ§¹ ë¦¬ì†ŒìŠ¤ë¥¼ ì •ë¦¬í•©ë‹ˆë‹¤.
  /// 
  /// ìŠ¤íŠ¸ë¦¼ êµ¬ë…, íƒ€ì´ë¨¸, ë©”ëª¨ë¦¬ ìºì‹œ ë“± ëª¨ë“  ë¦¬ì†ŒìŠ¤ í•´ì œ
  Future<void> dispose();
}\n\n// ====== lib/domain/usecases/volume_usecase.dart ======\n
// lib/domain/usecases/volume_usecase.dart

import '../entities/volume.dart';
import '../repositories/volume_repository.dart';

class VolumeUsecase {
  final VolumeRepository _repository;

  VolumeUsecase(this._repository);

  Stream<List<Volume>> watchVolumeRanking(TimeFrame timeFrame, List<String> markets) {
    return _repository.watchVolumeRanking(timeFrame, markets);
  }

  void resetTimeFrame(TimeFrame timeFrame) {
    _repository.resetTimeFrame(timeFrame);
  }

  void resetAllTimeFrames() {
    _repository.resetAllTimeFrames();
  }

  void dispose() {
    _repository.dispose();
  }
}\n\n// ====== lib/domain/entities/volume.dart ======\n
import 'package:equatable/equatable.dart';

/// ê±°ë˜ëŸ‰ ë°ì´í„°ë¥¼ ì§‘ê³„í•  ì‹œê°„ëŒ€(TimeFrame)ë¥¼ ì •ì˜í•˜ëŠ” Enum
enum TimeFrame {
  min1(1, '1m'),
  min3(3, '3m'),
  min5(5, '5m'),
  min15(15, '15m'),
  min30(30, '30m'),
  hour1(60, '1h'),
  hour2(120, '2h'),
  hour4(240, '4h'),
  hour6(360, '6h'),
  hour12(720, '12h'),
  day1(1440, '1d'),
  week1(10080, '1w');

  const TimeFrame(this.minutes, this.displayName);
  final int minutes;
  final String displayName;

  Duration get duration => Duration(minutes: minutes);
}


/// ë§ˆì¼“ë³„, ì‹œê°„ëŒ€ë³„ ëˆ„ì  ê±°ë˜ëŸ‰ ì •ë³´ë¥¼ ë‹´ëŠ” ë°ì´í„° ëª¨ë¸
class Volume extends Equatable {
  /// ë§ˆì¼“ ì‹¬ë³¼ (e.g., "BTCUSDT")
  final String market;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ëˆ„ì  ê±°ë˜ëŒ€ê¸ˆ (ë‹¨ìœ„: USDT)
  final double totalValue;
  
  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê° (milliseconds from epoch)
  final int lastUpdated;
  
  /// ë°ì´í„° ì§‘ê³„ ê¸°ì¤€ ì‹œê°„ëŒ€
  final TimeFrame timeFrame;
  
  /// í˜„ì¬ ì‹œê°„ëŒ€(ë´‰)ê°€ ì‹œì‘ëœ ì‹œê° (milliseconds from epoch)
  final int timeFrameStart;

  const Volume({
    required this.market,
    required this.totalValue,
    required this.lastUpdated,
    required this.timeFrame,
    required this.timeFrameStart,
  });
  
  /// ì½”ì¸ í‹°ì»¤ë§Œ ì¶”ì¶œ (e.g., "BTCUSDT" -> "BTC")
  String get ticker => market.replaceAll('USDT', '');

  /// í˜„ì¬ ì‹œê°„ëŒ€(ë´‰)ê°€ ëë‚˜ëŠ” ì˜ˆì • ì‹œê°
  DateTime get timeFrameEnd =>
      DateTime.fromMillisecondsSinceEpoch(timeFrameStart).add(timeFrame.duration);

  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ (ì´ˆ)
  int get remainingSeconds {
    final remaining = timeFrameEnd.difference(DateTime.now()).inSeconds;
    return remaining > 0 ? remaining : 0;
  }
  
  @override
  List<Object> get props => [market, timeFrame];
}\n\n// ====== lib/presentation/controllers/volume_controller.dart ======\n
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/volume_provider.dart';
import '../../domain/entities/volume.dart';
import '../../domain/usecases/volume_usecase.dart';

/// VolumePageì˜ UI ìƒíƒœë¥¼ ë‹´ëŠ” ë¶ˆë³€ í´ë˜ìŠ¤
class VolumeControllerState {
  final bool isTop100;

  const VolumeControllerState({this.isTop100 = false}); // ê¸°ë³¸ê°’ Top 50

  VolumeControllerState copyWith({bool? isTop100}) {
    return VolumeControllerState(isTop100: isTop100 ?? this.isTop100);
  }
}

/// VolumePageì˜ ìƒíƒœì™€ ë¡œì§ì„ ê´€ë¦¬í•˜ëŠ” ì»¨íŠ¸ë¡¤ëŸ¬
class VolumeController extends StateNotifier<VolumeControllerState> {
  final Ref _ref;

  VolumeController(this._ref) : super(const VolumeControllerState());

  // --- UI ìƒíƒœ ë³€ê²½ ë©”ì„œë“œ ---

  /// Top 50ê³¼ Top 100 í‘œì‹œë¥¼ í† ê¸€í•©ë‹ˆë‹¤.
  void toggleTopLimit() {
    state = state.copyWith(isTop100: !state.isTop100);
  }

  /// ì‹œê°„ëŒ€(TimeFrame)ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
  void setTimeFrame(TimeFrame newTimeFrame) {
    _ref.read(volumeTimeFrameProvider.notifier).state = newTimeFrame;
  }

  // --- ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ í˜¸ì¶œ ë©”ì„œë“œ ---

  /// í˜„ì¬ ì‹œê°„ëŒ€ì˜ ê±°ë˜ëŸ‰ì„ ë¦¬ì…‹í•©ë‹ˆë‹¤.
  void resetCurrentTimeFrame() {
    final usecase = _ref.read(volumeUsecaseProvider);
    final currentTimeFrame = _ref.read(volumeTimeFrameProvider);
    usecase.resetTimeFrame(currentTimeFrame);
  }

  // --- UIì— í•„ìš”í•œ ë°ì´í„° getter ---

  /// í˜„ì¬ ì„ íƒëœ ì‹œê°„ëŒ€
  TimeFrame get currentTimeFrame => _ref.watch(volumeTimeFrameProvider);
  
  /// ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“  ì‹œê°„ëŒ€ ëª©ë¡
  List<TimeFrame> get availableTimeFrames => TimeFrame.values;
  
  /// í˜„ì¬ í‘œì‹œí•  ëª©ë¡ ê°œìˆ˜ (50 ë˜ëŠ” 100)
  int get currentLimit => state.isTop100 ? 100 : 50;
  
  /// í˜„ì¬ í‘œì‹œ ëª¨ë“œ ì´ë¦„
  String get currentLimitName => state.isTop100 ? 'Top 100' : 'Top 50';
}


/// VolumeControllerë¥¼ ì œê³µí•˜ëŠ” ìµœì¢… Provider
final volumeControllerProvider =
    StateNotifierProvider.autoDispose<VolumeController, VolumeControllerState>((ref) {
  return VolumeController(ref);
});\n\n// ====== lib/presentation/pages/volume_page.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../core/common/time_frame_types.dart';
import '../../core/di/volume_provider.dart';
import '../../domain/entities/volume.dart';
import '../controllers/volume_controller.dart';
import '../widgets/volume_tile.dart';

class VolumePage extends ConsumerWidget {
  const VolumePage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final volumeDataAsync = ref.watch(volumeDataProvider);
    final uiState = ref.watch(volumeControllerProvider);
    final controller = ref.read(volumeControllerProvider.notifier);
    
    return Column(
      children: [
        // âœ… [ìˆ˜ì •] refë¥¼ ì „ë‹¬í•˜ì—¬ ì˜¤ë¥˜ í•´ê²°
        _buildControls(context, ref, controller, uiState),
        const Divider(height: 1),
        Expanded(
          child: volumeDataAsync.when(
            data: (volumes) => _buildVolumeList(context, volumes, uiState),
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (e, st) => Center(child: Text('Error: $e')),
          ),
        ),
      ],
    );
  }

  Widget _buildControls(BuildContext context, WidgetRef ref, VolumeController controller, VolumeControllerState uiState) {
    final currentTimeFrame = controller.currentTimeFrame;

    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 8, 16, 0),
      child: Column(
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Text(
                'Timeframe: ${currentTimeFrame.displayName}',
                style: Theme.of(context).textTheme.titleSmall?.copyWith(fontWeight: FontWeight.bold),
              ),
              _buildTopLimitToggle(controller, uiState),
              // âœ… [ìˆ˜ì •] refë¥¼ ì „ë‹¬í•˜ì—¬ ì˜¤ë¥˜ í•´ê²°
              _buildCountdownWidget(context, ref),
            ],
          ),
          Slider(
            value: TimeFrame.values.indexOf(currentTimeFrame).toDouble(),
            min: 0,
            max: (controller.availableTimeFrames.length - 1).toDouble(),
            divisions: controller.availableTimeFrames.length - 1,
            label: currentTimeFrame.displayName,
            onChanged: (value) {
              final newTimeFrame = controller.availableTimeFrames[value.round()];
              controller.setTimeFrame(newTimeFrame);
            },
            onChangeEnd: (_) => HapticFeedback.mediumImpact(),
          ),
        ],
      ),
    );
  }

  Widget _buildTopLimitToggle(VolumeController controller, VolumeControllerState uiState) {
    return GestureDetector(
      onTap: () {
        HapticFeedback.lightImpact();
        controller.toggleTopLimit();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        decoration: BoxDecoration(
          // âœ… [ìˆ˜ì •] .withOpacity -> .withAlphaë¡œ ë³€ê²½
          color: uiState.isTop100 ? Colors.orange.withAlpha(51) : Colors.transparent, // 0.2 opacity
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.orange.withAlpha(179), width: 1.5), // 0.7 opacity
        ),
        child: Text(
          controller.currentLimitName,
          style: const TextStyle(
            fontSize: 12,
            fontWeight: FontWeight.w600,
            color: Colors.orange,
          ),
        ),
      ),
    );
  }

  Widget _buildCountdownWidget(BuildContext context, WidgetRef ref) {
    final volumeData = ref.watch(volumeDataProvider);
    final remainingSeconds = volumeData.when(
      data: (volumes) => volumes.isNotEmpty ? volumes.first.remainingSeconds : 0,
      loading: () => 0,
      error: (_, __) => 0,
    );
    
    final minutes = remainingSeconds ~/ 60;
    final seconds = remainingSeconds % 60;
    final timeStr = '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(Icons.timer_outlined, size: 16, color: Theme.of(context).hintColor),
        const SizedBox(width: 4),
        SizedBox(
          width: 42,
          child: Text(
            timeStr,
            style: const TextStyle(
              fontSize: 14,
              color: Colors.orange,
              fontWeight: FontWeight.bold,
              fontFamily: 'monospace',
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildVolumeList(BuildContext context, List<Volume> volumes, VolumeControllerState uiState) {
    if (volumes.isEmpty) {
      return const Center(child: Text('ê±°ë˜ëŸ‰ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.'));
    }
    
    final limitedList = volumes.take(uiState.isTop100 ? 100 : 50).toList();
    
    return RawScrollbar(
      thumbVisibility: true,
      thickness: 8,
      radius: const Radius.circular(4),
      child: ListView.builder(
        primary: false,
        padding: const EdgeInsets.symmetric(vertical: 4.0, horizontal: 12.0),
        itemCount: limitedList.length,
        itemBuilder: (context, index) => VolumeTile(
          volume: limitedList[index],
          rank: index + 1,
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/widgets/volume_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import '../../domain/entities/volume.dart';

final Map<String, int> _previousRanks = {};

class VolumeTile extends StatefulWidget {
  final Volume volume;
  final int rank;

  const VolumeTile({
    Key? key,
    required this.volume,
    required this.rank,
  }) : super(key: key);

  @override
  State<VolumeTile> createState() => _VolumeTileState();
}

class _VolumeTileState extends State<VolumeTile> with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<Color?> _colorAnimation;

  static final _volumeFormatter = NumberFormat.compact(locale: 'en_US');

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 750),
      vsync: this,
    );
    _colorAnimation = ColorTween(begin: Colors.transparent, end: Colors.transparent)
        .animate(_animationController);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) _checkRankChange();
    });
  }

  @override
  void didUpdateWidget(VolumeTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.rank != oldWidget.rank) {
      _checkRankChange();
    }
  }

  void _checkRankChange() {
    final previousRank = _previousRanks[widget.volume.market];
    final currentRank = widget.rank;
    
    if (previousRank != null && currentRank < previousRank) {
      _colorAnimation = ColorTween(
        begin: Colors.green.withAlpha(102), // 0.4 opacity
        end: Colors.transparent,
      ).animate(CurvedAnimation(parent: _animationController, curve: Curves.easeOut));
      _animationController.forward(from: 0.0);
    }
    
    _previousRanks[widget.volume.market] = currentRank;
  }
  
  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }
  
  Color _getRankColor(BuildContext context) {
    if (widget.rank <= 3) return Colors.amber.shade600;
    if (widget.rank <= 10) return Theme.of(context).colorScheme.primary;
    // âœ… [ìˆ˜ì •] .withOpacity -> .withAlphaë¡œ ë³€ê²½
    return Theme.of(context).colorScheme.onSurface.withAlpha(179); // 0.7 opacity
  }
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final rankColor = _getRankColor(context);

    return AnimatedBuilder(
      animation: _colorAnimation,
      builder: (context, child) {
        return Container(
          margin: const EdgeInsets.symmetric(vertical: 3.0),
          decoration: BoxDecoration(
            color: _colorAnimation.value,
            borderRadius: BorderRadius.circular(8.0),
          ),
          child: child,
        );
      },
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 14.0),
        child: Row(
          children: [
            Text(
              '${widget.rank}',
              style: theme.textTheme.titleSmall?.copyWith(
                color: rankColor,
                fontWeight: FontWeight.bold,
                fontFamily: 'monospace',
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              flex: 4,
              child: Text(
                widget.volume.ticker,
                style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
                overflow: TextOverflow.ellipsis,
              ),
            ),
            Expanded(
              flex: 5,
              child: Text(
                '\$${_volumeFormatter.format(widget.volume.totalValue)}',
                textAlign: TextAlign.end,
                style: theme.textTheme.bodyLarge?.copyWith(
                  fontFamily: 'monospace',
                  fontWeight: FontWeight.w500,
                  color: theme.colorScheme.onSurface,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}