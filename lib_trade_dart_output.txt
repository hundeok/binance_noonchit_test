\n\n// ====== lib/core/di/trade_provider.dart ======\n
\n\n// ====== lib/core/network/websocket/clients/trade_ws_client.dart ======\n
\n\n// ====== lib/core/network/websocket/trade_ws_client.dart ======\n
import 'dart:convert';
import 'dart:math';
import '../../config/app_config.dart';
import '../../../domain/entities/trade.dart';
import '../../utils/logger.dart';
import 'base_ws_client.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ aggTrade ìŠ¤íŠ¸ë¦¼ ì „ìš© í´ë¼ì´ì–¸íŠ¸ (ë°±ì„œ 100% ì¤€ìˆ˜)
class TradeWsClient extends BaseWsClient<Trade> {

  TradeWsClient({
    void Function(WsStatus status)? onStatusChange,
    bool enableVerboseLogging = false,
  }) : super(
          url: AppConfig.streamUrl,
          onStatusChange: onStatusChange,
          pongTimeout: AppConfig.wsPongTimeout,
          encodeSubscribe: (markets) => _encodeSubscribeMessage(markets),
          // âœ… [ìˆ˜ì •] ë‹¤ì‹œ static ë©”ì„œë“œë¥¼ ì „ë‹¬í•˜ì—¬ ì´ë‹ˆì…œë¼ì´ì € ì˜¤ë¥˜ í•´ê²°
          decode: (json) => _decodeTradeMessage(json, enableVerboseLogging),
        );

  // ===================================================================
  // ğŸ“¨ êµ¬ë… ë©”ì‹œì§€ ì¸ì½”ë”© (ë°”ì´ë‚¸ìŠ¤ ë°±ì„œ ì¤€ìˆ˜)
  // ===================================================================

  static String _encodeSubscribeMessage(List<String> markets) {
    if (markets.length > AppConfig.wsMaxStreams) {
      throw ArgumentError('Too many streams: ${markets.length}. '
          'Binance limit: ${AppConfig.wsMaxStreams} streams per connection.');
    }

    final params =
        markets.map((symbol) => '${symbol.toLowerCase()}@aggTrade').toList();
    
    // âœ… [ìˆ˜ì •] String IDë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
    final messageId = _generateUniqueMessageId();

    final subscribeMessage = {
      'method': 'SUBSCRIBE',
      'params': params,
      'id': messageId,
    };

    final jsonMessage = jsonEncode(subscribeMessage);

    log.i('[TradeWS] ğŸ“¤ Subscribing to ${params.length} aggTrade streams');
    log.d('[TradeWS] Subscription message: $jsonMessage');

    return jsonMessage;
  }

  /// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ í˜¸í™˜ ê³ ìœ  ë©”ì‹œì§€ ID ìƒì„± (String ë°˜í™˜)
  static String _generateUniqueMessageId() {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    // ì¶©ëŒ ë°©ì§€ë¥¼ ìœ„í•œ ëœë¤ ìˆ«ì ì¶”ê°€
    final randomPart = Random().nextInt(99999).toString().padLeft(5, '0');
    return '$timestamp$randomPart';
  }

  // ===================================================================
  // ğŸ“¥ ë©”ì‹œì§€ ë””ì½”ë”© (ë°”ì´ë‚¸ìŠ¤ Combined Stream ì²˜ë¦¬)
  // ===================================================================

  static Trade? _decodeTradeMessage(
      Map<String, dynamic> json, bool verboseLogging) {
    if (json.isEmpty) {
      if (verboseLogging) log.w('[TradeWS] Empty message received');
      return null;
    }

    if (json.containsKey('result')) {
      if (json['result'] == null) {
        log.i('[TradeWS] âœ… Subscription confirmed: ${json['id']}');
      } else if (json['result'] is List) {
        final subscriptions = json['result'] as List;
        log.i('[TradeWS] ğŸ“‹ Active subscriptions: ${subscriptions.length}');
      }
      return null;
    }

    if (json.containsKey('stream') && json.containsKey('data')) {
      final streamName = json['stream'] as String?;
      final data = json['data'];

      if (streamName == null ||
          data == null ||
          !streamName.endsWith('@aggTrade')) {
        return null;
      }
      return _parseTradeData(data, streamName, verboseLogging);
    }

    if (json.containsKey('e') && json['e'] == 'aggTrade') {
      return _parseTradeData(json, 'direct', verboseLogging);
    }

    if (verboseLogging) {
      log.w('[TradeWS] Unknown message type: ${json.keys.join(', ')}');
    }
    return null;
  }

  /// ğŸ¯ ì‹¤ì œ ê±°ë˜ ë°ì´í„° íŒŒì‹±
  static Trade? _parseTradeData(
      dynamic data, String streamInfo, bool verboseLogging) {
    try {
      if (data is! Map<String, dynamic> || data['e'] != 'aggTrade') {
        return null;
      }

      final trade = Trade.fromBinance(data);

      // âœ… [ìˆ˜ì •] Trade ê°ì²´ ì†ì„±ì— ì˜ì¡´í•˜ì§€ ì•Šê³  ì›ë³¸ ë°ì´í„°ë¡œ ë¡œê·¸ ê¸°ë¡
      if (verboseLogging) {
        final symbol = data['s'] as String? ?? 'UNKNOWN';
        final price = data['p'] as String? ?? '0';
        final quantity = data['q'] as String? ?? '0';
        log.d('[TradeWS] ğŸ’° $symbol: $price Ã— $quantity (Stream: $streamInfo)');
      }

      return trade;
    } catch (e, st) {
      log.e('[TradeWS] Trade parsing failed (Stream: $streamInfo)', e, st);
      return null;
    }
  }

  // âŒ [ì œê±°] í†µê³„ ê´€ë ¨ ë¡œì§ì€ ì´ í´ë˜ìŠ¤ì˜ ì±…ì„ì„ ë²—ì–´ë‚˜ë¯€ë¡œ ëª¨ë‘ ì œê±°.
  // ì´ í´ë˜ìŠ¤ëŠ” ìˆœìˆ˜í•˜ê²Œ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ì„ ì œê³µí•˜ëŠ” ì—­í• ë§Œ ìˆ˜í–‰.
}\n\n// ====== lib/data/datasources/trade_remote_ds.dart ======\n
// lib/data/datasources/trade_remote_ds.dart

import '../../core/network/websocket/trade_ws_client.dart';
import '../../domain/entities/trade.dart';

/// ì›ê²© WebSocketìœ¼ë¡œë¶€í„° ì‹¤ì‹œê°„ Trade ë°ì´í„°ë¥¼ ìˆ˜ì‹ í•˜ëŠ” ë°ì´í„° ì†ŒìŠ¤
class TradeRemoteDataSource {
  final TradeWsClient _wsClient;

  TradeRemoteDataSource(this._wsClient);

  /// WebSocket í´ë¼ì´ì–¸íŠ¸ì— ë§ˆì¼“ êµ¬ë…ì„ ìš”ì²­í•˜ê³ ,
  /// ë°˜í™˜ë˜ëŠ” ìˆœìˆ˜ Trade ìŠ¤íŠ¸ë¦¼ì„ ê·¸ëŒ€ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
  Stream<Trade> watchTrades(List<String> markets) {
    _wsClient.connect(markets);
    return _wsClient.stream;
  }
}\n\n// ====== lib/data/repositories/trade_repository_impl.dart ======\n
// lib/data/repositories/trade_repository_impl.dart

import 'dart:async';
import 'dart:collection';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/common/time_frame_types.dart';
import '../../domain/entities/trade.dart';
import '../../domain/repositories/trade_repository.dart';
import '../datasources/trade_remote_ds.dart';
import '../processors/trade_aggregator.dart';
import '../../core/utils/logger.dart';

class TradeRepositoryImpl implements TradeRepository {
  final TradeRemoteDataSource _remoteDataSource;
  final TradeAggregator _aggregator;
  
  // ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬
  final _filteredTradesController = StreamController<List<Trade>>.broadcast();
  
  // ë‚´ë¶€ ìƒíƒœ
  StreamSubscription? _rawTradeSub;
  StreamSubscription? _aggregatedTradeSub;
  double _currentThreshold = TradeFilter.usdt50k.value; // ê¸°ë³¸ ì„ê³„ê°’
  final Map<TradeFilter, List<Trade>> _filterCache = {
    for (var filter in TradeFilter.values) filter: []
  };
  final _seenIds = LinkedHashSet<String>();
  Timer? _batchUpdateTimer;
  bool _isInitialized = false;

  TradeRepositoryImpl(this._remoteDataSource) : _aggregator = TradeAggregator();

  void _initialize(List<String> markets) {
    if (_isInitialized) return;
    _isInitialized = true;

    // 1. ì›ê²© ë°ì´í„° ì†ŒìŠ¤ì˜ ìŠ¤íŠ¸ë¦¼ì„ êµ¬ë…
    final rawTradeStream = _remoteDataSource.watchTrades(markets);
    _rawTradeSub = rawTradeStream.listen(_processRawTrade);

    // 2. ì§‘ê³„ê¸°(Aggregator)ì˜ ìŠ¤íŠ¸ë¦¼ì„ êµ¬ë…
    _aggregatedTradeSub = _aggregator.stream.listen(_handleAggregatedTrade);
    
    log.i('[Repository] Initialized with ${markets.length} markets.');
  }

  /// 1. ì›ì‹œ ë°ì´í„° ì²˜ë¦¬: ì¤‘ë³µ í™•ì¸ í›„ ì§‘ê³„ê¸°ë¡œ ì „ë‹¬
  void _processRawTrade(Trade trade) {
    if (!_seenIds.add(trade.tradeId)) return;
    if (_seenIds.length > TradeConfig.maxSeenIdsCacheSize) {
      _seenIds.remove(_seenIds.first);
    }
    _aggregator.process(trade);
  }

  /// 2. ì§‘ê³„ëœ ë°ì´í„° ì²˜ë¦¬: í•„í„°ë³„ ìºì‹œì— ì €ì¥
  void _handleAggregatedTrade(Trade trade) {
    for (final filter in TradeFilter.values) {
      if (trade.totalValue >= filter.value) {
        final list = _filterCache[filter]!;
        list.insert(0, trade);
        if (list.length > TradeConfig.maxTradesPerFilter) {
          list.removeLast();
        }
      }
    }
    // UI ì—…ë°ì´íŠ¸ëŠ” ë°”ë¡œ í•˜ì§€ ì•Šê³ , ë°°ì¹˜ ìŠ¤ì¼€ì¤„ë§
    _scheduleBatchUpdate();
  }
  
  /// 3. ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§: 100ms ì´ë‚´ì˜ ë³€ê²½ì‚¬í•­ì€ í•œ ë²ˆì— ëª¨ì•„ì„œ UI ì—…ë°ì´íŠ¸
  void _scheduleBatchUpdate() {
    _batchUpdateTimer?.cancel();
    _batchUpdateTimer = Timer(const Duration(milliseconds: 100), _performBatchUpdate);
  }
  
  /// 4. ì‹¤ì œ UI ì—…ë°ì´íŠ¸ ìˆ˜í–‰: í˜„ì¬ ì„ê³„ê°’ì— ë§ëŠ” ìµœì¢… ë¦¬ìŠ¤íŠ¸ë¥¼ ìŠ¤íŠ¸ë¦¼ì— ì „ë‹¬
  void _performBatchUpdate() {
    final list = _filterCache[
      TradeFilter.values.firstWhere(
        (f) => f.value == _currentThreshold,
        orElse: () => TradeFilter.usdt50k,
      )
    ] ?? [];
    
    _filteredTradesController.add(List.from(list));
  }

  @override
  Stream<List<Trade>> watchFilteredTrades(List<String> markets) {
    _initialize(markets);
    return _filteredTradesController.stream;
  }

  @override
  Stream<Trade> watchAggregatedTrades(List<String> markets) {
    _initialize(markets);
    return _aggregator.stream;
  }
  
  @override
  void updateThreshold(double threshold) {
    if (_currentThreshold == threshold) return;
    _currentThreshold = threshold;
    log.d('[Repository] Threshold updated to: $threshold');
    // ì„ê³„ê°’ ë³€ê²½ ì‹œ ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸ ìˆ˜í–‰
    _performBatchUpdate();
  }

  @override
  void dispose() {
    _rawTradeSub?.cancel();
    _aggregatedTradeSub?.cancel();
    _batchUpdateTimer?.cancel();
    _aggregator.dispose();
    _filteredTradesController.close();
    _isInitialized = false;
    log.i('[Repository] Disposed.');
  }
}\n\n// ====== lib/data/processors/trade_aggregator.dart ======\n
// lib/data/processors/trade_aggregator.dart

import 'dart:async';
import '../../domain/entities/trade.dart';
import '../../core/utils/logger.dart';

/// ì‹¤ì‹œê°„ ê±°ë˜ë¥¼ ë³‘í•©í•˜ì—¬ UI ì—…ë°ì´íŠ¸ ë¹ˆë„ë¥¼ ì¡°ì ˆí•˜ëŠ” ê±°ë˜ ì§‘ê³„ê¸°
class TradeAggregator {
  final Map<String, Trade> _pendingTrades = {};
  final _controller = StreamController<Trade>.broadcast();
  Timer? _flushTimer;

  /// ì§‘ê³„ ì²˜ë¦¬ëœ ê±°ë˜ ë°ì´í„° ìŠ¤íŠ¸ë¦¼
  Stream<Trade> get stream => _controller.stream;

  TradeAggregator() {
    // 1ì´ˆë§ˆë‹¤ ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ë“¤ì„ ë°©ì¶œ(flush)í•˜ì—¬ í•­ìƒ ìµœì‹  ë°ì´í„°ê°€ ë°˜ì˜ë˜ë„ë¡ í•¨
    _flushTimer = Timer.periodic(const Duration(seconds: 1), (_) => _flush());
  }

  /// ìƒˆë¡œìš´ ê±°ë˜ë¥¼ ë°›ì•„ ì§‘ê³„ ë¡œì§ ì²˜ë¦¬
  void process(Trade trade) {
    final existing = _pendingTrades[trade.market];

    // í•´ë‹¹ ë§ˆì¼“ì— ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ê°€ ì—†ë‹¤ë©´ ìƒˆë¡œ ì¶”ê°€
    if (existing == null) {
      _pendingTrades[trade.market] = trade;
      return;
    }

    // ì‹œê°„ ì°½(500ms) ë‚´ì˜ ê±°ë˜ë¼ë©´ ë³‘í•©
    if (trade.timestamp - existing.timestamp <= 500) {
      final newQuantity = existing.quantity + trade.quantity;
      _pendingTrades[trade.market] = Trade(
        market: trade.market,
        price: trade.price, // ê°€ê²©ì€ ìµœì‹  ê±°ë˜ì˜ ê²ƒì„ ë”°ë¦„
        quantity: newQuantity,
        totalValue: existing.totalValue + trade.totalValue,
        isBuy: trade.isBuy, // ë°©í–¥ë„ ìµœì‹  ê±°ë˜ì˜ ê²ƒì„ ë”°ë¦„
        timestamp: trade.timestamp,
        tradeId: trade.tradeId,
      );
    } else {
      // ì‹œê°„ ì°½ì„ ë²—ì–´ë‚˜ë©´, ê¸°ì¡´ ê±°ë˜ëŠ” ë°©ì¶œí•˜ê³  ìƒˆ ê±°ë˜ë¥¼ ëŒ€ê¸°
      _controller.add(existing);
      _pendingTrades[trade.market] = trade;
    }
  }

  /// ëŒ€ê¸° ì¤‘ì¸ ëª¨ë“  ê±°ë˜ë¥¼ ë°©ì¶œ
  void _flush() {
    if (_pendingTrades.isEmpty) return;
    _pendingTrades.values.forEach(_controller.add);
    _pendingTrades.clear();
  }

  void dispose() {
    _flushTimer?.cancel();
    _controller.close();
    log.i('[Aggregator] Disposed.');
  }
}\n\n// ====== lib/domain/repositories/trade_repository.dart ======\n
// lib/domain/repositories/trade_repository.dart

import '../entities/trade.dart';

abstract class TradeRepository {
  /// í•„í„°ë§ëœ ì‹¤ì‹œê°„ ì²´ê²° ë¦¬ìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼
  Stream<List<Trade>> watchFilteredTrades(List<String> markets);

  /// ì§‘ê³„ ì²˜ë¦¬ëœ ë‹¨ì¼ ì²´ê²° ìŠ¤íŠ¸ë¦¼
  Stream<Trade> watchAggregatedTrades(List<String> markets);

  /// ì‹¤ì‹œê°„ìœ¼ë¡œ í•„í„° ì„ê³„ê°’ ì—…ë°ì´íŠ¸
  void updateThreshold(double threshold);
  
  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  void dispose();
}\n\n// ====== lib/domain/usecases/trade_usecase.dart ======\n
// lib/domain/usecases/trade_usecase.dart

import '../entities/trade.dart';
import '../repositories/trade_repository.dart';

class TradeUsecase {
  final TradeRepository _repository;

  TradeUsecase(this._repository);

  Stream<List<Trade>> watchFilteredTrades(List<String> markets) {
    return _repository.watchFilteredTrades(markets);
  }

  Stream<Trade> watchAggregatedTrades(List<String> markets) {
    return _repository.watchAggregatedTrades(markets);
  }
  
  void updateThreshold(double threshold) {
    _repository.updateThreshold(threshold);
  }
  
  void dispose() {
    _repository.dispose();
  }
}\n\n// ====== lib/domain/entities/trade.dart ======\n
import 'package:equatable/equatable.dart';

class Trade extends Equatable {
  /// ì‹¬ë³¼ (e.g., BTCUSDT)
  final String market;

  /// ì²´ê²° ê°€ê²©
  final double price;

  /// ì²´ê²° ìˆ˜ëŸ‰ (API í•„ë“œëª… 'q'ì— ë§ì¶° volume -> quantityë¡œ ë³€ê²½)
  final double quantity;

  /// ì´ ì²´ê²°ì•¡ (price * quantity)
  final double totalValue; // total -> totalValueë¡œ ëª…í™•í™”

  /// ë§¤ìˆ˜ ì²´ê²° ì—¬ë¶€
  final bool isBuy;

  /// ì²´ê²° ì‹œê° (milliseconds from epoch)
  final int timestamp; // timestampMs -> timestampë¡œ ê°„ì†Œí™”

  /// ê±°ë˜ ê³ ìœ  ID (Aggregate trade ID)
  final String tradeId; // id -> tradeIdë¡œ ëª…í™•í™”

  const Trade({
    required this.market,
    required this.price,
    required this.quantity,
    required this.totalValue,
    required this.isBuy,
    required this.timestamp,
    required this.tradeId,
  });

  /// UIì—ì„œ ì‚¬ìš©í•˜ê¸° í¸í•œ DateTime ê°ì²´
  DateTime get dateTime => DateTime.fromMillisecondsSinceEpoch(timestamp);

  /// ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ `aggTrade` ìŠ¤íŠ¸ë¦¼ ë°ì´í„°ë¡œë¶€í„° Trade ê°ì²´ ìƒì„±
  factory Trade.fromBinance(Map<String, dynamic> json) {
    final price = double.parse(json['p'].toString());
    final quantity = double.parse(json['q'].toString());

    return Trade(
      market: json['s'] as String,
      price: price,
      quantity: quantity,
      totalValue: price * quantity,
      isBuy: !(json['m'] as bool), // isBuyerMaker(`m`)ê°€ falseì¼ ë•Œê°€ ë§¤ìˆ˜
      timestamp: json['T'] as int,
      tradeId: json['a'].toString(),
    );
  }

  /// Equatableì„ ìœ„í•œ ì„¤ì •. tradeIdë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê°ì²´ì˜ ë™ë“±ì„±ì„ ë¹„êµí•©ë‹ˆë‹¤.
  @override
  List<Object> get props => [tradeId];
}\n\n// ====== lib/presentation/controllers/trade_controller.dart ======\n
// lib/presentation/controllers/trade_controller.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/common/time_frame_types.dart';
import '../../core/di/core_provider.dart';
import '../../domain/entities/trade.dart';

// State í´ë˜ìŠ¤ëŠ” ë³€ê²½ ì—†ìŒ
class TradeControllerState {
  final bool isLoading;
  final String? errorMessage;
  final List<Trade> trades;
  final TradeFilter currentFilter;
  final int selectedFilterIndex;

  TradeControllerState({
    this.isLoading = true,
    this.errorMessage,
    this.trades = const [],
    required this.currentFilter,
    required this.selectedFilterIndex,
  });

  TradeControllerState copyWith({
    bool? isLoading,
    String? errorMessage,
    List<Trade>? trades,
    TradeFilter? currentFilter,
    int? selectedFilterIndex,
  }) {
    return TradeControllerState(
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage,
      trades: trades ?? this.trades,
      currentFilter: currentFilter ?? this.currentFilter,
      selectedFilterIndex: selectedFilterIndex ?? this.selectedFilterIndex,
    );
  }
}

// Controller í´ë˜ìŠ¤ ìˆ˜ì •
class TradeController extends StateNotifier<TradeControllerState> {
  final Ref _ref;
  // âœ… StreamSubscription -> ProviderSubscription ìœ¼ë¡œ ë³€ê²½
  ProviderSubscription? _filteredTradesSub;
  ProviderSubscription? _rawStreamSub;

  TradeController(this._ref)
      : super(TradeControllerState(
          currentFilter: _ref.read(tradeFilterProvider),
          selectedFilterIndex: TradeFilter.values.indexOf(_ref.read(tradeFilterProvider)),
        )) {
    _listenToTrades();
  }

  void _listenToTrades() {
    // raw streamì˜ ë¡œë”©/ì—ëŸ¬ ìƒíƒœë¥¼ ê°ì§€
    _rawStreamSub = _ref.listen<AsyncValue<Trade>>(
      rawTradeStreamProvider,
      (previous, next) {
        if (state.isLoading && !next.isLoading) {
          state = state.copyWith(isLoading: false);
        }
        if (next.hasError) {
          state = state.copyWith(errorMessage: next.error.toString(), isLoading: false);
        }
      },
      fireImmediately: true,
    );

    // í•„í„°ë§ëœ ìµœì¢… ëª©ë¡ì„ êµ¬ë…í•˜ì—¬ UIì— í‘œì‹œí•  tradesë¥¼ ì—…ë°ì´íŠ¸
    _filteredTradesSub = _ref.listen<List<Trade>>(
      filteredTradesProvider, 
      (previous, next) {
        state = state.copyWith(trades: next, isLoading: false);
      },
      fireImmediately: true,
    );
  }

  void setThreshold(TradeFilter newFilter) {
    _ref.read(tradeFilterProvider.notifier).state = newFilter;
    state = state.copyWith(
      currentFilter: newFilter,
      selectedFilterIndex: TradeFilter.values.indexOf(newFilter),
    );
  }

  List<TradeFilter> get availableFilters => TradeFilter.values;
  String get currentFilterDisplayName => state.currentFilter.displayName;

  @override
  void dispose() {
    // âœ… êµ¬ë… ì·¨ì†Œ ë°©ì‹ì„ .close()ë¡œ ë³€ê²½
    _filteredTradesSub?.close();
    _rawStreamSub?.close();
    super.dispose();
  }
}

// Provider ì •ì˜ëŠ” ë³€ê²½ ì—†ìŒ
final tradeControllerProvider =
    StateNotifierProvider.autoDispose<TradeController, TradeControllerState>((ref) {
  return TradeController(ref);
});\n\n// ====== lib/presentation/pages/trade_page.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// âœ… ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” import ì œê±°
// import '../../core/common/time_frame_types.dart';
// import '../../core/config/app_config.dart';
// import '../../core/di/core_provider.dart';

import '../controllers/trade_controller.dart';
import '../widgets/trade_tile.dart';

class TradePage extends ConsumerWidget {
  const TradePage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(tradeControllerProvider);
    final controller = ref.read(tradeControllerProvider.notifier);

    final slider = _buildFilterSlider(context, controller, state);
    final tradeList = _buildTradeList(context, state);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Binance Futures - Live Trades'),
        elevation: 1,
      ),
      body: Column(
        children: [
          slider,
          const Divider(height: 1),
          Expanded(child: tradeList),
        ],
      ),
    );
  }

  Widget _buildFilterSlider(
    BuildContext context,
    TradeController controller,
    TradeControllerState state,
  ) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 8, 16, 0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Minimum Value: ${state.currentFilter.displayName}',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
          ),
          Slider(
            value: state.selectedFilterIndex.toDouble(),
            min: 0,
            max: (controller.availableFilters.length - 1).toDouble(),
            divisions: controller.availableFilters.length - 1,
            label: state.currentFilter.displayName,
            onChanged: (value) {
              final newFilter = controller.availableFilters[value.round()];
              controller.setThreshold(newFilter);
            },
            onChangeEnd: (_) {
              HapticFeedback.mediumImpact();
            },
          ),
        ],
      ),
    );
  }

  Widget _buildTradeList(BuildContext context, TradeControllerState state) {
    if (state.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }
    if (state.errorMessage != null) {
      return Center(child: Text('Error: ${state.errorMessage}'));
    }
    if (state.trades.isEmpty) {
      return Center(
        child: Text(
          'No trades captured.\n(Threshold: ${state.currentFilter.displayName})',
          textAlign: TextAlign.center,
          style: TextStyle(color: Theme.of(context).hintColor),
        ),
      );
    }
    
    return RawScrollbar(
      thumbVisibility: true,
      trackVisibility: true,
      interactive: true,
      thickness: 8,
      radius: const Radius.circular(4),
      child: ListView.separated(
        padding: const EdgeInsets.symmetric(vertical: 8.0),
        itemCount: state.trades.length,
        itemBuilder: (context, index) {
          return TradeTile(trade: state.trades[index]);
        },
        separatorBuilder: (context, index) => Divider(
          height: 1,
          thickness: 1,
          // âœ… .withOpacity(0.1) -> .withAlpha(25)ë¡œ ìˆ˜ì • (0.1 * 255 = 25.5)
          color: Theme.of(context).dividerColor.withAlpha(25),
          indent: 16,
          endIndent: 16,
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/widgets/trade_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../domain/entities/trade.dart';

class TradeTile extends ConsumerWidget {
  final Trade trade;

  const TradeTile({Key? key, required this.trade}) : super(key: key);

  static final _timeFormat = DateFormat('HH:mm:ss');
  static final _quantityFormat = NumberFormat('#,##0.###');
  static final _totalFormat = NumberFormat('#,##0');

  String _formatPrice(double price) {
    if (price < 0.01) return price.toStringAsFixed(6);
    if (price < 1) return price.toStringAsFixed(4);
    if (price < 100) return price.toStringAsFixed(2);
    return price.toStringAsFixed(1);
  }

  String _getDisplayName(WidgetRef ref) {
    return trade.market.replaceAll('USDT', '');
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final bool isBuy = trade.isBuy;
    final Color sideColor = isBuy ? Colors.green.shade400 : Colors.red.shade400;

    return Card(
      elevation: 1.5,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 5),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Row(
          children: [
            // âœ… ì‹œê°„ (Flex: 13)
            Expanded(
              flex: 13,
              child: Text(
                _timeFormat.format(trade.dateTime),
                style: theme.textTheme.bodySmall?.copyWith(color: theme.hintColor),
              ),
            ),

            // âœ… í‹°ì»¤ (Flex: 17)
            Expanded(
              flex: 17,
              child: Text(
                _getDisplayName(ref),
                style: theme.textTheme.titleSmall?.copyWith(fontWeight: FontWeight.bold),
                overflow: TextOverflow.ellipsis,
              ),
            ),

            // âœ… ê°€ê²© / ìˆ˜ëŸ‰ (Flex: 20)
            Expanded(
              flex: 20,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    // âœ… ê°€ê²© ì•ì— '$' ê¸°í˜¸ ì¶”ê°€
                    '\$${_formatPrice(trade.price)}',
                    style: theme.textTheme.bodyMedium?.copyWith(fontFamily: 'monospace'),
                  ),
                  const SizedBox(height: 2),
                  Text(
                    _quantityFormat.format(trade.quantity),
                    style: theme.textTheme.bodySmall?.copyWith(color: theme.hintColor),
                  ),
                ],
              ),
            ),

            // âœ… ì´ì•¡ (Flex: 20)
            Expanded(
              flex: 20,
              child: Align(
                alignment: Alignment.centerRight,
                child: Text(
                  // âœ… ì´ì•¡ ì•ì— '$' ê¸°í˜¸ ì¶”ê°€
                  '\$${_totalFormat.format(trade.totalValue)}',
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                    fontFamily: 'monospace',
                    color: sideColor,
                  ),
                ),
              ),
            ),

            // ë°©í–¥ ì•„ì´ì½˜
            Padding(
              padding: const EdgeInsets.only(left: 10.0),
              child: Icon(
                isBuy ? Icons.arrow_upward : Icons.arrow_downward,
                color: sideColor,
                size: 18,
              ),
            ),
          ],
        ),
      ),
    );
  }
}