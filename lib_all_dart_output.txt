\n\n// ====== lib/core/di/trade_provider.dart ======\n
\n\n// ====== lib/core/di/websocket_provider.dart ======\n
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../network/websocket/base_ws_client.dart';
import '../network/websocket/trade_ws_client.dart';
import '../utils/logger.dart';
import 'core_provider.dart';

@immutable
class WebSocketState {
  final WsStatus status;
  final List<String> subscribedSymbols;
  final DateTime? lastConnectedAt;

  const WebSocketState({
    this.status = WsStatus.disconnected,
    this.subscribedSymbols = const [],
    this.lastConnectedAt,
  });

  WebSocketState copyWith({
    WsStatus? status,
    List<String>? subscribedSymbols,
    DateTime? lastConnectedAt,
  }) {
    return WebSocketState(
      status: status ?? this.status,
      subscribedSymbols: subscribedSymbols ?? this.subscribedSymbols,
      lastConnectedAt: lastConnectedAt ?? this.lastConnectedAt,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
  
    return other is WebSocketState &&
      other.status == status &&
      listEquals(other.subscribedSymbols, subscribedSymbols) &&
      other.lastConnectedAt == lastConnectedAt;
  }

  @override
  int get hashCode => status.hashCode ^ subscribedSymbols.hashCode ^ lastConnectedAt.hashCode;
}

final wsClientProvider = Provider.autoDispose<TradeWsClient>((ref) {
  final client = TradeWsClient();
  ref.onDispose(client.dispose);
  return client;
});

final webSocketManagerProvider =
    StateNotifierProvider.autoDispose<WebSocketManager, WebSocketState>(
  (ref) => WebSocketManager(ref),
);

class WebSocketManager extends StateNotifier<WebSocketState> {
  final Ref _ref;

  WebSocketManager(this._ref) : super(const WebSocketState()) {
    // âœ… ì´ì œ ì´ ì½”ë“œëŠ” ì •ìƒì ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.
    _ref.read(wsClientProvider).onStatusChange = (newStatus) {
      if (state.status != newStatus) {
        state = state.copyWith(
          status: newStatus,
          lastConnectedAt: newStatus == WsStatus.connected ? DateTime.now() : state.lastConnectedAt,
        );
      }
    };
  }

  Future<void> connect() async {
    if (state.status == WsStatus.connecting || state.status == WsStatus.connected) {
      log.w('[WebSocketManager] Already connected or connecting.');
      return;
    }

    state = state.copyWith(status: WsStatus.connecting);

    try {
      final markets = await _ref.read(marketsProvider.future);
      if (markets.isEmpty) {
        throw Exception('Cannot connect without markets.');
      }
      
      _ref.read(wsClientProvider).connect(markets);
      
      state = state.copyWith(subscribedSymbols: markets);
      log.i('[WebSocketManager] Connect command issued with ${markets.length} markets.');

    } catch (e, st) {
      log.e('[WebSocketManager] Connection failed.', e, st);
      state = state.copyWith(status: WsStatus.disconnected);
    }
  }

  void disconnect() {
    log.i('[WebSocketManager] Disconnect command issued.');
    _ref.read(wsClientProvider).dispose();
    state = const WebSocketState(); 
  }
}\n\n// ====== lib/core/di/volume_provider.dart ======\n
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/repositories/volume_repository_impl.dart';
import '../../domain/entities/volume.dart'; // âœ… ëˆ„ë½ëœ import ì¶”ê°€
import '../../domain/repositories/volume_repository.dart';
import '../../domain/usecases/volume_usecase.dart';
import 'core_provider.dart';

// ===================================================================
// 1. Data & Domain Layer Providers
// ===================================================================

final volumeRepositoryProvider = Provider<VolumeRepository>((ref) {
  final remoteDS = ref.watch(tradeRemoteDSProvider); 
  final repo = VolumeRepositoryImpl(remoteDS);
  ref.onDispose(() => repo.dispose());
  return repo;
});

final volumeUsecaseProvider = Provider((ref) {
  final usecase = VolumeUsecase(ref.watch(volumeRepositoryProvider));
  return usecase;
});


// ===================================================================
// 2. UI State & Final Data Provider
// ===================================================================

final volumeTimeFrameProvider = StateProvider<TimeFrame>((ref) => TimeFrame.min5);

final volumeDataProvider = StreamProvider.autoDispose<List<Volume>>((ref) {
  final timeFrame = ref.watch(volumeTimeFrameProvider);
  final marketsAsync = ref.watch(marketsProvider);
  final usecase = ref.read(volumeUsecaseProvider);

  return marketsAsync.when(
    data: (markets) {
      if (markets.isEmpty) return const Stream.empty();
      return usecase.watchVolumeRanking(timeFrame, markets);
    },
    loading: () => const Stream.empty(),
    error: (e, st) => Stream.error(e, st),
  );
});\n\n// ====== lib/core/di/core_provider.dart ======\n
import 'dart:async';
import 'dart:collection';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../data/datasources/trade_remote_ds.dart';
import '../../data/repositories/trade_repository_impl.dart';
import '../../domain/entities/trade.dart';
import '../../domain/repositories/trade_repository.dart';
import '../common/time_frame_types.dart'; // TradeFilter enumì´ ì •ì˜ëœ ê²½ë¡œ
import '../config/app_config.dart';
import '../network/api_client.dart';
import '../utils/logger.dart';
import 'websocket_provider.dart';

// ===================================================================
// 0. Configuration Constants
// ===================================================================

class TradeConfig {
  static const int maxSeenIdsCacheSize = 10000;
  static const int maxTradesPerFilter = 100;
}

// ===================================================================
// 1. Foundational Service & Data Layer Providers
// ===================================================================

/// API í´ë¼ì´ì–¸íŠ¸ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
final apiClientProvider = Provider((_) => ApiClient());

/// ì›ê²© ë°ì´í„° ì†ŒìŠ¤(WebSocket)ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
final tradeRemoteDSProvider = Provider((ref) {
  return TradeRemoteDataSource(ref.watch(wsClientProvider));
});

/// ê±°ë˜ ë°ì´í„° Repositoryë¥¼ ì œê³µí•©ë‹ˆë‹¤.
final tradeRepositoryProvider = Provider<TradeRepository>((ref) {
  final repo = TradeRepositoryImpl(ref.watch(tradeRemoteDSProvider));
  ref.onDispose(() => repo.dispose());
  return repo;
});

// ===================================================================
// 2. Market Info & Raw Data Stream Providers
// ===================================================================

/// ë°”ì´ë‚¸ìŠ¤ APIì—ì„œ ê±°ë˜ëŸ‰ ìƒìœ„ ì¢…ëª© ëª©ë¡ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
/// âœ… [ìˆ˜ì •] .autoDisposeë¥¼ ì œê±°í•˜ì—¬, ì•± ì„¸ì…˜ ë™ì•ˆ ì¢…ëª© ë¦¬ìŠ¤íŠ¸ë¥¼ ë‹¨ í•œ ë²ˆë§Œ ê°€ì ¸ì˜¤ë„ë¡ ìµœì í™”í•©ë‹ˆë‹¤.
final marketsProvider = FutureProvider<List<String>>((ref) async {
  log.d('[marketsProvider] Fetching top volume markets from Binance...');
  final client = ref.watch(apiClientProvider);
  try {
    final List<dynamic> tickers = await client.get('/fapi/v1/ticker/24hr');
    
    tickers.removeWhere((t) => !(t['symbol'] as String).endsWith('USDT'));
    tickers.sort((a, b) {
      final volumeA = double.tryParse(a['quoteVolume'].toString()) ?? 0;
      final volumeB = double.tryParse(b['quoteVolume'].toString()) ?? 0;
      return volumeB.compareTo(volumeA);
    });

    final markets = tickers.map((t) => t['symbol'] as String)
                           .take(AppConfig.wsMaxSubscriptions)
                           .toList();
                           
    log.i('[marketsProvider] Fetched ${markets.length} markets, sorted by volume.');
    return markets;
  } catch (e, st) {
    log.e('[marketsProvider] Failed to fetch Binance markets', e, st);
    throw Exception('Failed to fetch markets: $e');
  }
});

/// WebSocket í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ë“¤ì–´ì˜¤ëŠ” ê°€ê³µë˜ì§€ ì•Šì€ 'ê±°ë˜' ë°ì´í„° ìŠ¤íŠ¸ë¦¼ì„ ì œê³µí•©ë‹ˆë‹¤.
final rawTradeStreamProvider = StreamProvider.autoDispose<Trade>((ref) {
  final client = ref.watch(wsClientProvider);
  return client.stream;
});


// ===================================================================
// 3. Filtered Data & UI State Providers
// ===================================================================

/// UIì—ì„œ ì‚¬ìš©ìê°€ ì„ íƒí•œ ê±°ë˜ëŒ€ê¸ˆ í•„í„° ê°’ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
final tradeFilterProvider = StateProvider<TradeFilter>((ref) => TradeFilter.usdt50k);

/// ìµœì¢…ì ìœ¼ë¡œ í•„í„°ë§ëœ ê±°ë˜ ëª©ë¡ì„ UIì— ì œê³µí•©ë‹ˆë‹¤.
final filteredTradesProvider = Provider.autoDispose<List<Trade>>((ref) {
  final filter = ref.watch(tradeFilterProvider);
  final filteredList = ref.watch(tradeCacheProvider.select((cache) => cache[filter]));
  return filteredList ?? const [];
});

/// ê±°ë˜ ë°ì´í„°ë¥¼ í•„í„°ë³„ë¡œ ìºì‹±í•˜ê³  ê´€ë¦¬í•˜ëŠ” í•µì‹¬ ë¡œì§ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.
final tradeCacheProvider = StateNotifierProvider.autoDispose<
    TradeCacheNotifier, Map<TradeFilter, List<Trade>>>((ref) {
  return TradeCacheNotifier(ref);
});

class TradeCacheNotifier extends StateNotifier<Map<TradeFilter, List<Trade>>> {
  final Ref _ref;
  final Queue<String> _seenIds = Queue();
  ProviderSubscription? _sub;

  TradeCacheNotifier(this._ref)
      : super({for (var filter in TradeFilter.values) filter: const []}) {
    _sub = _ref.listen<AsyncValue<Trade>>(
      rawTradeStreamProvider,
      (_, next) => next.whenData(_processTrade),
    );
  }
  
  void _processTrade(Trade trade) {
    if (_seenIds.contains(trade.tradeId)) return;

    _seenIds.addLast(trade.tradeId);
    if (_seenIds.length > TradeConfig.maxSeenIdsCacheSize) {
      _seenIds.removeFirst();
    }
    
    final newState = Map.of(state); 
    bool needsUpdate = false;

    for (final filter in TradeFilter.values) {
      if (trade.totalValue >= filter.value) {
        final oldList = newState[filter]!;
        final newList = [trade, ...oldList];
        
        newState[filter] = newList.length > TradeConfig.maxTradesPerFilter 
            ? newList.sublist(0, TradeConfig.maxTradesPerFilter) 
            : newList;
            
        needsUpdate = true;
      }
    }
    
    if (needsUpdate) {
      state = newState;
    }
  }
  
  @override
  void dispose() {
    _sub?.close();
    super.dispose();
  }
}\n\n// ====== lib/core/config/app_config.dart ======\n
import 'package:flutter_dotenv/flutter_dotenv.dart';
import '../utils/logger.dart';

/// ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼(USDâ“ˆ-M) ì „ìš© ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì •
/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ê³µì‹ WebSocket ë°±ì„œ (2025-01-28) 100% ì¤€ìˆ˜
class AppConfig {
  AppConfig._(); // ì¸ìŠ¤í„´ìŠ¤í™” ë°©ì§€

  // ===================================================================
  // 1. í™˜ê²½ ë³€ìˆ˜ ë° í† ê¸€
  // ===================================================================
  
  /// í…ŒìŠ¤íŠ¸ë„· ì‚¬ìš© ì—¬ë¶€. `dart --define=BINANCE_TESTNET=true`ë¡œ ì»´íŒŒì¼ ì‹œ true.
  static const bool useTestnet = bool.fromEnvironment('BINANCE_TESTNET');
  
  static String apiKey = '';
  static String apiSecret = '';
  
  static Future<void> initialize() async {
    try {
      await dotenv.load();
      apiKey = dotenv.env['BINANCE_API_KEY'] ?? '';
      apiSecret = dotenv.env['BINANCE_API_SECRET'] ?? '';
      log.i('[AppConfig] Initialized. Testnet mode: $useTestnet');
    } catch (e) {
      log.w('[AppConfig] .env not found. Using empty credentials.');
    }
  }

  // ===================================================================
  // 2. ë„¤íŠ¸ì›Œí¬ ì—”ë“œí¬ì¸íŠ¸ (í…ŒìŠ¤íŠ¸ë„·/ë©”ì¸ë„· ìë™ ì „í™˜)
  // ===================================================================
  
  static String get restBaseUrl =>
      useTestnet ? _testnetRestUrl : _mainnetRestUrl;
  static String get streamUrl =>
      useTestnet ? _testnetStreamUrl : _mainnetStreamUrl;

  // ë°”ì´ë‚¸ìŠ¤ ê³µì‹ ì—”ë“œí¬ì¸íŠ¸
  static const String _mainnetRestUrl = 'https://fapi.binance.com';
  static const String _testnetRestUrl = 'https://testnet.binancefuture.com';
  static const String _mainnetStreamUrl = 'wss://fstream.binance.com/stream';
  static const String _testnetStreamUrl = 'wss://stream.binancefuture.com/stream';

  // ì¶”ê°€ WebSocket ì—”ë“œí¬ì¸íŠ¸ ì˜µì…˜
  static const String mainStreamBase = 'wss://stream.binance.com:9443';
  static const String mainStreamAlt = 'wss://stream.binance.com:443';
  static const String dataOnlyStream = 'wss://data-stream.binance.vision';

  // ===================================================================
  // 3. REST API ì„¤ì •
  // ===================================================================
  
  static const Duration restTimeout = Duration(seconds: 30);

  // ===================================================================
  // 4. ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ê³µì‹ WebSocket ì œí•œì‚¬í•­ (ë°±ì„œ ê¸°ì¤€)
  // ===================================================================
  
  /// ğŸš¨ í•µì‹¬: í´ë¼ì´ì–¸íŠ¸â†’ì„œë²„ ë©”ì‹œì§€ ì œí•œ (PING, PONG, JSON ì»¨íŠ¸ë¡¤)
  /// "WebSocket connections have a limit of 5 incoming messages per second"
  static const int wsMaxOutgoingMsgPerSec = 5;
  
  /// ë‹¨ì¼ ì—°ê²°ë‹¹ ìµœëŒ€ ìŠ¤íŠ¸ë¦¼ êµ¬ë… ê°œìˆ˜
  /// "A single connection can listen to a maximum of 1024 streams"
  static const int wsMaxStreams = 1024;
  
  /// IPë‹¹ ì—°ê²° ì œí•œ
  /// "There is a limit of 300 connections per attempt every 5 minutes per IP"
  static const int wsMaxConnectionsPer5Min = 300;
  
  /// 24ì‹œê°„ ì„¸ì…˜ ì œí•œ
  /// "A single connection to stream.binance.com is only valid for 24 hours"
  static const Duration wsMaxSessionDuration = Duration(hours: 24);

  // ===================================================================
  // 5. ğŸ¯ Ping/Pong ì •ì±… (ë°±ì„œ ê¸°ì¤€)
  // ===================================================================
  
  /// ì„œë²„ Ping ê°„ê²©
  /// "The WebSocket server will send a ping frame every 20 seconds"
  static const Duration wsServerPingInterval = Duration(seconds: 20);
  
  /// Pong ì‘ë‹µ íƒ€ì„ì•„ì›ƒ
  /// "If the WebSocket server does not receive a pong frame back from the connection within a minute"
  static const Duration wsPongTimeout = Duration(seconds: 60);
  
  /// Unsolicited Pong ê°„ê²©
  /// "Unsolicited pong frames are allowed... It is recommended that the payload for these pong frames are empty"
  static const Duration wsUnsolicitedPongInterval = Duration(seconds: 30);

  // ===================================================================
  // 6. ğŸ›¡ï¸ ì•ˆì „ ì„¤ì • (ë°±ì„œ ê¸°ì¤€ + ì—¬ìœ )
  // ===================================================================
  
  /// ì‹¤ì œ êµ¬ë…í•  ì‹¬ë³¼ ìˆ˜ (1024ë³´ë‹¤ ì ê²Œ - ì•ˆì „ ë²„í¼)
  static const int wsMaxSubscriptions = 200;
  
  /// 24ì‹œê°„ ì „ ë¯¸ë¦¬ ì¬ì—°ê²° (ì„¸ì…˜ ë§Œë£Œ ë°©ì§€)
  static const Duration wsSessionRefresh = Duration(hours: 23);
  
  /// ì„œë²„â†’í´ë¼ì´ì–¸íŠ¸ ë©”ì‹œì§€ëŠ” ë¬´ì œí•œì´ì§€ë§Œ ì•± ì•ˆì •ì„±ì„ ìœ„í•´ ì„¤ì •
  static const int wsMaxInMsgPerSec = 2000;
  
  /// ì»¨íŠ¸ë¡¤ ë©”ì‹œì§€ ì „ì†¡ ê°„ê²© (5ê°œ/ì´ˆ ì œí•œ ì¤€ìˆ˜)
  static const Duration wsControlMsgInterval = Duration(milliseconds: 220); // 200ms + ë²„í¼
  
  /// ì¬ì—°ê²° ì‹œë„ ì œí•œ (IP Ban ë°©ì§€)
  static const int wsMaxReconnectAttempts = 10;
  static const Duration wsReconnectCooldown = Duration(minutes: 5);

  // ===================================================================
  // 7. ğŸ“Š ìŠ¤íŠ¸ë¦¼ë³„ ì—…ë°ì´íŠ¸ ì†ë„ (ë°±ì„œ ê¸°ì¤€)
  // ===================================================================
  
  static const Map<String, String> streamUpdateSpeeds = {
    'aggTrade': 'Real-time',
    'trade': 'Real-time',
    'bookTicker': 'Real-time',
    'miniTicker': '1000ms',
    'ticker': '1000ms',
    'depth': '1000ms',
    'depth@100ms': '100ms',
    'kline_1s': '1000ms',
    'kline_others': '2000ms',
  };

  // ===================================================================
  // 8. ğŸ›ï¸ ì§€ì›ë˜ëŠ” WebSocket ì»¨íŠ¸ë¡¤ ë©”ì„œë“œ
  // ===================================================================
  
  static const List<String> wsSupportedMethods = [
    'SUBSCRIBE',
    'UNSUBSCRIBE',
    'LIST_SUBSCRIPTIONS',
    'SET_PROPERTY',
    'GET_PROPERTY',
  ];

  // ===================================================================
  // 9. âš ï¸ ë°”ì´ë‚¸ìŠ¤ WebSocket ì—ëŸ¬ ì½”ë“œ
  // ===================================================================
  
  static const Map<int, String> wsErrorCodes = {
    0: 'Unknown property',
    1: 'Invalid value type: expected Boolean',
    2: 'Invalid request format',
    3: 'Invalid JSON syntax',
  };

  // ===================================================================
  // 10. ğŸ”§ ê³ ê¸‰ ì„¤ì •
  // ===================================================================
  
  /// ë§ˆì´í¬ë¡œì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„ ì‚¬ìš© ì—¬ë¶€
  static const bool useMicrosecondTimestamps = false;
  
  /// Combined ìŠ¤íŠ¸ë¦¼ ì‚¬ìš© (ìš°ë¦¬ê°€ ì‚¬ìš©í•˜ëŠ” ë°©ì‹)
  static const bool useCombinedStreams = true;
  
  /// WebSocket ì—°ê²° ì•ˆì •ì„±ì„ ìœ„í•œ Keep-Alive
  static const Duration wsKeepAliveInterval = Duration(seconds: 45);
}\n\n// ====== lib/core/network/binance_auth_interceptor.dart ======\n
// lib/core/network/binance_auth_interceptor.dart

import 'dart:convert';
import 'package:crypto/crypto.dart';
import 'package:dio/dio.dart';
import '../config/app_config.dart';

/// ë°”ì´ë‚¸ìŠ¤ API ìš”ì²­ì— HMAC-SHA256 ì‹œê·¸ë‹ˆì²˜ë¥¼ ì¶”ê°€í•˜ëŠ” ì¸í„°ì…‰í„°
class BinanceAuthInterceptor extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    // API í‚¤/ì‹œí¬ë¦¿ì´ í•„ìš”í•œ private ì—”ë“œí¬ì¸íŠ¸ì—ë§Œ ì ìš©
    if (AppConfig.apiKey.isEmpty || AppConfig.apiSecret.isEmpty) {
      return handler.next(options);
    }
    
    // Public APIëŠ” ì‹œê·¸ë‹ˆì²˜ ë¶ˆí•„ìš”
    if (!options.path.contains('/v1/order') && !options.path.contains('/v1/account')) {
        options.headers['X-MBX-APIKEY'] = AppConfig.apiKey;
        return handler.next(options);
    }

    // íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    options.queryParameters['timestamp'] = timestamp;

    // ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜
    final query = Uri(queryParameters: options.queryParameters).query;

    // HMAC-SHA256 ì‹œê·¸ë‹ˆì²˜ ìƒì„±
    final key = utf8.encode(AppConfig.apiSecret);
    final bytes = utf8.encode(query);
    final hmac = Hmac(sha256, key);
    final digest = hmac.convert(bytes);
    
    // ì‹œê·¸ë‹ˆì²˜ë¥¼ ì¿¼ë¦¬ì— ì¶”ê°€
    options.queryParameters['signature'] = digest.toString();
    options.headers['X-MBX-APIKEY'] = AppConfig.apiKey;

    return handler.next(options);
  }
}\n\n// ====== lib/core/network/websocket/clients/kline_ws_client.dart ======\n
\n\n// ====== lib/core/network/websocket/clients/ticker_ws_client.dart ======\n
\n\n// ====== lib/core/network/websocket/clients/trade_ws_client.dart ======\n
\n\n// ====== lib/core/network/websocket/clients/orderbook_ws_client.dart ======\n
\n\n// ====== lib/core/network/websocket/trade_ws_client.dart ======\n
import 'dart:convert';
import 'dart:math';
import '../../config/app_config.dart';
import '../../../domain/entities/trade.dart';
import '../../utils/logger.dart';
import 'base_ws_client.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ aggTrade ìŠ¤íŠ¸ë¦¼ ì „ìš© í´ë¼ì´ì–¸íŠ¸ (ë°±ì„œ 100% ì¤€ìˆ˜)
class TradeWsClient extends BaseWsClient<Trade> {

  TradeWsClient({
    void Function(WsStatus status)? onStatusChange,
    bool enableVerboseLogging = false,
  }) : super(
          url: AppConfig.streamUrl,
          onStatusChange: onStatusChange,
          pongTimeout: AppConfig.wsPongTimeout,
          encodeSubscribe: (markets) => _encodeSubscribeMessage(markets),
          // âœ… [ìˆ˜ì •] ë‹¤ì‹œ static ë©”ì„œë“œë¥¼ ì „ë‹¬í•˜ì—¬ ì´ë‹ˆì…œë¼ì´ì € ì˜¤ë¥˜ í•´ê²°
          decode: (json) => _decodeTradeMessage(json, enableVerboseLogging),
        );

  // ===================================================================
  // ğŸ“¨ êµ¬ë… ë©”ì‹œì§€ ì¸ì½”ë”© (ë°”ì´ë‚¸ìŠ¤ ë°±ì„œ ì¤€ìˆ˜)
  // ===================================================================

  static String _encodeSubscribeMessage(List<String> markets) {
    if (markets.length > AppConfig.wsMaxStreams) {
      throw ArgumentError('Too many streams: ${markets.length}. '
          'Binance limit: ${AppConfig.wsMaxStreams} streams per connection.');
    }

    final params =
        markets.map((symbol) => '${symbol.toLowerCase()}@aggTrade').toList();
    
    // âœ… [ìˆ˜ì •] String IDë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½
    final messageId = _generateUniqueMessageId();

    final subscribeMessage = {
      'method': 'SUBSCRIBE',
      'params': params,
      'id': messageId,
    };

    final jsonMessage = jsonEncode(subscribeMessage);

    log.i('[TradeWS] ğŸ“¤ Subscribing to ${params.length} aggTrade streams');
    log.d('[TradeWS] Subscription message: $jsonMessage');

    return jsonMessage;
  }

  /// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ í˜¸í™˜ ê³ ìœ  ë©”ì‹œì§€ ID ìƒì„± (String ë°˜í™˜)
  static String _generateUniqueMessageId() {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    // ì¶©ëŒ ë°©ì§€ë¥¼ ìœ„í•œ ëœë¤ ìˆ«ì ì¶”ê°€
    final randomPart = Random().nextInt(99999).toString().padLeft(5, '0');
    return '$timestamp$randomPart';
  }

  // ===================================================================
  // ğŸ“¥ ë©”ì‹œì§€ ë””ì½”ë”© (ë°”ì´ë‚¸ìŠ¤ Combined Stream ì²˜ë¦¬)
  // ===================================================================

  static Trade? _decodeTradeMessage(
      Map<String, dynamic> json, bool verboseLogging) {
    if (json.isEmpty) {
      if (verboseLogging) log.w('[TradeWS] Empty message received');
      return null;
    }

    if (json.containsKey('result')) {
      if (json['result'] == null) {
        log.i('[TradeWS] âœ… Subscription confirmed: ${json['id']}');
      } else if (json['result'] is List) {
        final subscriptions = json['result'] as List;
        log.i('[TradeWS] ğŸ“‹ Active subscriptions: ${subscriptions.length}');
      }
      return null;
    }

    if (json.containsKey('stream') && json.containsKey('data')) {
      final streamName = json['stream'] as String?;
      final data = json['data'];

      if (streamName == null ||
          data == null ||
          !streamName.endsWith('@aggTrade')) {
        return null;
      }
      return _parseTradeData(data, streamName, verboseLogging);
    }

    if (json.containsKey('e') && json['e'] == 'aggTrade') {
      return _parseTradeData(json, 'direct', verboseLogging);
    }

    if (verboseLogging) {
      log.w('[TradeWS] Unknown message type: ${json.keys.join(', ')}');
    }
    return null;
  }

  /// ğŸ¯ ì‹¤ì œ ê±°ë˜ ë°ì´í„° íŒŒì‹±
  static Trade? _parseTradeData(
      dynamic data, String streamInfo, bool verboseLogging) {
    try {
      if (data is! Map<String, dynamic> || data['e'] != 'aggTrade') {
        return null;
      }

      final trade = Trade.fromBinance(data);

      // âœ… [ìˆ˜ì •] Trade ê°ì²´ ì†ì„±ì— ì˜ì¡´í•˜ì§€ ì•Šê³  ì›ë³¸ ë°ì´í„°ë¡œ ë¡œê·¸ ê¸°ë¡
      if (verboseLogging) {
        final symbol = data['s'] as String? ?? 'UNKNOWN';
        final price = data['p'] as String? ?? '0';
        final quantity = data['q'] as String? ?? '0';
        log.d('[TradeWS] ğŸ’° $symbol: $price Ã— $quantity (Stream: $streamInfo)');
      }

      return trade;
    } catch (e, st) {
      log.e('[TradeWS] Trade parsing failed (Stream: $streamInfo)', e, st);
      return null;
    }
  }

  // âŒ [ì œê±°] í†µê³„ ê´€ë ¨ ë¡œì§ì€ ì´ í´ë˜ìŠ¤ì˜ ì±…ì„ì„ ë²—ì–´ë‚˜ë¯€ë¡œ ëª¨ë‘ ì œê±°.
  // ì´ í´ë˜ìŠ¤ëŠ” ìˆœìˆ˜í•˜ê²Œ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ì„ ì œê³µí•˜ëŠ” ì—­í• ë§Œ ìˆ˜í–‰.
}\n\n// ====== lib/core/network/websocket/base_ws_client.dart ======\n
import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'package:web_socket_channel/web_socket_channel.dart';
import '../../config/app_config.dart';
import '../../utils/logger.dart';
import 'exponential_backoff.dart';

enum WsStatus { connecting, connected, reconnecting, disconnected, banned }

typedef DecodeFn<T> = T? Function(Map<String, dynamic> json);
typedef EncodeFn = String Function(List<String> symbols);

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ê³µì‹ WebSocket ë°±ì„œ 100% ì¤€ìˆ˜ WebSocket í´ë¼ì´ì–¸íŠ¸ (ìµœì¢… ìˆ˜ì •ë³¸)
class BaseWsClient<T> {
  final String url;
  final DecodeFn<T> decode;
  final EncodeFn encodeSubscribe;
  final Duration pongTimeout;
  
  // âœ… [ìˆ˜ì •] ì™¸ë¶€ì—ì„œ ì½œë°±ì„ ì„¤ì •í•  ìˆ˜ ìˆë„ë¡ final í‚¤ì›Œë“œ ì œê±°
  void Function(WsStatus status)? onStatusChange;
  
  // âŒ [ì œê±°] ë¬¸ì œë¥¼ ì¼ìœ¼í‚¤ëŠ” Unsolicited Pong ê´€ë ¨ ì†ì„± ì œê±°
  // final Duration unsolicitedPongInterval;

  // Core WebSocket
  WebSocketChannel? _channel;
  final _dataController = StreamController<T>.broadcast();
  List<String> _subscribedSymbols = [];
  bool _isDisposed = false;
  WsStatus _currentStatus = WsStatus.disconnected;

  // ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ë°±ì„œ ì¤€ìˆ˜ ê¸°ëŠ¥ë“¤
  final _backoff = ExponentialBackoff();
  final _outgoingMsgTimestamps = Queue<DateTime>(); // 5ê°œ/ì´ˆ ì œí•œ ê´€ë¦¬
  final _incomingMsgTimestamps = Queue<DateTime>(); // ì•± ì•ˆì •ì„±ìš©

  // íƒ€ì´ë¨¸ë“¤
  Timer? _pongTimer;
  Timer? _sessionRefreshTimer;
  Timer? _keepAliveTimer;
  // âŒ [ì œê±°] Unsolicited Pong íƒ€ì´ë¨¸ ë³€ìˆ˜ ì œê±°
  // Timer? _unsolicitedPongTimer;

  // ì—°ê²° í†µê³„ (IP Ban ë°©ì§€)
  int _connectionAttempts = 0;
  DateTime? _lastConnectionAttempt;
  DateTime? _sessionStartTime;

  BaseWsClient({
    required this.url,
    required this.decode,
    required this.encodeSubscribe,
    this.onStatusChange,
    required this.pongTimeout,
    // âŒ [ì œê±°]
    // required this.unsolicitedPongInterval,
  });

  Stream<T> get stream => _dataController.stream;
  WsStatus get currentStatus => _currentStatus;
  bool get isConnected => _currentStatus == WsStatus.connected;

  // ===================================================================
  // ğŸš€ ì—°ê²° ê´€ë¦¬
  // ===================================================================

  void connect(List<String> symbols) {
    if (_isDisposed || symbols.isEmpty || _currentStatus == WsStatus.connecting) {
      return;
    }

    if (!_canAttemptConnection()) {
      log.w('[WS] Connection attempt blocked - too many attempts');
      return;
    }

    _subscribedSymbols = symbols;
    _updateStatus(WsStatus.connecting);
    _cleanupConnection(keepSubscribers: true);

    try {
      _channel = WebSocketChannel.connect(Uri.parse(url));
      _sessionStartTime = DateTime.now();
      _connectionAttempts++;
      _lastConnectionAttempt = DateTime.now();

      _sendControlMessage(encodeSubscribe(_subscribedSymbols));

      _channel!.stream.listen(
        _handleMessage,
        onDone: () => _scheduleReconnect(reason: 'Stream done'),
        onError: (e) => _scheduleReconnect(reason: 'Stream error: $e'),
      );

      _backoff.reset();
      _setupTimers();
      _updateStatus(WsStatus.connected);
      log.i('[WS] ğŸ¯ Connected to $url (Session: ${_sessionStartTime})');
    } catch (e, st) {
      log.e('[WS] Connection failed', e, st);
      _scheduleReconnect(reason: 'Connection exception');
    }
  }

  // ===================================================================
  // ğŸ“¨ ë©”ì‹œì§€ ì²˜ë¦¬ (ë°”ì´ë‚¸ìŠ¤ ë°±ì„œ ì¤€ìˆ˜)
  // ===================================================================

  void _handleMessage(dynamic message) {
    _trackIncomingMessage();
    _resetPongTimer();

    // âœ… [ìˆ˜ì •] ë©”ì‹œì§€ê°€ ìœ íš¨í•œ ë¬¸ìì—´ì¸ì§€ ë¨¼ì € í™•ì¸
    if (message is! String || message.isEmpty) {
      log.w('[WS] Received non-string or empty message, skipping. Message: $message');
      return;
    }

    // âœ… [ìˆ˜ì •] ë¬¸ì„œì— ëª…ì‹œëœ ëŒ€ë¡œ, ì„œë²„ì˜ pingì—ë§Œ pongìœ¼ë¡œ ì‘ë‹µ. ì´ê²ƒìœ¼ë¡œ ì¶©ë¶„.
    if (message == 'ping' || message == 'PING') {
      _sendPong();
      return;
    }

    try {
      final json = jsonDecode(message) as Map<String, dynamic>;

      if (json.containsKey('code') && json['code'] != 0) {
        final errorCode = json['code'] as int;
        final errorMsg = json['msg'] as String? ?? 'Unknown error';
        log.e('[WS] ğŸš¨ Binance error: $errorMsg (code: $errorCode)');
        
        // âœ… [ìˆ˜ì •] code:3ê³¼ ê°™ì€ ì„œë²„ ì—ëŸ¬ëŠ” ì—°ê²° ëŠê¹€ì„ ì˜ë¯¸í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ, ë¡œê·¸ë§Œ ë‚¨ê¸°ê³  ì—°ê²° ìœ ì§€
        // ì‹¬ê°í•œ ì˜¤ë¥˜(e.g., code:2) ì‹œì—ë§Œ ì¬ì—°ê²° ê³ ë ¤
        if (errorCode == 2) {
          _scheduleReconnect(reason: 'Critical server error: $errorCode');
        }
        return; // ì¬ì—°ê²°í•˜ì§€ ì•Šê³  í•¨ìˆ˜ ì¢…ë£Œ
      }

      final decodedData = decode(json);
      if (decodedData != null) {
        _dataController.add(decodedData);
      }
    } catch (e, st) {
      // âœ… [ìˆ˜ì •] JSON íŒŒì‹± ì—ëŸ¬ ë°œìƒ ì‹œ, ì—°ê²°ì„ ëŠì§€ ì•Šê³  ë¡œê·¸ë§Œ ë‚¨ê¹€
      log.e('[WS] Message decode error, but maintaining connection. Message: "$message"', e, st);
    }
  }

  // ===================================================================
  // ğŸ›ï¸ ë©”ì‹œì§€ ì†¡ì‹  (5ê°œ/ì´ˆ ì œí•œ ì¤€ìˆ˜)
  // ===================================================================

  void _sendControlMessage(String message) {
    if (!_canSendMessage()) {
      log.w('[WS] ğŸš¨ Outgoing message rate limit - message dropped');
      return;
    }
    _trackOutgoingMessage();
    _channel?.sink.add(message);
    log.d('[WS] ğŸ“¤ Control message sent');
  }

  void _sendPong() {
    if (!_canSendMessage()) return;
    _trackOutgoingMessage();
    _channel?.sink.add('pong');
    log.d('[WS] ğŸ“ PONG sent');
  }

  // ===================================================================
  // ğŸ“Š ì†ë„ ì œí•œ ê´€ë¦¬ (ë°”ì´ë‚¸ìŠ¤ ë°±ì„œ ì¤€ìˆ˜)
  // ===================================================================

  bool _canSendMessage() {
    final now = DateTime.now();
    _cleanOldTimestamps(_outgoingMsgTimestamps, const Duration(seconds: 1));
    return _outgoingMsgTimestamps.length < 5; // ë¬¸ì„œ ê¸°ì¤€ ì´ˆë‹¹ 5ê°œ
  }

  void _trackOutgoingMessage() {
    _outgoingMsgTimestamps.addLast(DateTime.now());
  }

  void _trackIncomingMessage() {
    final now = DateTime.now();
    _incomingMsgTimestamps.addLast(now);
    _cleanOldTimestamps(_incomingMsgTimestamps, const Duration(seconds: 1));

    if (_incomingMsgTimestamps.length > AppConfig.wsMaxInMsgPerSec) {
      log.w('[WS] âš ï¸ High incoming message rate: ${_incomingMsgTimestamps.length}/sec');
    }
  }

  void _cleanOldTimestamps(Queue<DateTime> timestamps, Duration window) {
    final cutoff = DateTime.now().subtract(window);
    while (timestamps.isNotEmpty && timestamps.first.isBefore(cutoff)) {
      timestamps.removeFirst();
    }
  }

  // ===================================================================
  // â° íƒ€ì´ë¨¸ ê´€ë¦¬ (ë°”ì´ë‚¸ìŠ¤ ì •ì±… ì¤€ìˆ˜)
  // ===================================================================

  void _setupTimers() {
    _resetPongTimer();
    _setupSessionRefreshTimer();
    _setupKeepAlive();
    // âŒ [ì œê±°]
    // _setupUnsolicitedPong();
  }

  void _resetPongTimer() {
    _pongTimer?.cancel();
    _pongTimer = Timer(pongTimeout, () {
      log.w('[WS] ğŸš¨ Pong timeout - no server message in ${pongTimeout.inSeconds}s');
      _scheduleReconnect(reason: 'Pong timeout');
    });
  }

  // âŒ [ì œê±°] Unsolicited Pong ì„¤ì • ë©”ì„œë“œ ì „ì²´ ì œê±°
  /*
  void _setupUnsolicitedPong() { ... }
  */

  void _setupSessionRefreshTimer() {
    _sessionRefreshTimer?.cancel();
    _sessionRefreshTimer = Timer(AppConfig.wsSessionRefresh, () {
      log.i('[WS] ğŸ”„ 24h session refresh - proactive reconnect');
      _scheduleReconnect(reason: '24h session refresh');
    });
  }

  void _setupKeepAlive() {
    _keepAliveTimer?.cancel();
    _keepAliveTimer = Timer.periodic(AppConfig.wsKeepAliveInterval, (_) {
      if (_currentStatus == WsStatus.connected) {
        log.d('[WS] ğŸ’“ Keep-alive check');
      }
    });
  }

  // ===================================================================
  // ğŸ”„ ì¬ì—°ê²° ê´€ë¦¬ (IP Ban ë°©ì§€)
  // ===================================================================

  void _scheduleReconnect({required String reason}) {
    if (_isDisposed || _currentStatus == WsStatus.reconnecting) return;

    log.w('[WS] ğŸ”„ Disconnected: $reason');
    _updateStatus(WsStatus.reconnecting);
    _cleanupConnection(keepSubscribers: true);

    if (_connectionAttempts >= AppConfig.wsMaxReconnectAttempts) {
      log.w('[WS] ğŸš¨ Too many connection attempts - cooling down');
      _updateStatus(WsStatus.banned);
      Timer(AppConfig.wsReconnectCooldown, () {
        _connectionAttempts = 0;
        if (!_isDisposed) {
          _scheduleReconnect(reason: 'Cooldown complete');
        }
      });
      return;
    }

    _backoff.attempt(() async {
      if (!_isDisposed && _subscribedSymbols.isNotEmpty) {
        connect(_subscribedSymbols);
      }
    });
  }

  bool _canAttemptConnection() {
    final now = DateTime.now();
    if (_lastConnectionAttempt != null) {
      final timeSinceLastAttempt = now.difference(_lastConnectionAttempt!);
      if (timeSinceLastAttempt < const Duration(minutes: 5) &&
          _connectionAttempts >= AppConfig.wsMaxConnectionsPer5Min) {
        return false;
      }
      if (timeSinceLastAttempt >= const Duration(minutes: 5)) {
        _connectionAttempts = 0;
      }
    }
    return _connectionAttempts < AppConfig.wsMaxReconnectAttempts;
  }

  // ===================================================================
  // ğŸ›ï¸ ìƒíƒœ ë° ì •ë¦¬
  // ===================================================================

  void _updateStatus(WsStatus status) {
    if (_currentStatus == status) return;
    final oldStatus = _currentStatus;
    _currentStatus = status;
    log.i('[WS] ğŸ“Š Status: $oldStatus â†’ $status');
    try {
      onStatusChange?.call(status);
    } catch (e, st) {
      log.e('[WS] Status callback error', e, st);
    }
  }

  void _cleanupConnection({bool keepSubscribers = false}) {
    _pongTimer?.cancel();
    _sessionRefreshTimer?.cancel();
    _keepAliveTimer?.cancel();
    // âŒ [ì œê±°]
    // _unsolicitedPongTimer?.cancel();

    try {
      _channel?.sink.close();
    } catch (e) {
      log.d('[WS] Channel close error (normal): $e');
    }

    if (!keepSubscribers) {
      _subscribedSymbols.clear();
    }
  }

  void dispose() {
    if (_isDisposed) return;
    _isDisposed = true;
    log.i('[WS] ğŸ”Œ Client disposing...');
    _backoff.cancel();
    _cleanupConnection();
    _dataController.close();
    _updateStatus(WsStatus.disconnected);
    final sessionDuration = _sessionStartTime != null
        ? DateTime.now().difference(_sessionStartTime!)
        : null;
    log.i('[WS] âœ… Disposed (Session: ${sessionDuration?.inMinutes ?? 0}min, Attempts: $_connectionAttempts)');
  }

  // ===================================================================
  // ğŸ“Š ë””ë²„ê·¸ ì •ë³´
  // ===================================================================

  Map<String, dynamic> getDebugInfo() {
    return {
      'status': _currentStatus.toString(),
      'subscribedSymbols': _subscribedSymbols.length,
      'connectionAttempts': _connectionAttempts,
      'sessionDuration': _sessionStartTime != null
          ? DateTime.now().difference(_sessionStartTime!).inMinutes
          : 0,
      'outgoingMsgRate': _outgoingMsgTimestamps.length,
      'incomingMsgRate': _incomingMsgTimestamps.length,
    };
  }
}\n\n// ====== lib/core/network/websocket/exponential_backoff.dart ======\n
import 'dart:async';
import 'dart:math';
import '../../utils/logger.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ IP Ban ë°©ì§€ë¥¼ ìœ„í•œ ì§€ìˆ˜ ë°±ì˜¤í”„
/// ë°±ì„œ ì œí•œ: "300 connections per attempt every 5 minutes per IP"
class ExponentialBackoff {
  final Duration initialDelay;
  final Duration maxDelay;
  final double randomizationFactor;
  final int maxRetries;

  int _retryCount = 0;
  Timer? _retryTimer;
  DateTime? _firstAttemptTime;

  ExponentialBackoff({
    this.initialDelay = const Duration(seconds: 2), // ë°”ì´ë‚¸ìŠ¤ìš© ë³´ìˆ˜ì  ì‹œì‘
    this.maxDelay = const Duration(minutes: 5), // 5ë¶„ ìµœëŒ€ (IP ì œí•œ ê³ ë ¤)
    this.randomizationFactor = 0.3, // 30% ì§€í„°
    this.maxRetries = 10, // IP Ban ë°©ì§€
  });

  /// ğŸ¯ ë‹¤ìŒ ì¬ì‹œë„ê¹Œì§€ì˜ ëŒ€ê¸° ì‹œê°„ ê³„ì‚° (ë°”ì´ë‚¸ìŠ¤ ì¹œí™”ì )
  Duration get nextDelay {
    // ì²« ì‹œë„ëŠ” ì§€ì—° ì—†ìŒ
    if (_retryCount == 0) return Duration.zero;

    // ì§€ìˆ˜ ë°±ì˜¤í”„: 2^n * initialDelay
    final baseDelay = initialDelay * pow(2, _retryCount - 1);

    // ğŸ¯ ë°”ì´ë‚¸ìŠ¤ íŠ¹í™”: 5ë¶„ ê²½ê³„ì—ì„œ ë” ê¸´ ëŒ€ê¸°
    Duration adjustedDelay = baseDelay;
    if (_retryCount >= 5) {
      // 5íšŒ ì´ìƒ ì‹¤íŒ¨ ì‹œ ë” ë³´ìˆ˜ì ìœ¼ë¡œ
      adjustedDelay = Duration(minutes: 1 + _retryCount);
    }

    // ëœë¤ ì§€í„° ì¶”ê°€ (ì„œë²„ ë¶€í•˜ ë¶„ì‚°)
    final random = Random();
    final jitter = (adjustedDelay.inMilliseconds *
            randomizationFactor *
            (random.nextDouble() * 2 - 1))
        .round();

    final finalDelay = Duration(
        milliseconds: (adjustedDelay.inMilliseconds + jitter)
            .clamp(initialDelay.inMilliseconds, maxDelay.inMilliseconds));

    return finalDelay;
  }

  /// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ IP ì œí•œ ê³ ë ¤í•œ ì¬ì‹œë„ ì‹œë„
  void attempt(Future<void> Function() action) {
    // ì´ì „ íƒ€ì´ë¨¸ ì·¨ì†Œ
    _retryTimer?.cancel();

    // ğŸš¨ IP Ban ë°©ì§€: ìµœëŒ€ ì¬ì‹œë„ ì²´í¬
    if (_retryCount >= maxRetries) {
      log.e(
          '[Backoff] ğŸš¨ Max retry limit reached ($maxRetries). Stopping to prevent IP ban.');
      _resetForCooldown();
      return;
    }

    // ğŸ¯ 5ë¶„ ê²½ê³„ ì²´í¬ (ë°”ì´ë‚¸ìŠ¤ ì •ì±…)
    if (_shouldCooldown()) {
      log.w('[Backoff] ğŸ• 5-minute cooldown activated for IP safety');
      _resetForCooldown();
      return;
    }

    _retryCount++;
    _firstAttemptTime ??= DateTime.now();

    final delay = nextDelay;
    final totalDuration = DateTime.now().difference(_firstAttemptTime!);

    log.i('[Backoff] ğŸ”„ Attempt #$_retryCount after ${delay.inSeconds}s '
        '(Total: ${totalDuration.inMinutes}min)');

    _retryTimer = Timer(delay, () async {
      try {
        await action();
        // ì„±ê³µ ì‹œ ë¦¬ì…‹ì€ ì™¸ë¶€ì—ì„œ í˜¸ì¶œ (connect ì„±ê³µ ì‹œ)
      } catch (e) {
        log.w('[Backoff] âŒ Action failed: $e');
        // ì‹¤íŒ¨ ì‹œ ë‹¤ì‹œ ì¬ì‹œë„í•˜ì§€ ì•ŠìŒ (í˜¸ì¶œìê°€ ê²°ì •)
      }
    });
  }

  /// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ 5ë¶„ ì œí•œ ê³ ë ¤ (300 connections per 5 minutes)
  bool _shouldCooldown() {
    if (_firstAttemptTime == null) return false;

    final elapsed = DateTime.now().difference(_firstAttemptTime!);

    // 5ë¶„ ë‚´ì— ë„ˆë¬´ ë§ì€ ì‹œë„
    if (elapsed < const Duration(minutes: 5) && _retryCount >= 8) {
      return true;
    }

    // ì´ ì‹œë„ ì‹œê°„ì´ ë„ˆë¬´ ê¸¸ë©´ (15ë¶„ ì´ìƒ)
    if (elapsed > const Duration(minutes: 15)) {
      return true;
    }

    return false;
  }

  /// 5ë¶„ ì¿¨ë‹¤ìš´ í›„ ì¬ì‹œì‘
  void _resetForCooldown() {
    const cooldownDuration = Duration(minutes: 5);
    log.i('[Backoff] ğŸ• Starting ${cooldownDuration.inMinutes}min cooldown...');

    _retryTimer?.cancel();
    _retryTimer = Timer(cooldownDuration, () {
      log.i('[Backoff] âœ… Cooldown complete - resetting counters');
      reset();
    });
  }

  /// ì—°ê²° ì„±ê³µ ì‹œ ë°±ì˜¤í”„ ë¦¬ì…‹
  void reset() {
    _retryCount = 0;
    _firstAttemptTime = null;
    _retryTimer?.cancel();
    log.d('[Backoff] âœ… Reset - ready for new attempts');
  }

  /// ë°±ì˜¤í”„ ì™„ì „ ì¤‘ì§€
  void cancel() {
    _retryTimer?.cancel();
    _retryCount = 0;
    _firstAttemptTime = null;
    log.d('[Backoff] ğŸ›‘ Cancelled');
  }

  // ===================================================================
  // ğŸ“Š ìƒíƒœ ì •ë³´
  // ===================================================================

  int get retryCount => _retryCount;
  bool get isActive => _retryTimer?.isActive ?? false;
  bool get isInCooldown => _retryCount == 0 && isActive;

  Duration? get timeSinceFirstAttempt => _firstAttemptTime != null
      ? DateTime.now().difference(_firstAttemptTime!)
      : null;

  /// ë°±ì˜¤í”„ ìƒíƒœ ë””ë²„ê·¸ ì •ë³´
  Map<String, dynamic> getDebugInfo() {
    return {
      'retryCount': _retryCount,
      'isActive': isActive,
      'isInCooldown': isInCooldown,
      'nextDelaySeconds': nextDelay.inSeconds,
      'timeSinceFirstAttemptMinutes': timeSinceFirstAttempt?.inMinutes ?? 0,
      'maxRetries': maxRetries,
      'shouldCooldown': _shouldCooldown(),
    };
  }

  /// ë°±ì˜¤í”„ ì „ëµ ì„¤ëª…
  String getStrategyDescription() {
    final buf = StringBuffer();
    buf.writeln('ğŸ¯ Binance IP Ban Prevention Strategy:');
    buf.writeln('  â€¢ Initial delay: ${initialDelay.inSeconds}s');
    buf.writeln('  â€¢ Max delay: ${maxDelay.inMinutes}min');
    buf.writeln('  â€¢ Max retries: $maxRetries');
    buf.writeln('  â€¢ Jitter factor: ${(randomizationFactor * 100).toInt()}%');
    buf.writeln(
        '  â€¢ 5-minute cooldown: ${_retryCount >= 8 ? "ACTIVE" : "Ready"}');
    return buf.toString();
  }

  /// í˜„ì¬ ë°±ì˜¤í”„ ìƒíƒœ ìš”ì•½
  String getStatusSummary() {
    if (_retryCount == 0) return 'âœ… Ready';
    if (isInCooldown) return 'ğŸ• Cooling down';
    if (_retryCount >= maxRetries) return 'ğŸš¨ Max retries reached';
    return 'ğŸ”„ Retrying (#$_retryCount/${maxRetries})';
  }
}
\n\n// ====== lib/core/network/websocket/binance_ws_utils.dart ======\n
import 'dart:convert';
import 'dart:math';
import '../../config/app_config.dart';
import '../../utils/logger.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ WebSocket ê³µí†µ ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤
class BinanceWsUtils {
  
  // ===================================================================
  // ğŸ“¨ ë©”ì‹œì§€ ìƒì„±
  // ===================================================================

  /// ê³ ìœ í•œ ë©”ì‹œì§€ ID ìƒì„± (ë°”ì´ë‚¸ìŠ¤ í˜¸í™˜)
  static int generateMessageId() {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final random = Random().nextInt(1000);
    return timestamp * 1000 + random;
  }

  /// ë°”ì´ë‚¸ìŠ¤ êµ¬ë… ë©”ì‹œì§€ ìƒì„±
  static String createSubscribeMessage(List<String> params) {
    if (params.length > AppConfig.wsMaxStreams) {
      throw ArgumentError(
        'Too many streams: ${params.length}. '
        'Binance limit: ${AppConfig.wsMaxStreams} streams per connection.'
      );
    }

    final subscribeMessage = {
      'method': 'SUBSCRIBE',
      'params': params,
      'id': generateMessageId(),
    };

    final jsonMessage = jsonEncode(subscribeMessage);
    log.d('[BinanceWS] ğŸ“¤ Subscribe message: $jsonMessage');
    
    return jsonMessage;
  }

  /// ë°”ì´ë‚¸ìŠ¤ êµ¬ë… í•´ì œ ë©”ì‹œì§€ ìƒì„±
  static String createUnsubscribeMessage(List<String> params) {
    final unsubscribeMessage = {
      'method': 'UNSUBSCRIBE',
      'params': params,
      'id': generateMessageId(),
    };

    final jsonMessage = jsonEncode(unsubscribeMessage);
    log.d('[BinanceWS] ğŸ“¤ Unsubscribe message: $jsonMessage');
    
    return jsonMessage;
  }

  // ===================================================================
  // ğŸ“¥ ë©”ì‹œì§€ ê²€ì¦
  // ===================================================================

  /// Combined Stream ë°ì´í„° ì¶”ì¶œ
  static Map<String, dynamic>? extractCombinedStreamData(
    Map<String, dynamic> json,
    String expectedStreamSuffix,
  ) {
    if (!json.containsKey('stream') || !json.containsKey('data')) {
      return null;
    }

    final streamName = json['stream'] as String?;
    final data = json['data'];

    if (streamName == null || data == null) {
      return null;
    }

    // ìŠ¤íŠ¸ë¦¼ íƒ€ì… í™•ì¸
    if (!streamName.contains(expectedStreamSuffix)) {
      return null;
    }

    if (data is Map<String, dynamic>) {
      return data;
    }

    return null;
  }

  /// Direct Stream ë°ì´í„° í™•ì¸
  static bool isDirectStreamEvent(Map<String, dynamic> json, String eventType) {
    return json.containsKey('e') && json['e'] == eventType;
  }

  // ===================================================================
  // ğŸ“Š í†µê³„ ìœ í‹¸ë¦¬í‹°
  // ===================================================================

  /// ê¸°ë³¸ í†µê³„ ì •ë³´ ìƒì„±
  static Map<String, dynamic> createBaseStatistics({
    required String streamType,
    required String updateSpeed,
    required int totalReceived,
    required int totalErrors,
    required int activeStreams,
    required DateTime? firstTime,
    required DateTime? lastTime,
    Map<String, dynamic>? additionalStats,
  }) {
    final now = DateTime.now();
    final sessionDuration = firstTime != null
        ? now.difference(firstTime)
        : Duration.zero;

    final itemsPerMinute = sessionDuration.inMinutes > 0
        ? (totalReceived / sessionDuration.inMinutes).toStringAsFixed(1)
        : '0';

    final errorRate = totalReceived > 0
        ? '${((totalErrors / (totalReceived + totalErrors)) * 100).toStringAsFixed(2)}%'
        : '0%';

    final baseStats = {
      'streamType': streamType,
      'updateSpeed': updateSpeed,
      'totalReceived': totalReceived,
      'totalErrors': totalErrors,
      'activeStreams': activeStreams,
      'sessionDurationMinutes': sessionDuration.inMinutes,
      'itemsPerMinute': itemsPerMinute,
      'errorRate': errorRate,
      'firstTime': firstTime?.toIso8601String(),
      'lastTime': lastTime?.toIso8601String(),
    };

    if (additionalStats != null) {
      baseStats.addAll(additionalStats);
    }

    return baseStats;
  }

  // ===================================================================
  // ğŸ”§ ìŠ¤íŠ¸ë¦¼ íŒŒë¼ë¯¸í„° ìƒì„±ê¸°
  // ===================================================================

  /// aggTrade ìŠ¤íŠ¸ë¦¼ íŒŒë¼ë¯¸í„° ìƒì„±
  static List<String> createAggTradeStreams(List<String> symbols) {
    return symbols.map((symbol) => '${symbol.toLowerCase()}@aggTrade').toList();
  }

  /// depth ìŠ¤íŠ¸ë¦¼ íŒŒë¼ë¯¸í„° ìƒì„±
  static List<String> createDepthStreams(List<String> symbols, {bool fast = false}) {
    final suffix = fast ? 'depth@100ms' : 'depth';
    return symbols.map((symbol) => '${symbol.toLowerCase()}@$suffix').toList();
  }

  /// bookTicker ìŠ¤íŠ¸ë¦¼ íŒŒë¼ë¯¸í„° ìƒì„±
  static List<String> createBookTickerStreams(List<String> symbols) {
    return symbols.map((symbol) => '${symbol.toLowerCase()}@bookTicker').toList();
  }

  /// kline ìŠ¤íŠ¸ë¦¼ íŒŒë¼ë¯¸í„° ìƒì„±
  static List<String> createKlineStreams(List<String> symbols, String interval) {
    return symbols.map((symbol) => '${symbol.toLowerCase()}@kline_$interval').toList();
  }

  /// ticker ìŠ¤íŠ¸ë¦¼ íŒŒë¼ë¯¸í„° ìƒì„±
  static List<String> createTickerStreams(List<String> symbols, {bool mini = false}) {
    final suffix = mini ? 'miniTicker' : 'ticker';
    return symbols.map((symbol) => '${symbol.toLowerCase()}@$suffix').toList();
  }

  /// ì „ì²´ ticker ìŠ¤íŠ¸ë¦¼ íŒŒë¼ë¯¸í„° ìƒì„± (ëª¨ë“  ì‹¬ë³¼)
  static List<String> createAllTickerStreams({bool mini = false}) {
    final suffix = mini ? '!miniTicker@arr' : '!ticker@arr';
    return [suffix];
  }
}\n\n// ====== lib/core/network/api_client.dart ======\n
import 'package:dio/dio.dart';
import '../config/app_config.dart';
import '../error/app_exception.dart';
import '../utils/logger.dart';

/// ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ REST API í†µì‹ ì„ ìœ„í•œ í´ë¼ì´ì–¸íŠ¸
class ApiClient {
  final Dio _dio;

  ApiClient({Dio? dio})
      : _dio = dio ??
            Dio(BaseOptions(
              baseUrl: AppConfig.restBaseUrl,
              connectTimeout: AppConfig.restTimeout,
              receiveTimeout: AppConfig.restTimeout,
            ));

  /// GET ìš”ì²­ì„ ìœ„í•œ ë²”ìš© ë©”ì„œë“œ
  Future<dynamic> get(String path) async {
    try {
      log.d('[API] GET: $path');
      final response = await _dio.get(path);
      return response.data;
    } on DioException catch (e, st) {
      // âœ… ì—ëŸ¬ ë¡œê¹… ë°©ì‹ì„ positional argumentë¡œ ìˆ˜ì •
      log.e('[API] GET failed on path: $path', e, st);
      // DioExceptionì„ ì»¤ìŠ¤í…€ NetworkExceptionìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ë°˜í™˜
      throw NetworkException.fromDio(e);
    } catch (e, st) {
      // âœ… ì—ëŸ¬ ë¡œê¹… ë°©ì‹ì„ positional argumentë¡œ ìˆ˜ì •
      log.e('[API] Unexpected error on path: $path', e, st);
      // ê·¸ ì™¸ ì˜ˆì™¸ëŠ” ì¼ë°˜ AppExceptionìœ¼ë¡œ ì²˜ë¦¬
      throw AppException(e.toString());
    }
  }
}\n\n// ====== lib/core/utils/logger.dart ======\n
import 'package:logger/logger.dart';

/// ì•± ì „ì²´ì—ì„œ ì‚¬ìš©í•  ì „ì—­ ë¡œê±° ì¸ìŠ¤í„´ìŠ¤
final Logger log = Logger(
  printer: PrettyPrinter(
    methodCount: 1, // ë¡œê·¸ í˜¸ì¶œ ìŠ¤íƒì„ í•œ ì¤„ë§Œ í‘œì‹œ
    errorMethodCount: 8, // ì—ëŸ¬ ë°œìƒ ì‹œ í‘œì‹œí•  ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë¼ì¸ ìˆ˜
    lineLength: 120, // ë¡œê·¸ í•œ ì¤„ì˜ ìµœëŒ€ ê¸¸ì´
    colors: true, // ë¡œê·¸ ë ˆë²¨ë³„ ì»¬ëŸ¬ ì ìš©
    printEmojis: true, // ë¡œê·¸ ë ˆë²¨ë³„ ì´ëª¨ì§€ ì ìš©
    printTime: true, // íƒ€ì„ìŠ¤íƒ¬í”„ ì¶œë ¥
  ),
  // ê°œë°œ ì¤‘ì—ëŠ” ëª¨ë“  ë ˆë²¨ì˜ ë¡œê·¸ë¥¼, ë¦´ë¦¬ì¦ˆ ì‹œì—ëŠ” Level.warning ë“±ìœ¼ë¡œ ë³€ê²½ ê°€ëŠ¥
  level: Level.debug,
);
\n\n// ====== lib/core/common/time_frame_types.dart ======\n
import 'package:flutter/foundation.dart';

/// ê±°ë˜ í•„í„° Enum (ë‹¨ìœ„: USDT)
///
/// ë°”ì´ë‚¸ìŠ¤ í™˜ê²½ì— ë§ì¶° ê±°ë˜ëŒ€ê¸ˆ í•„í„°ì˜ ê¸°ì¤€ì„ USDTë¡œ ë³€ê²½í•©ë‹ˆë‹¤.
enum TradeFilter {
  usdt10k(10000, '10K USDT'),
  usdt30k(30000, '30K USDT'),
  usdt50k(50000, '50K USDT'),
  usdt100k(100000, '100K USDT'),
  usdt300k(300000, '300K USDT'),
  usdt500k(500000, '500K USDT');

  const TradeFilter(this.value, this.displayName);
  final double value;
  final String displayName;

  static List<TradeFilter> get supportedFilters => values.toList();
}

/// ê±°ë˜ ëª¨ë“œ Enum (ê±°ë˜ì†Œ ë¬´ê´€)
enum TradeMode {
  accumulated('ëˆ„ì '),
  range('êµ¬ê°„');

  const TradeMode(this.displayName);
  final String displayName;

  bool get isAccumulated => this == TradeMode.accumulated;
}

/// ê±°ë˜ ê´€ë ¨ ì„¤ì • (ê±°ë˜ì†Œ ë¬´ê´€)
class TradeConfig {
  /// í•„í„°ë³„ë¡œ UIì— í‘œì‹œí•  ìµœëŒ€ ê±°ë˜ ë‚´ì—­ ê°œìˆ˜
  static const int maxTradesPerFilter = 200;
  
  /// ì¤‘ë³µ ì²´ê²° IDë¥¼ ê±¸ëŸ¬ë‚´ê¸° ìœ„í•œ ìºì‹œ ì‚¬ì´ì¦ˆ
  static const int maxSeenIdsCacheSize = 1000;
}

/// ë°”ì´ë‚¸ìŠ¤ ë§ˆì¼“ ì •ë³´ ì—”í‹°í‹°
///
/// ë°”ì´ë‚¸ìŠ¤ì˜ `/fapi/v1/exchangeInfo` ì—”ë“œí¬ì¸íŠ¸ ì‘ë‹µì„ ê¸°ë°˜ìœ¼ë¡œ ì¬êµ¬ì„±í•©ë‹ˆë‹¤.
@immutable
class MarketInfo {
  final String symbol;
  final String pair;
  final String status;
  final String baseAsset;
  final String quoteAsset;
  final int pricePrecision;
  final int quantityPrecision;

  const MarketInfo({
    required this.symbol,
    required this.pair,
    required this.status,
    required this.baseAsset,
    required this.quoteAsset,
    required this.pricePrecision,
    required this.quantityPrecision,
  });

  factory MarketInfo.fromJson(Map<String, dynamic> json) {
    return MarketInfo(
      symbol: json['symbol'] ?? '',
      pair: json['pair'] ?? '',
      status: json['status'] ?? '',
      baseAsset: json['baseAsset'] ?? '',
      quoteAsset: json['quoteAsset'] ?? '',
      pricePrecision: json['pricePrecision'] ?? 0,
      quantityPrecision: json['quantityPrecision'] ?? 0,
    );
  }
}\n\n// ====== lib/core/error/app_exception.dart ======\n
import 'package:dio/dio.dart';

/// ì•±ì˜ ìµœìƒìœ„ ì»¤ìŠ¤í…€ ì˜ˆì™¸ í´ë˜ìŠ¤
class AppException implements Exception {
  final String message;
  final StackTrace? stackTrace;

  const AppException(this.message, [this.stackTrace]);

  @override
  String toString() => 'AppException: $message';
}

/// ë„¤íŠ¸ì›Œí¬(REST API) ê´€ë ¨ ì˜ˆì™¸
class NetworkException extends AppException {
  final DioException? originalException;

  const NetworkException(String message, {this.originalException, StackTrace? stackTrace})
      : super(message, stackTrace);

  factory NetworkException.fromDio(DioException dioError) {
    final message = dioError.message ?? 'A network error occurred.';
    return NetworkException(
      message,
      originalException: dioError,
      stackTrace: dioError.stackTrace,
    );
  }

  @override
  String toString() => 'NetworkException: $message';
}

/// WebSocket ê´€ë ¨ ì˜ˆì™¸
class WebSocketException extends AppException {
  const WebSocketException(String message, [StackTrace? stackTrace])
      : super(message, stackTrace);
      
  @override
  String toString() => 'WebSocketException: $message';
}

/// ë°ì´í„° íŒŒì‹±(JSON ë“±) ê´€ë ¨ ì˜ˆì™¸
class DataParsingException extends AppException {
  const DataParsingException(String message, [StackTrace? stackTrace])
      : super(message, stackTrace);

  @override
  String toString() => 'DataParsingException: $message';
}\n\n// ====== lib/main.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'presentation/pages/main_page.dart';

void main() {
  runApp(const ProviderScope(child: MyApp()));
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Binance Pro',
      theme: ThemeData.light(),
      darkTheme: ThemeData.dark(),
      themeMode: ThemeMode.system,
      debugShowCheckedModeBanner: false,
      home: const MainPage(),
    );
  }
}\n\n// ====== lib/data/datasources/trade_remote_ds.dart ======\n
// lib/data/datasources/trade_remote_ds.dart

import '../../core/network/websocket/trade_ws_client.dart';
import '../../domain/entities/trade.dart';

/// ì›ê²© WebSocketìœ¼ë¡œë¶€í„° ì‹¤ì‹œê°„ Trade ë°ì´í„°ë¥¼ ìˆ˜ì‹ í•˜ëŠ” ë°ì´í„° ì†ŒìŠ¤
class TradeRemoteDataSource {
  final TradeWsClient _wsClient;

  TradeRemoteDataSource(this._wsClient);

  /// WebSocket í´ë¼ì´ì–¸íŠ¸ì— ë§ˆì¼“ êµ¬ë…ì„ ìš”ì²­í•˜ê³ ,
  /// ë°˜í™˜ë˜ëŠ” ìˆœìˆ˜ Trade ìŠ¤íŠ¸ë¦¼ì„ ê·¸ëŒ€ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
  Stream<Trade> watchTrades(List<String> markets) {
    _wsClient.connect(markets);
    return _wsClient.stream;
  }
}\n\n// ====== lib/data/repositories/volume_repository_impl.dart ======\n
// lib/data/repositories/volume_repository_impl.dart

import 'dart:async';
import 'package:collection/collection.dart'; // sortedë¥¼ ìœ„í•´ import ì¶”ê°€
import '../../core/utils/logger.dart';
import '../../domain/entities/trade.dart';
import '../../domain/entities/volume.dart';
import '../../domain/repositories/volume_repository.dart';
import '../datasources/trade_remote_ds.dart';

class VolumeRepositoryImpl implements VolumeRepository {
  final TradeRemoteDataSource _remoteDataSource;

  final Map<TimeFrame, StreamController<List<Volume>>> _controllers = {};
  StreamSubscription? _rawTradeSub;
  final Map<TimeFrame, Map<String, double>> _volumeCache = {};
  final Map<TimeFrame, DateTime> _timeFrameStartTimes = {};
  Timer? _batchUpdateTimer;
  Timer? _resetCheckTimer;
  bool _isInitialized = false;

  VolumeRepositoryImpl(this._remoteDataSource) {
    for (final tf in TimeFrame.values) {
      _controllers[tf] = StreamController<List<Volume>>.broadcast();
      _volumeCache[tf] = {};
      _timeFrameStartTimes[tf] = DateTime.now();
    }
    _resetCheckTimer = Timer.periodic(const Duration(seconds: 15), (_) => _checkTimeFrameResets());
  }

  void _initialize(List<String> markets) {
    if (_isInitialized) return;
    _isInitialized = true;
    final rawTradeStream = _remoteDataSource.watchTrades(markets);
    _rawTradeSub = rawTradeStream.listen(_processTrade);
    log.i('[VolumeRepo] Initialized.');
  }

  void _processTrade(Trade trade) {
    for (final tf in TimeFrame.values) {
      final cache = _volumeCache[tf]!;
      cache[trade.market] = (cache[trade.market] ?? 0) + trade.totalValue;
    }
    _scheduleBatchUpdate();
  }

  void _scheduleBatchUpdate() {
    _batchUpdateTimer?.cancel();
    _batchUpdateTimer = Timer(const Duration(milliseconds: 100), _performBatchUpdate);
  }

  void _performBatchUpdate() {
    final now = DateTime.now().millisecondsSinceEpoch;
    for (final tf in TimeFrame.values) {
      final cache = _volumeCache[tf]!;
      final startTime = _timeFrameStartTimes[tf]!;
      
      final volumeList = cache.entries.map((entry) => Volume(
            market: entry.key,
            totalValue: entry.value,
            lastUpdated: now,
            timeFrame: tf,
            timeFrameStart: startTime.millisecondsSinceEpoch,
          ))
      // âœ… sortedBy -> sortedë¡œ ë³€ê²½í•˜ê³ , null ì•ˆì •ì„± ì²˜ë¦¬
      .sorted((a, b) => b.totalValue.compareTo(a.totalValue));
      
      _controllers[tf]?.add(volumeList);
    }
  }

  void _checkTimeFrameResets() {
    final now = DateTime.now();
    for (final tf in TimeFrame.values) {
      final startTime = _timeFrameStartTimes[tf]!;
      if (now.difference(startTime) >= tf.duration) {
        _resetTimeFrame(tf, now);
      }
    }
  }

  void _resetTimeFrame(TimeFrame timeFrame, DateTime newStartTime) {
    _volumeCache[timeFrame]?.clear();
    _timeFrameStartTimes[timeFrame] = newStartTime;
    _performBatchUpdate();
  }

  @override
  Stream<List<Volume>> watchVolumeRanking(TimeFrame timeFrame, List<String> markets) {
    _initialize(markets);
    Future.microtask(_performBatchUpdate);
    return _controllers[timeFrame]?.stream ?? const Stream.empty();
  }

  @override
  void resetTimeFrame(TimeFrame timeFrame) {
    _resetTimeFrame(timeFrame, DateTime.now());
  }

  @override
  void resetAllTimeFrames() {
    final now = DateTime.now();
    for (final tf in TimeFrame.values) {
      _resetTimeFrame(tf, now);
    }
  }

  @override
  void dispose() {
    _rawTradeSub?.cancel();
    _batchUpdateTimer?.cancel();
    _resetCheckTimer?.cancel();
    for (var controller in _controllers.values) {
      controller.close();
    }
    log.i('[VolumeRepo] Disposed.');
  }
}\n\n// ====== lib/data/repositories/trade_repository_impl.dart ======\n
// lib/data/repositories/trade_repository_impl.dart

import 'dart:async';
import 'dart:collection';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/common/time_frame_types.dart';
import '../../domain/entities/trade.dart';
import '../../domain/repositories/trade_repository.dart';
import '../datasources/trade_remote_ds.dart';
import '../processors/trade_aggregator.dart';
import '../../core/utils/logger.dart';

class TradeRepositoryImpl implements TradeRepository {
  final TradeRemoteDataSource _remoteDataSource;
  final TradeAggregator _aggregator;
  
  // ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬
  final _filteredTradesController = StreamController<List<Trade>>.broadcast();
  
  // ë‚´ë¶€ ìƒíƒœ
  StreamSubscription? _rawTradeSub;
  StreamSubscription? _aggregatedTradeSub;
  double _currentThreshold = TradeFilter.usdt50k.value; // ê¸°ë³¸ ì„ê³„ê°’
  final Map<TradeFilter, List<Trade>> _filterCache = {
    for (var filter in TradeFilter.values) filter: []
  };
  final _seenIds = LinkedHashSet<String>();
  Timer? _batchUpdateTimer;
  bool _isInitialized = false;

  TradeRepositoryImpl(this._remoteDataSource) : _aggregator = TradeAggregator();

  void _initialize(List<String> markets) {
    if (_isInitialized) return;
    _isInitialized = true;

    // 1. ì›ê²© ë°ì´í„° ì†ŒìŠ¤ì˜ ìŠ¤íŠ¸ë¦¼ì„ êµ¬ë…
    final rawTradeStream = _remoteDataSource.watchTrades(markets);
    _rawTradeSub = rawTradeStream.listen(_processRawTrade);

    // 2. ì§‘ê³„ê¸°(Aggregator)ì˜ ìŠ¤íŠ¸ë¦¼ì„ êµ¬ë…
    _aggregatedTradeSub = _aggregator.stream.listen(_handleAggregatedTrade);
    
    log.i('[Repository] Initialized with ${markets.length} markets.');
  }

  /// 1. ì›ì‹œ ë°ì´í„° ì²˜ë¦¬: ì¤‘ë³µ í™•ì¸ í›„ ì§‘ê³„ê¸°ë¡œ ì „ë‹¬
  void _processRawTrade(Trade trade) {
    if (!_seenIds.add(trade.tradeId)) return;
    if (_seenIds.length > TradeConfig.maxSeenIdsCacheSize) {
      _seenIds.remove(_seenIds.first);
    }
    _aggregator.process(trade);
  }

  /// 2. ì§‘ê³„ëœ ë°ì´í„° ì²˜ë¦¬: í•„í„°ë³„ ìºì‹œì— ì €ì¥
  void _handleAggregatedTrade(Trade trade) {
    for (final filter in TradeFilter.values) {
      if (trade.totalValue >= filter.value) {
        final list = _filterCache[filter]!;
        list.insert(0, trade);
        if (list.length > TradeConfig.maxTradesPerFilter) {
          list.removeLast();
        }
      }
    }
    // UI ì—…ë°ì´íŠ¸ëŠ” ë°”ë¡œ í•˜ì§€ ì•Šê³ , ë°°ì¹˜ ìŠ¤ì¼€ì¤„ë§
    _scheduleBatchUpdate();
  }
  
  /// 3. ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§: 100ms ì´ë‚´ì˜ ë³€ê²½ì‚¬í•­ì€ í•œ ë²ˆì— ëª¨ì•„ì„œ UI ì—…ë°ì´íŠ¸
  void _scheduleBatchUpdate() {
    _batchUpdateTimer?.cancel();
    _batchUpdateTimer = Timer(const Duration(milliseconds: 100), _performBatchUpdate);
  }
  
  /// 4. ì‹¤ì œ UI ì—…ë°ì´íŠ¸ ìˆ˜í–‰: í˜„ì¬ ì„ê³„ê°’ì— ë§ëŠ” ìµœì¢… ë¦¬ìŠ¤íŠ¸ë¥¼ ìŠ¤íŠ¸ë¦¼ì— ì „ë‹¬
  void _performBatchUpdate() {
    final list = _filterCache[
      TradeFilter.values.firstWhere(
        (f) => f.value == _currentThreshold,
        orElse: () => TradeFilter.usdt50k,
      )
    ] ?? [];
    
    _filteredTradesController.add(List.from(list));
  }

  @override
  Stream<List<Trade>> watchFilteredTrades(List<String> markets) {
    _initialize(markets);
    return _filteredTradesController.stream;
  }

  @override
  Stream<Trade> watchAggregatedTrades(List<String> markets) {
    _initialize(markets);
    return _aggregator.stream;
  }
  
  @override
  void updateThreshold(double threshold) {
    if (_currentThreshold == threshold) return;
    _currentThreshold = threshold;
    log.d('[Repository] Threshold updated to: $threshold');
    // ì„ê³„ê°’ ë³€ê²½ ì‹œ ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸ ìˆ˜í–‰
    _performBatchUpdate();
  }

  @override
  void dispose() {
    _rawTradeSub?.cancel();
    _aggregatedTradeSub?.cancel();
    _batchUpdateTimer?.cancel();
    _aggregator.dispose();
    _filteredTradesController.close();
    _isInitialized = false;
    log.i('[Repository] Disposed.');
  }
}\n\n// ====== lib/data/processors/trade_aggregator.dart ======\n
// lib/data/processors/trade_aggregator.dart

import 'dart:async';
import '../../domain/entities/trade.dart';
import '../../core/utils/logger.dart';

/// ì‹¤ì‹œê°„ ê±°ë˜ë¥¼ ë³‘í•©í•˜ì—¬ UI ì—…ë°ì´íŠ¸ ë¹ˆë„ë¥¼ ì¡°ì ˆí•˜ëŠ” ê±°ë˜ ì§‘ê³„ê¸°
class TradeAggregator {
  final Map<String, Trade> _pendingTrades = {};
  final _controller = StreamController<Trade>.broadcast();
  Timer? _flushTimer;

  /// ì§‘ê³„ ì²˜ë¦¬ëœ ê±°ë˜ ë°ì´í„° ìŠ¤íŠ¸ë¦¼
  Stream<Trade> get stream => _controller.stream;

  TradeAggregator() {
    // 1ì´ˆë§ˆë‹¤ ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ë“¤ì„ ë°©ì¶œ(flush)í•˜ì—¬ í•­ìƒ ìµœì‹  ë°ì´í„°ê°€ ë°˜ì˜ë˜ë„ë¡ í•¨
    _flushTimer = Timer.periodic(const Duration(seconds: 1), (_) => _flush());
  }

  /// ìƒˆë¡œìš´ ê±°ë˜ë¥¼ ë°›ì•„ ì§‘ê³„ ë¡œì§ ì²˜ë¦¬
  void process(Trade trade) {
    final existing = _pendingTrades[trade.market];

    // í•´ë‹¹ ë§ˆì¼“ì— ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ê°€ ì—†ë‹¤ë©´ ìƒˆë¡œ ì¶”ê°€
    if (existing == null) {
      _pendingTrades[trade.market] = trade;
      return;
    }

    // ì‹œê°„ ì°½(500ms) ë‚´ì˜ ê±°ë˜ë¼ë©´ ë³‘í•©
    if (trade.timestamp - existing.timestamp <= 500) {
      final newQuantity = existing.quantity + trade.quantity;
      _pendingTrades[trade.market] = Trade(
        market: trade.market,
        price: trade.price, // ê°€ê²©ì€ ìµœì‹  ê±°ë˜ì˜ ê²ƒì„ ë”°ë¦„
        quantity: newQuantity,
        totalValue: existing.totalValue + trade.totalValue,
        isBuy: trade.isBuy, // ë°©í–¥ë„ ìµœì‹  ê±°ë˜ì˜ ê²ƒì„ ë”°ë¦„
        timestamp: trade.timestamp,
        tradeId: trade.tradeId,
      );
    } else {
      // ì‹œê°„ ì°½ì„ ë²—ì–´ë‚˜ë©´, ê¸°ì¡´ ê±°ë˜ëŠ” ë°©ì¶œí•˜ê³  ìƒˆ ê±°ë˜ë¥¼ ëŒ€ê¸°
      _controller.add(existing);
      _pendingTrades[trade.market] = trade;
    }
  }

  /// ëŒ€ê¸° ì¤‘ì¸ ëª¨ë“  ê±°ë˜ë¥¼ ë°©ì¶œ
  void _flush() {
    if (_pendingTrades.isEmpty) return;
    _pendingTrades.values.forEach(_controller.add);
    _pendingTrades.clear();
  }

  void dispose() {
    _flushTimer?.cancel();
    _controller.close();
    log.i('[Aggregator] Disposed.');
  }
}\n\n// ====== lib/data/processors/volume_processor.dart ======\n
\n\n// ====== lib/domain/repositories/trade_repository.dart ======\n
// lib/domain/repositories/trade_repository.dart

import '../entities/trade.dart';

abstract class TradeRepository {
  /// í•„í„°ë§ëœ ì‹¤ì‹œê°„ ì²´ê²° ë¦¬ìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼
  Stream<List<Trade>> watchFilteredTrades(List<String> markets);

  /// ì§‘ê³„ ì²˜ë¦¬ëœ ë‹¨ì¼ ì²´ê²° ìŠ¤íŠ¸ë¦¼
  Stream<Trade> watchAggregatedTrades(List<String> markets);

  /// ì‹¤ì‹œê°„ìœ¼ë¡œ í•„í„° ì„ê³„ê°’ ì—…ë°ì´íŠ¸
  void updateThreshold(double threshold);
  
  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  void dispose();
}\n\n// ====== lib/domain/repositories/volume_repository.dart ======\n
import '../entities/trade.dart';
import '../entities/volume.dart';

/// ì‹œê°„ëŒ€ë³„ ê±°ë˜ëŸ‰ ë°ì´í„°ì˜ ì§‘ê³„ ë° ì œê³µì„ ë‹´ë‹¹í•˜ëŠ” Repository ì¸í„°í˜ì´ìŠ¤
abstract class VolumeRepository {
  /// ì§€ì •ëœ ì‹œê°„ëŒ€ì˜ ê±°ë˜ëŸ‰ ìˆœìœ„ ìŠ¤íŠ¸ë¦¼ì„ ì œê³µí•©ë‹ˆë‹¤.
  Stream<List<Volume>> watchVolumeRanking(TimeFrame timeFrame, List<String> markets);

  /// íŠ¹ì • ì‹œê°„ëŒ€ì˜ ëˆ„ì  ê±°ë˜ëŸ‰ì„ ìˆ˜ë™ìœ¼ë¡œ ë¦¬ì…‹í•©ë‹ˆë‹¤.
  void resetTimeFrame(TimeFrame timeFrame);

  /// ëª¨ë“  ì‹œê°„ëŒ€ì˜ ëˆ„ì  ê±°ë˜ëŸ‰ì„ ìˆ˜ë™ìœ¼ë¡œ ë¦¬ì…‹í•©ë‹ˆë‹¤.
  void resetAllTimeFrames();

  /// ë¦¬ì†ŒìŠ¤ë¥¼ ì •ë¦¬í•©ë‹ˆë‹¤.
  void dispose();
}\n\n// ====== lib/domain/usecases/volume_usecase.dart ======\n
// lib/domain/usecases/volume_usecase.dart

import '../entities/volume.dart';
import '../repositories/volume_repository.dart';

class VolumeUsecase {
  final VolumeRepository _repository;

  VolumeUsecase(this._repository);

  Stream<List<Volume>> watchVolumeRanking(TimeFrame timeFrame, List<String> markets) {
    return _repository.watchVolumeRanking(timeFrame, markets);
  }

  void resetTimeFrame(TimeFrame timeFrame) {
    _repository.resetTimeFrame(timeFrame);
  }

  void resetAllTimeFrames() {
    _repository.resetAllTimeFrames();
  }

  void dispose() {
    _repository.dispose();
  }
}\n\n// ====== lib/domain/usecases/trade_usecase.dart ======\n
// lib/domain/usecases/trade_usecase.dart

import '../entities/trade.dart';
import '../repositories/trade_repository.dart';

class TradeUsecase {
  final TradeRepository _repository;

  TradeUsecase(this._repository);

  Stream<List<Trade>> watchFilteredTrades(List<String> markets) {
    return _repository.watchFilteredTrades(markets);
  }

  Stream<Trade> watchAggregatedTrades(List<String> markets) {
    return _repository.watchAggregatedTrades(markets);
  }
  
  void updateThreshold(double threshold) {
    _repository.updateThreshold(threshold);
  }
  
  void dispose() {
    _repository.dispose();
  }
}\n\n// ====== lib/domain/entities/trade.dart ======\n
import 'package:equatable/equatable.dart';

class Trade extends Equatable {
  /// ì‹¬ë³¼ (e.g., BTCUSDT)
  final String market;

  /// ì²´ê²° ê°€ê²©
  final double price;

  /// ì²´ê²° ìˆ˜ëŸ‰ (API í•„ë“œëª… 'q'ì— ë§ì¶° volume -> quantityë¡œ ë³€ê²½)
  final double quantity;

  /// ì´ ì²´ê²°ì•¡ (price * quantity)
  final double totalValue; // total -> totalValueë¡œ ëª…í™•í™”

  /// ë§¤ìˆ˜ ì²´ê²° ì—¬ë¶€
  final bool isBuy;

  /// ì²´ê²° ì‹œê° (milliseconds from epoch)
  final int timestamp; // timestampMs -> timestampë¡œ ê°„ì†Œí™”

  /// ê±°ë˜ ê³ ìœ  ID (Aggregate trade ID)
  final String tradeId; // id -> tradeIdë¡œ ëª…í™•í™”

  const Trade({
    required this.market,
    required this.price,
    required this.quantity,
    required this.totalValue,
    required this.isBuy,
    required this.timestamp,
    required this.tradeId,
  });

  /// UIì—ì„œ ì‚¬ìš©í•˜ê¸° í¸í•œ DateTime ê°ì²´
  DateTime get dateTime => DateTime.fromMillisecondsSinceEpoch(timestamp);

  /// ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ `aggTrade` ìŠ¤íŠ¸ë¦¼ ë°ì´í„°ë¡œë¶€í„° Trade ê°ì²´ ìƒì„±
  factory Trade.fromBinance(Map<String, dynamic> json) {
    final price = double.parse(json['p'].toString());
    final quantity = double.parse(json['q'].toString());

    return Trade(
      market: json['s'] as String,
      price: price,
      quantity: quantity,
      totalValue: price * quantity,
      isBuy: !(json['m'] as bool), // isBuyerMaker(`m`)ê°€ falseì¼ ë•Œê°€ ë§¤ìˆ˜
      timestamp: json['T'] as int,
      tradeId: json['a'].toString(),
    );
  }

  /// Equatableì„ ìœ„í•œ ì„¤ì •. tradeIdë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê°ì²´ì˜ ë™ë“±ì„±ì„ ë¹„êµí•©ë‹ˆë‹¤.
  @override
  List<Object> get props => [tradeId];
}\n\n// ====== lib/domain/entities/volume.dart ======\n
import 'package:equatable/equatable.dart';

/// ê±°ë˜ëŸ‰ ë°ì´í„°ë¥¼ ì§‘ê³„í•  ì‹œê°„ëŒ€(TimeFrame)ë¥¼ ì •ì˜í•˜ëŠ” Enum
enum TimeFrame {
  min1(1, '1m'),
  min3(3, '3m'),
  min5(5, '5m'),
  min15(15, '15m'),
  min30(30, '30m'),
  hour1(60, '1h'),
  hour2(120, '2h'),
  hour4(240, '4h'),
  hour6(360, '6h'),
  hour12(720, '12h'),
  day1(1440, '1d'),
  week1(10080, '1w');

  const TimeFrame(this.minutes, this.displayName);
  final int minutes;
  final String displayName;

  Duration get duration => Duration(minutes: minutes);
}


/// ë§ˆì¼“ë³„, ì‹œê°„ëŒ€ë³„ ëˆ„ì  ê±°ë˜ëŸ‰ ì •ë³´ë¥¼ ë‹´ëŠ” ë°ì´í„° ëª¨ë¸
class Volume extends Equatable {
  /// ë§ˆì¼“ ì‹¬ë³¼ (e.g., "BTCUSDT")
  final String market;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ëˆ„ì  ê±°ë˜ëŒ€ê¸ˆ (ë‹¨ìœ„: USDT)
  final double totalValue;
  
  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê° (milliseconds from epoch)
  final int lastUpdated;
  
  /// ë°ì´í„° ì§‘ê³„ ê¸°ì¤€ ì‹œê°„ëŒ€
  final TimeFrame timeFrame;
  
  /// í˜„ì¬ ì‹œê°„ëŒ€(ë´‰)ê°€ ì‹œì‘ëœ ì‹œê° (milliseconds from epoch)
  final int timeFrameStart;

  const Volume({
    required this.market,
    required this.totalValue,
    required this.lastUpdated,
    required this.timeFrame,
    required this.timeFrameStart,
  });
  
  /// ì½”ì¸ í‹°ì»¤ë§Œ ì¶”ì¶œ (e.g., "BTCUSDT" -> "BTC")
  String get ticker => market.replaceAll('USDT', '');

  /// í˜„ì¬ ì‹œê°„ëŒ€(ë´‰)ê°€ ëë‚˜ëŠ” ì˜ˆì • ì‹œê°
  DateTime get timeFrameEnd =>
      DateTime.fromMillisecondsSinceEpoch(timeFrameStart).add(timeFrame.duration);

  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ (ì´ˆ)
  int get remainingSeconds {
    final remaining = timeFrameEnd.difference(DateTime.now()).inSeconds;
    return remaining > 0 ? remaining : 0;
  }
  
  @override
  List<Object> get props => [market, timeFrame];
}\n\n// ====== lib/app.dart ======\n
\n\n// ====== lib/presentation/binance_live_page.dart ======\n
\n\n// ====== lib/presentation/controllers/volume_controller.dart ======\n
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/volume_provider.dart';
import '../../domain/entities/volume.dart';
import '../../domain/usecases/volume_usecase.dart';

/// VolumePageì˜ UI ìƒíƒœë¥¼ ë‹´ëŠ” ë¶ˆë³€ í´ë˜ìŠ¤
class VolumeControllerState {
  final bool isTop100;

  const VolumeControllerState({this.isTop100 = false}); // ê¸°ë³¸ê°’ Top 50

  VolumeControllerState copyWith({bool? isTop100}) {
    return VolumeControllerState(isTop100: isTop100 ?? this.isTop100);
  }
}

/// VolumePageì˜ ìƒíƒœì™€ ë¡œì§ì„ ê´€ë¦¬í•˜ëŠ” ì»¨íŠ¸ë¡¤ëŸ¬
class VolumeController extends StateNotifier<VolumeControllerState> {
  final Ref _ref;

  VolumeController(this._ref) : super(const VolumeControllerState());

  // --- UI ìƒíƒœ ë³€ê²½ ë©”ì„œë“œ ---

  /// Top 50ê³¼ Top 100 í‘œì‹œë¥¼ í† ê¸€í•©ë‹ˆë‹¤.
  void toggleTopLimit() {
    state = state.copyWith(isTop100: !state.isTop100);
  }

  /// ì‹œê°„ëŒ€(TimeFrame)ë¥¼ ë³€ê²½í•©ë‹ˆë‹¤.
  void setTimeFrame(TimeFrame newTimeFrame) {
    _ref.read(volumeTimeFrameProvider.notifier).state = newTimeFrame;
  }

  // --- ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ í˜¸ì¶œ ë©”ì„œë“œ ---

  /// í˜„ì¬ ì‹œê°„ëŒ€ì˜ ê±°ë˜ëŸ‰ì„ ë¦¬ì…‹í•©ë‹ˆë‹¤.
  void resetCurrentTimeFrame() {
    final usecase = _ref.read(volumeUsecaseProvider);
    final currentTimeFrame = _ref.read(volumeTimeFrameProvider);
    usecase.resetTimeFrame(currentTimeFrame);
  }

  // --- UIì— í•„ìš”í•œ ë°ì´í„° getter ---

  /// í˜„ì¬ ì„ íƒëœ ì‹œê°„ëŒ€
  TimeFrame get currentTimeFrame => _ref.watch(volumeTimeFrameProvider);
  
  /// ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“  ì‹œê°„ëŒ€ ëª©ë¡
  List<TimeFrame> get availableTimeFrames => TimeFrame.values;
  
  /// í˜„ì¬ í‘œì‹œí•  ëª©ë¡ ê°œìˆ˜ (50 ë˜ëŠ” 100)
  int get currentLimit => state.isTop100 ? 100 : 50;
  
  /// í˜„ì¬ í‘œì‹œ ëª¨ë“œ ì´ë¦„
  String get currentLimitName => state.isTop100 ? 'Top 100' : 'Top 50';
}


/// VolumeControllerë¥¼ ì œê³µí•˜ëŠ” ìµœì¢… Provider
final volumeControllerProvider =
    StateNotifierProvider.autoDispose<VolumeController, VolumeControllerState>((ref) {
  return VolumeController(ref);
});\n\n// ====== lib/presentation/controllers/trade_controller.dart ======\n
// lib/presentation/controllers/trade_controller.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/common/time_frame_types.dart';
import '../../core/di/core_provider.dart';
import '../../domain/entities/trade.dart';

// State í´ë˜ìŠ¤ëŠ” ë³€ê²½ ì—†ìŒ
class TradeControllerState {
  final bool isLoading;
  final String? errorMessage;
  final List<Trade> trades;
  final TradeFilter currentFilter;
  final int selectedFilterIndex;

  TradeControllerState({
    this.isLoading = true,
    this.errorMessage,
    this.trades = const [],
    required this.currentFilter,
    required this.selectedFilterIndex,
  });

  TradeControllerState copyWith({
    bool? isLoading,
    String? errorMessage,
    List<Trade>? trades,
    TradeFilter? currentFilter,
    int? selectedFilterIndex,
  }) {
    return TradeControllerState(
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage,
      trades: trades ?? this.trades,
      currentFilter: currentFilter ?? this.currentFilter,
      selectedFilterIndex: selectedFilterIndex ?? this.selectedFilterIndex,
    );
  }
}

// Controller í´ë˜ìŠ¤ ìˆ˜ì •
class TradeController extends StateNotifier<TradeControllerState> {
  final Ref _ref;
  // âœ… StreamSubscription -> ProviderSubscription ìœ¼ë¡œ ë³€ê²½
  ProviderSubscription? _filteredTradesSub;
  ProviderSubscription? _rawStreamSub;

  TradeController(this._ref)
      : super(TradeControllerState(
          currentFilter: _ref.read(tradeFilterProvider),
          selectedFilterIndex: TradeFilter.values.indexOf(_ref.read(tradeFilterProvider)),
        )) {
    _listenToTrades();
  }

  void _listenToTrades() {
    // raw streamì˜ ë¡œë”©/ì—ëŸ¬ ìƒíƒœë¥¼ ê°ì§€
    _rawStreamSub = _ref.listen<AsyncValue<Trade>>(
      rawTradeStreamProvider,
      (previous, next) {
        if (state.isLoading && !next.isLoading) {
          state = state.copyWith(isLoading: false);
        }
        if (next.hasError) {
          state = state.copyWith(errorMessage: next.error.toString(), isLoading: false);
        }
      },
      fireImmediately: true,
    );

    // í•„í„°ë§ëœ ìµœì¢… ëª©ë¡ì„ êµ¬ë…í•˜ì—¬ UIì— í‘œì‹œí•  tradesë¥¼ ì—…ë°ì´íŠ¸
    _filteredTradesSub = _ref.listen<List<Trade>>(
      filteredTradesProvider, 
      (previous, next) {
        state = state.copyWith(trades: next, isLoading: false);
      },
      fireImmediately: true,
    );
  }

  void setThreshold(TradeFilter newFilter) {
    _ref.read(tradeFilterProvider.notifier).state = newFilter;
    state = state.copyWith(
      currentFilter: newFilter,
      selectedFilterIndex: TradeFilter.values.indexOf(newFilter),
    );
  }

  List<TradeFilter> get availableFilters => TradeFilter.values;
  String get currentFilterDisplayName => state.currentFilter.displayName;

  @override
  void dispose() {
    // âœ… êµ¬ë… ì·¨ì†Œ ë°©ì‹ì„ .close()ë¡œ ë³€ê²½
    _filteredTradesSub?.close();
    _rawStreamSub?.close();
    super.dispose();
  }
}

// Provider ì •ì˜ëŠ” ë³€ê²½ ì—†ìŒ
final tradeControllerProvider =
    StateNotifierProvider.autoDispose<TradeController, TradeControllerState>((ref) {
  return TradeController(ref);
});\n\n// ====== lib/presentation/pages/main_page.dart ======\n
// lib/presentation/pages/main_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../widgets/common_app_bar.dart';
import '../widgets/slide_indicator.dart';
import 'trade_page.dart';
import 'volume_page.dart';

class MainPage extends ConsumerStatefulWidget {
  const MainPage({Key? key}) : super(key: key);

  @override
  ConsumerState<MainPage> createState() => _MainPageState();
}

class _MainPageState extends ConsumerState<MainPage> {
  late PageController _pageController;

  // âœ… ë©”ë‰´ëŠ” 2ê°œë§Œ ì‚¬ìš©
  final List<PageInfo> _pages = const [
    PageInfo('ì²´ê²°', Icons.list_alt_rounded),
    PageInfo('ê±°ë˜ëŸ‰', Icons.bar_chart_rounded),
  ];

  @override
  void initState() {
    super.initState();
    // ì²« í˜ì´ì§€ë¥¼ 'ì²´ê²°'ë¡œ ì„¤ì •
    _pageController = PageController(initialPage: 0);
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: CommonAppBar(
        pages: _pages,
        pageController: _pageController,
      ),
      body: PageView(
        controller: _pageController,
        onPageChanged: (index) {
          // í˜ì´ì§€ ìŠ¤ì™€ì´í”„ ì‹œ, ì¸ë””ì¼€ì´í„°ì˜ ìƒíƒœë„ í•¨ê»˜ ë³€ê²½
          ref.read(selectedTabProvider.notifier).state = index;
        },
        children: const [
          // âœ… í˜ì´ì§€ ìœ„ì ¯ ëª©ë¡
          TradePage(),
          VolumePage(),
        ],
      ),
    );
  }
}\n\n// ====== lib/presentation/pages/trade_page.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// âœ… ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” import ì œê±°
// import '../../core/common/time_frame_types.dart';
// import '../../core/config/app_config.dart';
// import '../../core/di/core_provider.dart';

import '../controllers/trade_controller.dart';
import '../widgets/trade_tile.dart';

class TradePage extends ConsumerWidget {
  const TradePage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(tradeControllerProvider);
    final controller = ref.read(tradeControllerProvider.notifier);

    final slider = _buildFilterSlider(context, controller, state);
    final tradeList = _buildTradeList(context, state);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Binance Futures - Live Trades'),
        elevation: 1,
      ),
      body: Column(
        children: [
          slider,
          const Divider(height: 1),
          Expanded(child: tradeList),
        ],
      ),
    );
  }

  Widget _buildFilterSlider(
    BuildContext context,
    TradeController controller,
    TradeControllerState state,
  ) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 8, 16, 0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Minimum Value: ${state.currentFilter.displayName}',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
          ),
          Slider(
            value: state.selectedFilterIndex.toDouble(),
            min: 0,
            max: (controller.availableFilters.length - 1).toDouble(),
            divisions: controller.availableFilters.length - 1,
            label: state.currentFilter.displayName,
            onChanged: (value) {
              final newFilter = controller.availableFilters[value.round()];
              controller.setThreshold(newFilter);
            },
            onChangeEnd: (_) {
              HapticFeedback.mediumImpact();
            },
          ),
        ],
      ),
    );
  }

  Widget _buildTradeList(BuildContext context, TradeControllerState state) {
    if (state.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }
    if (state.errorMessage != null) {
      return Center(child: Text('Error: ${state.errorMessage}'));
    }
    if (state.trades.isEmpty) {
      return Center(
        child: Text(
          'No trades captured.\n(Threshold: ${state.currentFilter.displayName})',
          textAlign: TextAlign.center,
          style: TextStyle(color: Theme.of(context).hintColor),
        ),
      );
    }
    
    return RawScrollbar(
      thumbVisibility: true,
      trackVisibility: true,
      interactive: true,
      thickness: 8,
      radius: const Radius.circular(4),
      child: ListView.separated(
        padding: const EdgeInsets.symmetric(vertical: 8.0),
        itemCount: state.trades.length,
        itemBuilder: (context, index) {
          return TradeTile(trade: state.trades[index]);
        },
        separatorBuilder: (context, index) => Divider(
          height: 1,
          thickness: 1,
          // âœ… .withOpacity(0.1) -> .withAlpha(25)ë¡œ ìˆ˜ì • (0.1 * 255 = 25.5)
          color: Theme.of(context).dividerColor.withAlpha(25),
          indent: 16,
          endIndent: 16,
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/pages/volume_page.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../core/common/time_frame_types.dart';
import '../../core/di/volume_provider.dart';
import '../../domain/entities/volume.dart';
import '../controllers/volume_controller.dart';
import '../widgets/volume_tile.dart';

class VolumePage extends ConsumerWidget {
  const VolumePage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final volumeDataAsync = ref.watch(volumeDataProvider);
    final uiState = ref.watch(volumeControllerProvider);
    final controller = ref.read(volumeControllerProvider.notifier);
    
    return Column(
      children: [
        // âœ… [ìˆ˜ì •] refë¥¼ ì „ë‹¬í•˜ì—¬ ì˜¤ë¥˜ í•´ê²°
        _buildControls(context, ref, controller, uiState),
        const Divider(height: 1),
        Expanded(
          child: volumeDataAsync.when(
            data: (volumes) => _buildVolumeList(context, volumes, uiState),
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (e, st) => Center(child: Text('Error: $e')),
          ),
        ),
      ],
    );
  }

  Widget _buildControls(BuildContext context, WidgetRef ref, VolumeController controller, VolumeControllerState uiState) {
    final currentTimeFrame = controller.currentTimeFrame;

    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 8, 16, 0),
      child: Column(
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Text(
                'Timeframe: ${currentTimeFrame.displayName}',
                style: Theme.of(context).textTheme.titleSmall?.copyWith(fontWeight: FontWeight.bold),
              ),
              _buildTopLimitToggle(controller, uiState),
              // âœ… [ìˆ˜ì •] refë¥¼ ì „ë‹¬í•˜ì—¬ ì˜¤ë¥˜ í•´ê²°
              _buildCountdownWidget(context, ref),
            ],
          ),
          Slider(
            value: TimeFrame.values.indexOf(currentTimeFrame).toDouble(),
            min: 0,
            max: (controller.availableTimeFrames.length - 1).toDouble(),
            divisions: controller.availableTimeFrames.length - 1,
            label: currentTimeFrame.displayName,
            onChanged: (value) {
              final newTimeFrame = controller.availableTimeFrames[value.round()];
              controller.setTimeFrame(newTimeFrame);
            },
            onChangeEnd: (_) => HapticFeedback.mediumImpact(),
          ),
        ],
      ),
    );
  }

  Widget _buildTopLimitToggle(VolumeController controller, VolumeControllerState uiState) {
    return GestureDetector(
      onTap: () {
        HapticFeedback.lightImpact();
        controller.toggleTopLimit();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        decoration: BoxDecoration(
          // âœ… [ìˆ˜ì •] .withOpacity -> .withAlphaë¡œ ë³€ê²½
          color: uiState.isTop100 ? Colors.orange.withAlpha(51) : Colors.transparent, // 0.2 opacity
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: Colors.orange.withAlpha(179), width: 1.5), // 0.7 opacity
        ),
        child: Text(
          controller.currentLimitName,
          style: const TextStyle(
            fontSize: 12,
            fontWeight: FontWeight.w600,
            color: Colors.orange,
          ),
        ),
      ),
    );
  }

  Widget _buildCountdownWidget(BuildContext context, WidgetRef ref) {
    final volumeData = ref.watch(volumeDataProvider);
    final remainingSeconds = volumeData.when(
      data: (volumes) => volumes.isNotEmpty ? volumes.first.remainingSeconds : 0,
      loading: () => 0,
      error: (_, __) => 0,
    );
    
    final minutes = remainingSeconds ~/ 60;
    final seconds = remainingSeconds % 60;
    final timeStr = '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(Icons.timer_outlined, size: 16, color: Theme.of(context).hintColor),
        const SizedBox(width: 4),
        SizedBox(
          width: 42,
          child: Text(
            timeStr,
            style: const TextStyle(
              fontSize: 14,
              color: Colors.orange,
              fontWeight: FontWeight.bold,
              fontFamily: 'monospace',
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildVolumeList(BuildContext context, List<Volume> volumes, VolumeControllerState uiState) {
    if (volumes.isEmpty) {
      return const Center(child: Text('ê±°ë˜ëŸ‰ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.'));
    }
    
    final limitedList = volumes.take(uiState.isTop100 ? 100 : 50).toList();
    
    return RawScrollbar(
      thumbVisibility: true,
      thickness: 8,
      radius: const Radius.circular(4),
      child: ListView.builder(
        primary: false,
        padding: const EdgeInsets.symmetric(vertical: 4.0, horizontal: 12.0),
        itemCount: limitedList.length,
        itemBuilder: (context, index) => VolumeTile(
          volume: limitedList[index],
          rank: index + 1,
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/widgets/trade_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../domain/entities/trade.dart';

class TradeTile extends ConsumerWidget {
  final Trade trade;

  const TradeTile({Key? key, required this.trade}) : super(key: key);

  static final _timeFormat = DateFormat('HH:mm:ss');
  static final _quantityFormat = NumberFormat('#,##0.###');
  static final _totalFormat = NumberFormat('#,##0');

  String _formatPrice(double price) {
    if (price < 0.01) return price.toStringAsFixed(6);
    if (price < 1) return price.toStringAsFixed(4);
    if (price < 100) return price.toStringAsFixed(2);
    return price.toStringAsFixed(1);
  }

  String _getDisplayName(WidgetRef ref) {
    return trade.market.replaceAll('USDT', '');
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final bool isBuy = trade.isBuy;
    final Color sideColor = isBuy ? Colors.green.shade400 : Colors.red.shade400;

    return Card(
      elevation: 1.5,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 5),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Row(
          children: [
            // âœ… ì‹œê°„ (Flex: 13)
            Expanded(
              flex: 13,
              child: Text(
                _timeFormat.format(trade.dateTime),
                style: theme.textTheme.bodySmall?.copyWith(color: theme.hintColor),
              ),
            ),

            // âœ… í‹°ì»¤ (Flex: 17)
            Expanded(
              flex: 17,
              child: Text(
                _getDisplayName(ref),
                style: theme.textTheme.titleSmall?.copyWith(fontWeight: FontWeight.bold),
                overflow: TextOverflow.ellipsis,
              ),
            ),

            // âœ… ê°€ê²© / ìˆ˜ëŸ‰ (Flex: 20)
            Expanded(
              flex: 20,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    // âœ… ê°€ê²© ì•ì— '$' ê¸°í˜¸ ì¶”ê°€
                    '\$${_formatPrice(trade.price)}',
                    style: theme.textTheme.bodyMedium?.copyWith(fontFamily: 'monospace'),
                  ),
                  const SizedBox(height: 2),
                  Text(
                    _quantityFormat.format(trade.quantity),
                    style: theme.textTheme.bodySmall?.copyWith(color: theme.hintColor),
                  ),
                ],
              ),
            ),

            // âœ… ì´ì•¡ (Flex: 20)
            Expanded(
              flex: 20,
              child: Align(
                alignment: Alignment.centerRight,
                child: Text(
                  // âœ… ì´ì•¡ ì•ì— '$' ê¸°í˜¸ ì¶”ê°€
                  '\$${_totalFormat.format(trade.totalValue)}',
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                    fontFamily: 'monospace',
                    color: sideColor,
                  ),
                ),
              ),
            ),

            // ë°©í–¥ ì•„ì´ì½˜
            Padding(
              padding: const EdgeInsets.only(left: 10.0),
              child: Icon(
                isBuy ? Icons.arrow_upward : Icons.arrow_downward,
                color: sideColor,
                size: 18,
              ),
            ),
          ],
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/widgets/common_app_bar.dart ======\n
// lib/presentation/widgets/common_app_bar.dart
import 'package:flutter/material.dart';
import 'slide_indicator.dart';

class CommonAppBar extends StatelessWidget implements PreferredSizeWidget {
  final List<PageInfo> pages;
  final PageController pageController;

  const CommonAppBar({
    Key? key,
    required this.pages,
    required this.pageController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AppBar(
      elevation: 0.5,
      // AppBar ì¤‘ì•™ì— í˜ì´ì§€ ì „í™˜ ì¸ë””ì¼€ì´í„°ë¥¼ ë°°ì¹˜
      title: SlideIndicator(
        pages: pages,
        pageController: pageController,
      ),
      centerTitle: true,
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}\n\n// ====== lib/presentation/widgets/volume_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import '../../domain/entities/volume.dart';

final Map<String, int> _previousRanks = {};

class VolumeTile extends StatefulWidget {
  final Volume volume;
  final int rank;

  const VolumeTile({
    Key? key,
    required this.volume,
    required this.rank,
  }) : super(key: key);

  @override
  State<VolumeTile> createState() => _VolumeTileState();
}

class _VolumeTileState extends State<VolumeTile> with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<Color?> _colorAnimation;

  static final _volumeFormatter = NumberFormat.compact(locale: 'en_US');

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 750),
      vsync: this,
    );
    _colorAnimation = ColorTween(begin: Colors.transparent, end: Colors.transparent)
        .animate(_animationController);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) _checkRankChange();
    });
  }

  @override
  void didUpdateWidget(VolumeTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.rank != oldWidget.rank) {
      _checkRankChange();
    }
  }

  void _checkRankChange() {
    final previousRank = _previousRanks[widget.volume.market];
    final currentRank = widget.rank;
    
    if (previousRank != null && currentRank < previousRank) {
      _colorAnimation = ColorTween(
        begin: Colors.green.withAlpha(102), // 0.4 opacity
        end: Colors.transparent,
      ).animate(CurvedAnimation(parent: _animationController, curve: Curves.easeOut));
      _animationController.forward(from: 0.0);
    }
    
    _previousRanks[widget.volume.market] = currentRank;
  }
  
  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }
  
  Color _getRankColor(BuildContext context) {
    if (widget.rank <= 3) return Colors.amber.shade600;
    if (widget.rank <= 10) return Theme.of(context).colorScheme.primary;
    // âœ… [ìˆ˜ì •] .withOpacity -> .withAlphaë¡œ ë³€ê²½
    return Theme.of(context).colorScheme.onSurface.withAlpha(179); // 0.7 opacity
  }
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final rankColor = _getRankColor(context);

    return AnimatedBuilder(
      animation: _colorAnimation,
      builder: (context, child) {
        return Container(
          margin: const EdgeInsets.symmetric(vertical: 3.0),
          decoration: BoxDecoration(
            color: _colorAnimation.value,
            borderRadius: BorderRadius.circular(8.0),
          ),
          child: child,
        );
      },
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 14.0),
        child: Row(
          children: [
            Text(
              '${widget.rank}',
              style: theme.textTheme.titleSmall?.copyWith(
                color: rankColor,
                fontWeight: FontWeight.bold,
                fontFamily: 'monospace',
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              flex: 4,
              child: Text(
                widget.volume.ticker,
                style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
                overflow: TextOverflow.ellipsis,
              ),
            ),
            Expanded(
              flex: 5,
              child: Text(
                '\$${_volumeFormatter.format(widget.volume.totalValue)}',
                textAlign: TextAlign.end,
                style: theme.textTheme.bodyLarge?.copyWith(
                  fontFamily: 'monospace',
                  fontWeight: FontWeight.w500,
                  color: theme.colorScheme.onSurface,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/widgets/slide_indicator.dart ======\n
// lib/presentation/widgets/slide_indicator.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// í˜„ì¬ ì„ íƒëœ íƒ­ì˜ ì¸ë±ìŠ¤ë¥¼ ê´€ë¦¬í•˜ëŠ” ê°„ë‹¨í•œ Provider
final selectedTabProvider = StateProvider<int>((ref) => 0);

/// í˜ì´ì§€ ì •ë³´ë¥¼ ë‹´ëŠ” ê°„ë‹¨í•œ í´ë˜ìŠ¤
class PageInfo {
  final String title;
  final IconData icon;
  const PageInfo(this.title, this.icon);
}

class SlideIndicator extends ConsumerWidget {
  final List<PageInfo> pages;
  final PageController pageController;

  const SlideIndicator({
    Key? key,
    required this.pages,
    required this.pageController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentIndex = ref.watch(selectedTabProvider);

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: List.generate(pages.length, (index) {
        final page = pages[index];
        final isSelected = index == currentIndex;
        final color = isSelected ? Theme.of(context).colorScheme.primary : Colors.grey;

        return GestureDetector(
          onTap: () {
            HapticFeedback.lightImpact();
            ref.read(selectedTabProvider.notifier).state = index;
            pageController.animateToPage(
              index,
              duration: const Duration(milliseconds: 300),
              curve: Curves.easeInOut,
            );
          },
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 12.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(page.icon, color: color, size: isSelected ? 24 : 20),
                Text(
                  page.title,
                  style: TextStyle(
                    fontSize: 12,
                    color: color,
                    fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                  ),
                ),
              ],
            ),
          ),
        );
      }),
    );
  }
}