\n\n// ====== lib/core/di/trade_provider.dart ======\n
\n\n// ====== lib/core/di/websocket_provider.dart ======\n
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../network/websocket/base_ws_client.dart';
import '../network/websocket/trade_ws_client.dart';
import '../utils/logger.dart';
import 'core_provider.dart';

@immutable
class WebSocketState {
  final WsStatus status;
  final List<String> subscribedSymbols;
  final DateTime? lastConnectedAt;

  const WebSocketState({
    this.status = WsStatus.disconnected,
    this.subscribedSymbols = const [],
    this.lastConnectedAt,
  });

  WebSocketState copyWith({
    WsStatus? status,
    List<String>? subscribedSymbols,
    DateTime? lastConnectedAt,
  }) {
    return WebSocketState(
      status: status ?? this.status,
      subscribedSymbols: subscribedSymbols ?? this.subscribedSymbols,
      lastConnectedAt: lastConnectedAt ?? this.lastConnectedAt,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
  
    return other is WebSocketState &&
      other.status == status &&
      listEquals(other.subscribedSymbols, subscribedSymbols) &&
      other.lastConnectedAt == lastConnectedAt;
  }

  @override
  int get hashCode => status.hashCode ^ subscribedSymbols.hashCode ^ lastConnectedAt.hashCode;
}

final wsClientProvider = Provider.autoDispose<TradeWsClient>((ref) {
  final client = TradeWsClient();
  ref.onDispose(client.dispose);
  return client;
});

final webSocketManagerProvider =
    StateNotifierProvider.autoDispose<WebSocketManager, WebSocketState>(
  (ref) => WebSocketManager(ref),
);

class WebSocketManager extends StateNotifier<WebSocketState> {
  final Ref _ref;

  WebSocketManager(this._ref) : super(const WebSocketState()) {
    // âœ… ì´ì œ ì´ ì½”ë“œëŠ” ì •ìƒì ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.
    _ref.read(wsClientProvider).onStatusChange = (newStatus) {
      if (state.status != newStatus) {
        state = state.copyWith(
          status: newStatus,
          lastConnectedAt: newStatus == WsStatus.connected ? DateTime.now() : state.lastConnectedAt,
        );
      }
    };
  }

  Future<void> connect() async {
    if (state.status == WsStatus.connecting || state.status == WsStatus.connected) {
      log.w('[WebSocketManager] Already connected or connecting.');
      return;
    }

    state = state.copyWith(status: WsStatus.connecting);

    try {
      final markets = await _ref.read(marketsProvider.future);
      if (markets.isEmpty) {
        throw Exception('Cannot connect without markets.');
      }
      
      _ref.read(wsClientProvider).connect(markets);
      
      state = state.copyWith(subscribedSymbols: markets);
      log.i('[WebSocketManager] Connect command issued with ${markets.length} markets.');

    } catch (e, st) {
      log.e('[WebSocketManager] Connection failed.', e, st);
      state = state.copyWith(status: WsStatus.disconnected);
    }
  }

  void disconnect() {
    log.i('[WebSocketManager] Disconnect command issued.');
    _ref.read(wsClientProvider).dispose();
    state = const WebSocketState(); 
  }
}\n\n// ====== lib/core/di/volume_provider.dart ======\n
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/repositories/volume_repository_impl.dart';
import '../../domain/entities/volume.dart'; // âœ… ëˆ„ë½ëœ import ì¶”ê°€
import '../../domain/repositories/volume_repository.dart';
import '../../domain/usecases/volume_usecase.dart';
import 'core_provider.dart';

// ===================================================================
// 1. Data & Domain Layer Providers
// ===================================================================

final volumeRepositoryProvider = Provider<VolumeRepository>((ref) {
  final remoteDS = ref.watch(tradeRemoteDSProvider); 
  final repo = VolumeRepositoryImpl(remoteDS);
  ref.onDispose(() => repo.dispose());
  return repo;
});

final volumeUsecaseProvider = Provider((ref) {
  final usecase = VolumeUsecase(ref.watch(volumeRepositoryProvider));
  return usecase;
});


// ===================================================================
// 2. UI State & Final Data Provider
// ===================================================================

final volumeTimeFrameProvider = StateProvider<TimeFrame>((ref) => TimeFrame.min5);

final volumeDataProvider = StreamProvider.autoDispose<List<Volume>>((ref) {
  final timeFrame = ref.watch(volumeTimeFrameProvider);
  final marketsAsync = ref.watch(marketsProvider);
  final usecase = ref.read(volumeUsecaseProvider);

  return marketsAsync.when(
    data: (markets) {
      if (markets.isEmpty) return const Stream.empty();
      return usecase.watchVolumeRanking(timeFrame, markets);
    },
    loading: () => const Stream.empty(),
    error: (e, st) => Stream.error(e, st),
  );
});\n\n// ====== lib/core/di/core_provider.dart ======\n
// ===================================================================
// lib/core/providers/trade_providers.dart
// ê¸°ì¡´ êµ¬ì¡° ê¸°ë°˜ - Result íŒ¨í„´ ì ìš©ëœ Providerë“¤
// ===================================================================

import 'dart:async';
import 'dart:collection';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../core/bridge/signal_bus.dart';
import '../../data/datasources/trade_remote_ds.dart';
import '../../data/repositories/trade_repository_impl.dart';
import '../../domain/entities/trade.dart';
import '../../domain/repositories/trade_repository.dart';
import '../common/time_frame_types.dart';
import '../config/app_config.dart';
import '../network/api_client.dart';
import '../utils/logger.dart';
import 'websocket_provider.dart';

// ===================================================================
// 0. Configuration Constants
// ===================================================================

class TradeConfig {
  static const int maxSeenIdsCacheSize = 10000;
  static const int maxTradesPerFilter = 100;
}

// ===================================================================
// 1. Foundational Service & Data Layer Providers
// ===================================================================

/// SignalBus ì¸ìŠ¤í„´ìŠ¤ ì œê³µ (ì‹±ê¸€í†¤)
final signalBusProvider = Provider((ref) {
  final bus = SignalBus();
  ref.onDispose(() => bus.dispose());
  return bus;
});

/// API í´ë¼ì´ì–¸íŠ¸ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤. (Result íŒ¨í„´ ì ìš©)
final apiClientProvider = Provider((ref) {
  final client = ApiClient(
    apiKey: null, // ê³µê°œ APIë§Œ ì‚¬ìš©
    secretKey: null,
  );
  ref.onDispose(() => client.dispose());
  return client;
});

/// SignalBusë¥¼ í¬í•¨í•œ ì›ê²© ë°ì´í„° ì†ŒìŠ¤ ì œê³µ
final tradeRemoteDSProvider = Provider((ref) {
  final ws = ref.watch(wsClientProvider);
  final signalBus = ref.watch(signalBusProvider);
  final ds = TradeRemoteDataSource(ws, signalBus);
  ref.onDispose(() => ds.dispose());
  return ds;
});

/// ê±°ë˜ ë°ì´í„° Repositoryë¥¼ ì œê³µí•©ë‹ˆë‹¤.
final tradeRepositoryProvider = Provider<TradeRepository>((ref) {
  final repo = TradeRepositoryImpl(ref.watch(tradeRemoteDSProvider));
  ref.onDispose(() => repo.dispose());
  return repo;
});

// ===================================================================
// 2. Market Info & Raw Data Stream Providers
// ===================================================================

/// ë°”ì´ë‚¸ìŠ¤ APIì—ì„œ ê±°ë˜ëŸ‰ ìƒìœ„ ì¢…ëª© ëª©ë¡ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
/// Result íŒ¨í„´ ì ìš©ìœ¼ë¡œ ì—ëŸ¬ ì²˜ë¦¬ ê°œì„ 
final marketsProvider = FutureProvider<List<String>>((ref) async {
  log.d('[marketsProvider] Fetching top volume markets from Binance Futures...');
  final client = ref.watch(apiClientProvider);
  
  try {
    // Result íŒ¨í„´ìœ¼ë¡œ API í˜¸ì¶œ
    final result = await client.get(
      '/fapi/v1/ticker/24hr',
      cacheDur: const Duration(minutes: 5), // 5ë¶„ ìºì‹œ
      weight: 40, // ì „ì²´ ticker ì¡°íšŒ weight
    );
    
    return result.when(
      ok: (data) {
        final tickers = data as List<dynamic>;
        
        // USDT í˜ì–´ë§Œ í•„í„°ë§
        tickers.removeWhere((t) => !(t['symbol'] as String).endsWith('USDT'));
        
        // ê±°ë˜ëŸ‰ìœ¼ë¡œ ì •ë ¬
        tickers.sort((a, b) {
          final volumeA = double.tryParse(a['quoteVolume']?.toString() ?? '0') ?? 0;
          final volumeB = double.tryParse(b['quoteVolume']?.toString() ?? '0') ?? 0;
          return volumeB.compareTo(volumeA);
        });

        final markets = tickers
            .map((t) => t['symbol'] as String)
            .take(AppConfig.wsMaxSubscriptions)
            .toList();
                           
        log.i('[marketsProvider] Fetched ${markets.length} markets, sorted by volume.');
        return markets;
      },
      err: (error) {
        log.e('[marketsProvider] API error: $error');
        
        // ì—ëŸ¬ ì‹œ ê¸°ë³¸ ì£¼ìš” ì¢…ëª© ë°˜í™˜
        final fallbackMarkets = [
          'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'ADAUSDT', 'SOLUSDT',
          'XRPUSDT', 'DOTUSDT', 'LINKUSDT', 'LTCUSDT', 'MATICUSDT',
          'AVAXUSDT', 'ATOMUSDT', 'ALGOUSDT', 'VETUSDT', 'ICPUSDT',
        ].take(AppConfig.wsMaxSubscriptions).toList();
        
        log.w('[marketsProvider] Using fallback markets: ${fallbackMarkets.length}');
        return fallbackMarkets;
      },
    );
  } catch (e, st) {
    log.e('[marketsProvider] Unexpected error', e, st);
    
    // ì˜ˆì™¸ ë°œìƒ ì‹œì—ë„ ê¸°ë³¸ê°’ ë°˜í™˜
    return [
      'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'ADAUSDT', 'SOLUSDT',
    ];
  }
});

/// ë§ˆì¼“ ëª©ë¡ì„ ê°€ì ¸ì˜¨ í›„ ì‹¤ì œ êµ¬ë…í•˜ëŠ” í†µí•© ìŠ¤íŠ¸ë¦¼ ì œê³µ
final rawTradeStreamProvider = StreamProvider.autoDispose<Trade>((ref) async* {
  log.d('[rawTradeStreamProvider] Initializing trade stream...');
  
  // 1. ë§ˆì¼“ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
  final marketsAsync = ref.watch(marketsProvider);
  
  yield* marketsAsync.when(
    data: (markets) async* {
      log.i('[rawTradeStreamProvider] Starting stream for ${markets.length} markets');
      
      // 2. TradeRemoteDataSourceì˜ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
      final dataSource = ref.watch(tradeRemoteDSProvider);
      
      try {
        // í•µì‹¬: ë§ˆì¼“ ëª©ë¡ìœ¼ë¡œ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì‹œì‘
        await for (final trade in dataSource.watch(markets)) {
          yield trade;
        }
      } catch (e, st) {
        log.e('[rawTradeStreamProvider] Stream error', e, st);
        rethrow;
      }
    },
    loading: () async* {
      log.d('[rawTradeStreamProvider] Loading markets...');
      // ë¡œë”© ì¤‘ì—ëŠ” ì•„ë¬´ê²ƒë„ emití•˜ì§€ ì•ŠìŒ
    },
    error: (e, st) async* {
      log.e('[rawTradeStreamProvider] Markets fetch error', e, st);
      throw e;
    },
  );
});

/// ìŠ¤íŠ¸ë¦¼ íƒ€ì…ë³„ í•„í„°ë§ëœ ìŠ¤íŠ¸ë¦¼ë“¤
final aggTradeStreamProvider = StreamProvider.autoDispose<Trade>((ref) async* {
  final rawStream = ref.watch(rawTradeStreamProvider.stream);
  await for (final trade in rawStream) {
    if (trade.streamType == BinanceStreamType.aggTrade) {
      yield trade;
    }
  }
});

final tickerStreamProvider = StreamProvider.autoDispose<Trade>((ref) async* {
  final rawStream = ref.watch(rawTradeStreamProvider.stream);
  await for (final trade in rawStream) {
    if (trade.streamType == BinanceStreamType.ticker) {
      yield trade;
    }
  }
});

final bookTickerStreamProvider = StreamProvider.autoDispose<Trade>((ref) async* {
  final rawStream = ref.watch(rawTradeStreamProvider.stream);
  await for (final trade in rawStream) {
    if (trade.streamType == BinanceStreamType.bookTicker) {
      yield trade;
    }
  }
});

/// SignalBus ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼ë“¤
final signalBusAggTradeProvider = StreamProvider.autoDispose((ref) {
  final signalBus = ref.watch(signalBusProvider);
  return signalBus.eventsOfType(BinanceEventType.aggTrade);
});

final signalBusTickerProvider = StreamProvider.autoDispose((ref) {
  final signalBus = ref.watch(signalBusProvider);
  return signalBus.eventsOfType(BinanceEventType.ticker);
});

final signalBusBookTickerProvider = StreamProvider.autoDispose((ref) {
  final signalBus = ref.watch(signalBusProvider);
  return signalBus.eventsOfType(BinanceEventType.bookTicker);
});

// ===================================================================
// 3. Filtered Data & UI State Providers
// ===================================================================

/// UIì—ì„œ ì‚¬ìš©ìê°€ ì„ íƒí•œ ê±°ë˜ëŒ€ê¸ˆ í•„í„° ê°’ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
final tradeFilterProvider = StateProvider<TradeFilter>((ref) => TradeFilter.usdt50k);

/// ìµœì¢…ì ìœ¼ë¡œ í•„í„°ë§ëœ ê±°ë˜ ëª©ë¡ì„ UIì— ì œê³µí•©ë‹ˆë‹¤.
final filteredTradesProvider = Provider.autoDispose<List<Trade>>((ref) {
  final filter = ref.watch(tradeFilterProvider);
  final filteredList = ref.watch(tradeCacheProvider.select((cache) => cache[filter]));
  return filteredList ?? const [];
});

/// ê±°ë˜ ë°ì´í„°ë¥¼ í•„í„°ë³„ë¡œ ìºì‹±í•˜ê³  ê´€ë¦¬í•˜ëŠ” í•µì‹¬ ë¡œì§ (ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì§€ì›)
final tradeCacheProvider = StateNotifierProvider.autoDispose<
    TradeCacheNotifier, Map<TradeFilter, List<Trade>>>((ref) {
  return TradeCacheNotifier(ref);
});

class TradeCacheNotifier extends StateNotifier<Map<TradeFilter, List<Trade>>> {
  final Ref _ref;
  final Queue<String> _seenIds = Queue();
  ProviderSubscription? _sub;

  TradeCacheNotifier(this._ref)
      : super({for (var filter in TradeFilter.values) filter: const []}) {
    
    // ìƒˆë¡œìš´ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
    _sub = _ref.listen<AsyncValue<Trade>>(
      rawTradeStreamProvider,
      (_, next) => next.whenData(_processTrade),
    );
    
    log.d('[TradeCacheNotifier] Initialized with broadcast stream subscription');
  }
  
  void _processTrade(Trade trade) {
    // ë°ì´í„° ê²€ì¦ ì¶”ê°€
    if (!trade.isValidData) {
      log.w('[TradeCacheNotifier] Invalid trade data: ${trade.market}');
      return;
    }
    
    // ì¤‘ë³µ ê±°ë˜ ID ì²´í¬
    if (_seenIds.contains(trade.tradeId)) {
      log.d('[TradeCacheNotifier] Duplicate trade ID: ${trade.tradeId}');
      return;
    }

    _seenIds.addLast(trade.tradeId);
    if (_seenIds.length > TradeConfig.maxSeenIdsCacheSize) {
      _seenIds.removeFirst();
    }
    
    final newState = Map.of(state); 
    bool needsUpdate = false;

    // aggTradeë§Œ í•„í„°ë§ì— ì‚¬ìš© (ticker, bookTickerëŠ” ë³„ë„ ì²˜ë¦¬)
    if (trade.streamType == BinanceStreamType.aggTrade) {
      for (final filter in TradeFilter.values) {
        if (trade.totalValue >= filter.value) {
          final oldList = newState[filter]!;
          final newList = [trade, ...oldList];
          
          newState[filter] = newList.length > TradeConfig.maxTradesPerFilter 
              ? newList.sublist(0, TradeConfig.maxTradesPerFilter) 
              : newList;
              
          needsUpdate = true;
        }
      }
    }
    
    if (needsUpdate) {
      state = newState;
      log.d('[TradeCacheNotifier] Updated cache for ${trade.market} (${trade.streamType.name})');
    }
  }
  
  @override
  void dispose() {
    log.d('[TradeCacheNotifier] Disposing...');
    _sub?.close();
    super.dispose();
  }
}

// ===================================================================
// 4. Statistics & Monitoring Providers
// ===================================================================

/// ì‹¤ì‹œê°„ ì„±ëŠ¥ í†µê³„ ì œê³µ
final tradeStatsProvider = StateNotifierProvider.autoDispose<
    TradeStatsNotifier, Map<String, dynamic>>((ref) {
  return TradeStatsNotifier(ref);
});

class TradeStatsNotifier extends StateNotifier<Map<String, dynamic>> {
  final Ref _ref;
  ProviderSubscription? _sub;
  int _totalMessages = 0;
  int _aggTradeCount = 0;
  int _tickerCount = 0;
  int _bookTickerCount = 0;
  DateTime? _lastMessageTime;
  final DateTime _startTime = DateTime.now();

  TradeStatsNotifier(this._ref) : super({}) {
    _sub = _ref.listen<AsyncValue<Trade>>(
      rawTradeStreamProvider,
      (_, next) => next.whenData(_updateStats),
    );
    _updateState();
  }

  void _updateStats(Trade trade) {
    _totalMessages++;
    _lastMessageTime = DateTime.now();
    
    switch (trade.streamType) {
      case BinanceStreamType.aggTrade:
        _aggTradeCount++;
        break;
      case BinanceStreamType.ticker:
        _tickerCount++;
        break;
      case BinanceStreamType.bookTicker:
        _bookTickerCount++;
        break;
      case BinanceStreamType.depth5:
        // depth5ëŠ” ë³„ë„ ì¹´ìš´í„° ì¶”ê°€ ê°€ëŠ¥
        break;
    }
    
    _updateState();
  }

  void _updateState() {
    final now = DateTime.now();
    final uptime = now.difference(_startTime);
    final messagesPerSecond = uptime.inSeconds > 0 ? _totalMessages / uptime.inSeconds : 0;

    state = {
      'totalMessages': _totalMessages,
      'aggTradeCount': _aggTradeCount,
      'tickerCount': _tickerCount,
      'bookTickerCount': _bookTickerCount,
      'messagesPerSecond': messagesPerSecond.toStringAsFixed(1),
      'uptime': uptime.toString().split('.')[0], // HH:MM:SS í˜•ì‹
      'lastMessageTime': _lastMessageTime?.toIso8601String(),
    };
  }

  @override
  void dispose() {
    _sub?.close();
    super.dispose();
  }
}

/// ë°ì´í„° ì†ŒìŠ¤ ìƒíƒœ ëª¨ë‹ˆí„°ë§
final dataSourceStatusProvider = Provider.autoDispose((ref) {
  final dataSource = ref.watch(tradeRemoteDSProvider);
  return dataSource.getStatus();
});

// ===================================================================
// 5. Additional API Providers (Result íŒ¨í„´ ì ìš©)
// ===================================================================

/// íŠ¹ì • ì‹¬ë³¼ì˜ 24ì‹œê°„ í†µê³„ ì •ë³´
final marketInfoProvider = FutureProvider.family<Map<String, dynamic>?, String>((ref, symbol) async {
  log.d('[marketInfoProvider] Fetching info for $symbol');
  
  final client = ref.watch(apiClientProvider);
  
  try {
    final result = await client.get(
      '/fapi/v1/ticker/24hr',
      query: {'symbol': symbol},
      cacheDur: const Duration(seconds: 30),
      weight: 1,
    );
    
    return result.when(
      ok: (data) {
        log.d('[marketInfoProvider] Got info for $symbol');
        return data as Map<String, dynamic>;
      },
      err: (error) {
        log.e('[marketInfoProvider] Failed to get info for $symbol: $error');
        return null;
      },
    );
    
  } catch (e, stackTrace) {
    log.e('[marketInfoProvider] Error for $symbol', e, stackTrace);
    return null;
  }
});

/// ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ ê±°ë˜ì†Œ ì •ë³´
final exchangeInfoProvider = FutureProvider<Map<String, dynamic>?>((ref) async {
  log.d('[exchangeInfoProvider] Fetching exchange info...');
  
  final client = ref.watch(apiClientProvider);
  
  try {
    final result = await client.get(
      '/fapi/v1/exchangeInfo',
      cacheDur: const Duration(hours: 1),
      weight: 1,
    );
    
    return result.when(
      ok: (data) {
        log.i('[exchangeInfoProvider] Exchange info loaded successfully');
        return data as Map<String, dynamic>;
      },
      err: (error) {
        log.e('[exchangeInfoProvider] Failed to get exchange info: $error');
        return null;
      },
    );
    
  } catch (e, stackTrace) {
    log.e('[exchangeInfoProvider] Error getting exchange info', e, stackTrace);
    return null;
  }
});

/// API í´ë¼ì´ì–¸íŠ¸ ìƒíƒœ ì •ë³´
final apiStatusProvider = Provider.autoDispose<Map<String, dynamic>>((ref) {
  final client = ref.watch(apiClientProvider);
  return client.getStatus();
});

/// Rate limit ì‚¬ìš©ë¥  ì •ë³´
final rateLimitStatusProvider = Provider.autoDispose<Map<String, dynamic>>((ref) {
  final client = ref.watch(apiClientProvider);
  final status = client.getStatus();
  return status['rateLimiter'] as Map<String, dynamic>? ?? {};
});

/// SignalBus ì—ëŸ¬ ìŠ¤íŠ¸ë¦¼
final signalBusErrorProvider = StreamProvider.autoDispose((ref) {
  final signalBus = ref.watch(signalBusProvider);
  return signalBus.errors;
});\n\n// ====== lib/core/config/app_config.dart ======\n
import 'package:flutter_dotenv/flutter_dotenv.dart';
import '../utils/logger.dart';

/// ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼(USDâ“ˆ-M) ì „ìš© ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì •
/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ê³µì‹ WebSocket ë°±ì„œ (2025-01-28) 100% ì¤€ìˆ˜ + ì•± ì•ˆì •ì„± ê³ ë ¤
class AppConfig {
  AppConfig._(); // ì¸ìŠ¤í„´ìŠ¤í™” ë°©ì§€

  // ===================================================================
  // 1. í™˜ê²½ ë³€ìˆ˜ ë° í† ê¸€
  // ===================================================================
  
  /// í…ŒìŠ¤íŠ¸ë„· ì‚¬ìš© ì—¬ë¶€. `dart --define=BINANCE_TESTNET=true`ë¡œ ì»´íŒŒì¼ ì‹œ true.
  static const bool useTestnet = bool.fromEnvironment('BINANCE_TESTNET');
  
  static String apiKey = '';
  static String apiSecret = '';
  
  static Future<void> initialize() async {
    try {
      await dotenv.load();
      apiKey = dotenv.env['BINANCE_API_KEY'] ?? '';
      apiSecret = dotenv.env['BINANCE_API_SECRET'] ?? '';
      log.i('[AppConfig] Initialized. Testnet mode: $useTestnet');
    } catch (e) {
      log.w('[AppConfig] .env not found. Using empty credentials.');
    }
  }

  // ===================================================================
  // 2. ë„¤íŠ¸ì›Œí¬ ì—”ë“œí¬ì¸íŠ¸ (í…ŒìŠ¤íŠ¸ë„·/ë©”ì¸ë„· ìë™ ì „í™˜)
  // ===================================================================
  
  static String get restBaseUrl =>
      useTestnet ? _testnetRestUrl : _mainnetRestUrl;
  static String get streamUrl =>
      useTestnet ? _testnetStreamUrl : _mainnetStreamUrl;

  // ë°”ì´ë‚¸ìŠ¤ ê³µì‹ ì—”ë“œí¬ì¸íŠ¸
  static const String _mainnetRestUrl = 'https://fapi.binance.com';
  static const String _testnetRestUrl = 'https://testnet.binancefuture.com';
  static const String _mainnetStreamUrl = 'wss://fstream.binance.com/stream';
  static const String _testnetStreamUrl = 'wss://stream.binancefuture.com/stream';

  // ì¶”ê°€ WebSocket ì—”ë“œí¬ì¸íŠ¸ ì˜µì…˜
  static const String mainStreamBase = 'wss://stream.binance.com:9443';
  static const String mainStreamAlt = 'wss://stream.binance.com:443';
  static const String dataOnlyStream = 'wss://data-stream.binance.vision';

  // ===================================================================
  // 3. REST API ì„¤ì •
  // ===================================================================
  
  static const Duration restTimeout = Duration(seconds: 30);

  // ===================================================================
  // 4. ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ê³µì‹ WebSocket ì œí•œì‚¬í•­ (ë°±ì„œ ê¸°ì¤€)
  // ===================================================================
  
  /// ğŸš¨ í•µì‹¬: í´ë¼ì´ì–¸íŠ¸â†’ì„œë²„ ë©”ì‹œì§€ ì œí•œ (PING, PONG, JSON ì»¨íŠ¸ë¡¤)
  /// "WebSocket connections have a limit of 5 incoming messages per second"
  static const int wsMaxOutgoingMsgPerSec = 5;
  
  /// ë‹¨ì¼ ì—°ê²°ë‹¹ ìµœëŒ€ ìŠ¤íŠ¸ë¦¼ êµ¬ë… ê°œìˆ˜
  /// "A single connection can listen to a maximum of 1024 streams"
  static const int wsMaxStreams = 1024;
  
  /// IPë‹¹ ì—°ê²° ì œí•œ
  /// "There is a limit of 300 connections per attempt every 5 minutes per IP"
  static const int wsMaxConnectionsPer5Min = 300;
  
  /// 24ì‹œê°„ ì„¸ì…˜ ì œí•œ
  /// "A single connection to stream.binance.com is only valid for 24 hours"
  static const Duration wsMaxSessionDuration = Duration(hours: 24);

  // ===================================================================
  // 5. ğŸ¯ Ping/Pong ì •ì±… (ë°±ì„œ ê¸°ì¤€)
  // ===================================================================
  
  /// ì„œë²„ Ping ê°„ê²©
  /// "The WebSocket server will send a ping frame every 20 seconds"
  static const Duration wsServerPingInterval = Duration(seconds: 20);
  
  /// Pong ì‘ë‹µ íƒ€ì„ì•„ì›ƒ
  /// "If the WebSocket server does not receive a pong frame back from the connection within a minute"
  static const Duration wsPongTimeout = Duration(seconds: 60);
  
  /// Unsolicited Pong ê°„ê²© (ë°”ì´ë‚¸ìŠ¤ ë°±ì„œì—ì„œëŠ” ê¶Œì¥í•˜ì§€ ì•ŠìŒ)
  /// "Unsolicited pong frames are allowed but will not prevent disconnection"
  static const Duration wsUnsolicitedPongInterval = Duration(seconds: 30);

  // ===================================================================
  // 6. ğŸ›¡ï¸ ì•ˆì „ ì„¤ì • (ë°±ì„œ ê¸°ì¤€ + ì•± ì•ˆì •ì„± ê³ ë ¤)
  // ===================================================================
  
  /// ì‹¤ì œ êµ¬ë…í•  ì‹¬ë³¼ ìˆ˜ (1024ë³´ë‹¤ ì ê²Œ - ì•ˆì „ ë²„í¼)
  static const int wsMaxSubscriptions = 200;
  
  /// 24ì‹œê°„ ì „ ë¯¸ë¦¬ ì¬ì—°ê²° (ì„¸ì…˜ ë§Œë£Œ ë°©ì§€)
  static const Duration wsSessionRefresh = Duration(hours: 23);
  
  /// âœ… [ìˆ˜ì •] ì„œë²„â†’í´ë¼ì´ì–¸íŠ¸ ë©”ì‹œì§€ ì œí•œ (ì•± ì•ˆì •ì„± ìš°ì„ )
  /// ë°”ì´ë‚¸ìŠ¤ëŠ” ë¬´ì œí•œì´ì§€ë§Œ, ì•±ì´ ê°ë‹¹í•  ìˆ˜ ìˆëŠ” ìˆ˜ì¤€ìœ¼ë¡œ ì„¤ì •
  static const int wsMaxInMsgPerSec = 500;  // 2000 â†’ 500 (4ë°° ê°ì†Œ)
  
  /// âœ… [ì¶”ê°€] ì‹¬ê°í•œ ìƒí™©ì—ì„œì˜ ê°•ì œ ì œí•œ
  static const int wsEmergencyMsgLimit = 1000;  // ì´ˆë‹¹ 1000ê°œ ë„˜ìœ¼ë©´ ì—°ê²° ëŠê¸°
  
  /// âœ… [ì¶”ê°€] ë©”ì‹œì§€ í­ì£¼ ê°ì§€ ì„ê³„ê°’
  static const int wsMsgFloodThreshold = 800;   // 800ê°œ ë„˜ìœ¼ë©´ ê²½ê³  ë ˆë²¨ ìƒìŠ¹
  
  /// ì»¨íŠ¸ë¡¤ ë©”ì‹œì§€ ì „ì†¡ ê°„ê²© (5ê°œ/ì´ˆ ì œí•œ ì¤€ìˆ˜)
  static const Duration wsControlMsgInterval = Duration(milliseconds: 220); // 200ms + ë²„í¼
  
  /// ì¬ì—°ê²° ì‹œë„ ì œí•œ (IP Ban ë°©ì§€)
  static const int wsMaxReconnectAttempts = 10;
  static const Duration wsReconnectCooldown = Duration(minutes: 5);

  // ===================================================================
  // 7. âœ… [ì¶”ê°€] ìŠ¤íŠ¸ë¦¼ë³„ ë©”ì‹œì§€ ë¹ˆë„ ì œí•œ (ì•± ì•ˆì •ì„±)
  // ===================================================================
  
  /// ìŠ¤íŠ¸ë¦¼ íƒ€ì…ë³„ ì˜ˆìƒ ë©”ì‹œì§€ ë¹ˆë„ (ì´ˆë‹¹)
  static const Map<String, int> streamMessageRates = {
    'ticker': 1,        // 24hr í†µê³„, 1ì´ˆë§ˆë‹¤
    'miniTicker': 1,    // 24hr mini í†µê³„, 1ì´ˆë§ˆë‹¤
    'bookTicker': 10,   // ìµœê³  í˜¸ê°€, ì‹¤ì‹œê°„ (ë¹ ë¦„)
    'aggTrade': 50,     // ì§‘ê³„ ê±°ë˜, ê±°ë˜ëŸ‰ì— ë”°ë¼
    'trade': 100,       // ê°œë³„ ê±°ë˜, ë§¤ìš° ë¹ ë¦„
    'depth5': 10,       // 5ë‹¨ê³„ í˜¸ê°€, 1ì´ˆë§ˆë‹¤
    'depth10': 10,      // 10ë‹¨ê³„ í˜¸ê°€, 1ì´ˆë§ˆë‹¤
    'depth20': 10,      // 20ë‹¨ê³„ í˜¸ê°€, 1ì´ˆë§ˆë‹¤
    'depth': 100,       // ì „ì²´ í˜¸ê°€, ë§¤ìš° ë¹ ë¦„ (ìœ„í—˜)
    'depth@100ms': 500, // 100ms í˜¸ê°€, ê·¹ë„ë¡œ ë¹ ë¦„ (ë§¤ìš° ìœ„í—˜)
    'kline_1s': 1,      // 1ì´ˆ ìº”ë“¤
    'kline_1m': 1,      // 1ë¶„ ìº”ë“¤
    'kline_others': 1,  // ê¸°íƒ€ ìº”ë“¤
  };
  
  /// âœ… [ì¶”ê°€] ìœ„í—˜í•œ ìŠ¤íŠ¸ë¦¼ íƒ€ì…ë“¤ (ë†’ì€ ë©”ì‹œì§€ ë¹ˆë„)
  static const Set<String> highVolumeStreams = {
    'depth',
    'depth@100ms',
    'trade',
    'aggTrade',
  };
  
  /// âœ… [ì¶”ê°€] ì•ˆì „í•œ ìŠ¤íŠ¸ë¦¼ íƒ€ì…ë“¤ (ë‚®ì€ ë©”ì‹œì§€ ë¹ˆë„)
  static const Set<String> safeStreams = {
    'ticker',
    'miniTicker',
    'kline_1m',
    'kline_5m',
    'kline_15m',
    'kline_1h',
  };

  // ===================================================================
  // 8. ğŸ“Š ìŠ¤íŠ¸ë¦¼ë³„ ì—…ë°ì´íŠ¸ ì†ë„ (ë°±ì„œ ê¸°ì¤€)
  // ===================================================================
  
  static const Map<String, String> streamUpdateSpeeds = {
    'aggTrade': 'Real-time',
    'trade': 'Real-time',
    'bookTicker': 'Real-time',
    'miniTicker': '1000ms',
    'ticker': '1000ms',
    'depth': '1000ms',
    'depth@100ms': '100ms',
    'kline_1s': '1000ms',
    'kline_others': '2000ms',
  };

  // ===================================================================
  // 9. ğŸ›ï¸ ì§€ì›ë˜ëŠ” WebSocket ì»¨íŠ¸ë¡¤ ë©”ì„œë“œ
  // ===================================================================
  
  static const List<String> wsSupportedMethods = [
    'SUBSCRIBE',
    'UNSUBSCRIBE',
    'LIST_SUBSCRIPTIONS',
    'SET_PROPERTY',
    'GET_PROPERTY',
  ];

  // ===================================================================
  // 10. âš ï¸ ë°”ì´ë‚¸ìŠ¤ WebSocket ì—ëŸ¬ ì½”ë“œ
  // ===================================================================
  
  static const Map<int, String> wsErrorCodes = {
    0: 'Unknown property',
    1: 'Invalid value type: expected Boolean',
    2: 'Invalid request format',
    3: 'Invalid JSON syntax',
  };

  // ===================================================================
  // 11. âœ… [ì¶”ê°€] ì•± ì•ˆì •ì„±ì„ ìœ„í•œ ìë™ ì œì–´ ì„¤ì •
  // ===================================================================
  
  /// ë©”ì‹œì§€ ê³¼ë¶€í•˜ ì‹œ ìë™ ëŒ€ì‘ í™œì„±í™”
  static const bool enableAutoMessageControl = true;
  
  /// ìœ„í—˜í•œ ìŠ¤íŠ¸ë¦¼ ìë™ ì°¨ë‹¨
  static const bool blockHighVolumeStreams = false;  // ê°œë°œ ë‹¨ê³„ì—ì„œëŠ” false
  
  /// ë©”ì‹œì§€ ì†ë„ë³„ ë¡œê·¸ ë ˆë²¨
  static const Map<int, String> messageRateLogLevels = {
    100: 'debug',   // 100/sec ì´í•˜: ë””ë²„ê·¸
    300: 'info',    // 300/sec ì´í•˜: ì •ë³´
    500: 'warn',    // 500/sec ì´í•˜: ê²½ê³ 
    800: 'error',   // 800/sec ì´í•˜: ì—ëŸ¬
    1000: 'fatal',  // 1000/sec ì´ˆê³¼: ì¹˜ëª…ì 
  };
  
  /// âœ… [ì¶”ê°€] ë¡œê¹… ìµœì í™” (ìŠ¤íŒ¸ ë°©ì§€)
  static const Duration logThrottleInterval = Duration(seconds: 5);  // 5ì´ˆë§ˆë‹¤ í•œ ë²ˆë§Œ ë¡œê·¸
  static const int logBurstLimit = 3;  // ì—°ì† 3ê°œê¹Œì§€ë§Œ í—ˆìš©

  // ===================================================================
  // 12. ğŸ”§ ê³ ê¸‰ ì„¤ì •
  // ===================================================================
  
  /// ë§ˆì´í¬ë¡œì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„ ì‚¬ìš© ì—¬ë¶€
  static const bool useMicrosecondTimestamps = false;
  
  /// Combined ìŠ¤íŠ¸ë¦¼ ì‚¬ìš© (ìš°ë¦¬ê°€ ì‚¬ìš©í•˜ëŠ” ë°©ì‹)
  static const bool useCombinedStreams = true;
  
  /// WebSocket ì—°ê²° ì•ˆì •ì„±ì„ ìœ„í•œ Keep-Alive
  static const Duration wsKeepAliveInterval = Duration(seconds: 45);
  
  /// âœ… [ì¶”ê°€] ë©”ëª¨ë¦¬ ì •ë¦¬ ì£¼ê¸°
  static const Duration memoryCleanupInterval = Duration(seconds: 30);
  
  /// âœ… [ì¶”ê°€] ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ê°„ê²©
  static const Duration performanceMonitorInterval = Duration(seconds: 10);

  // ===================================================================
  // 13. âœ… [ì¶”ê°€] ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œë“¤
  // ===================================================================
  
  /// ìŠ¤íŠ¸ë¦¼ì´ ê³ ìš©ëŸ‰ì¸ì§€ í™•ì¸
  static bool isHighVolumeStream(String streamName) {
    return highVolumeStreams.any((pattern) => streamName.contains(pattern));
  }
  
  /// ìŠ¤íŠ¸ë¦¼ì´ ì•ˆì „í•œì§€ í™•ì¸
  static bool isSafeStream(String streamName) {
    return safeStreams.any((pattern) => streamName.contains(pattern));
  }
  
  /// ë©”ì‹œì§€ ì†ë„ì— ë”°ë¥¸ ë¡œê·¸ ë ˆë²¨ ê²°ì •
  static String getLogLevelForMessageRate(int messagesPerSec) {
    for (final entry in messageRateLogLevels.entries) {
      if (messagesPerSec <= entry.key) {
        return entry.value;
      }
    }
    return 'fatal';
  }
  
  /// ì˜ˆìƒ ë©”ì‹œì§€ ì†ë„ ê³„ì‚°
  static int estimateMessageRate(List<String> streamNames) {
    int totalRate = 0;
    for (final streamName in streamNames) {
      for (final entry in streamMessageRates.entries) {
        if (streamName.contains(entry.key)) {
          totalRate += entry.value;
          break;
        }
      }
    }
    return totalRate;
  }
  
  // ===================================================================
  // 14. âœ… [ì¶”ê°€] TradeAggregator ì„¤ì •
  // ===================================================================
  
  /// ê±°ë˜ ë³‘í•© ì‹œê°„ ì°½ (ë°€ë¦¬ì´ˆ)
  /// aggTrade ìŠ¤íŠ¸ë¦¼ì—ì„œ ì—°ì†ëœ ê±°ë˜ë¥¼ í•˜ë‚˜ë¡œ ë³‘í•©í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ì‹œê°„ ì°½
  static const int mergeWindowMs = 500;
  
  /// ìŠ¤íŠ¸ë¦¼ë³„ ë³‘í•© ì „ëµ ì„¤ì •
  static const Map<String, int> streamMergeWindows = {
    'aggTrade': 500,     // 500ms ì°½ìœ¼ë¡œ ê±°ë˜ ë³‘í•©
    'ticker': 1000,      // 1ì´ˆ ì°½ìœ¼ë¡œ ticker ë°ì´í„° throttling
    'bookTicker': 100,   // 100ms ì°½ìœ¼ë¡œ í˜¸ê°€ ì—…ë°ì´íŠ¸
    'depth5': 100,       // 100ms ì°½ìœ¼ë¡œ í˜¸ê°€ì°½ ì—…ë°ì´íŠ¸
    'depth': 50,         // 50ms ì°½ (ê³ ë¹ˆë„ ë°ì´í„°)
  };
  
  /// Aggregator flush ì£¼ê¸° (ë°€ë¦¬ì´ˆ)
  /// ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ë“¤ì„ ê°•ì œë¡œ ë°©ì¶œí•˜ëŠ” ì£¼ê¸°
  static const int aggregatorFlushIntervalMs = 500;
  
  /// Aggregator ìµœëŒ€ ëŒ€ê¸° ê±°ë˜ ìˆ˜ (ë©”ëª¨ë¦¬ ë³´í˜¸)
  static const int maxPendingTrades = 1000;
  
  /// ê±°ë˜ ë³‘í•© ì‹œ ì‚¬ìš©í•  ê°€ê²© ê³„ì‚° ë°©ì‹
  static const String priceCalculationMethod = 'weightedAverage'; // 'simple', 'weightedAverage', 'last'
  
  /// âœ… [ì¶”ê°€] ìŠ¤íŠ¸ë¦¼ë³„ ì¦‰ì‹œ ì²˜ë¦¬ ì—¬ë¶€
  static const Map<String, bool> streamImmediateProcessing = {
    'aggTrade': false,    // ë³‘í•© í›„ ì²˜ë¦¬
    'ticker': true,       // ì¦‰ì‹œ ì²˜ë¦¬
    'bookTicker': true,   // ì¦‰ì‹œ ì²˜ë¦¬ (í˜¸ê°€ëŠ” ì‹¤ì‹œê°„ì´ ì¤‘ìš”)
    'depth5': true,       // ì¦‰ì‹œ ì²˜ë¦¬
    'depth': false,       // ë³‘í•© í›„ ì²˜ë¦¬ (ë„ˆë¬´ ë¹ ë¦„)
  };
  
  /// âœ… [ì¶”ê°€] ë””ë²„ê·¸ ëª¨ë“œì—ì„œ ë³‘í•© ë¡œê·¸ ì¶œë ¥ ì—¬ë¶€
  static const bool enableMergeLogging = true;
  
  /// âœ… [ì¶”ê°€] ì„±ëŠ¥ í†µê³„ ìˆ˜ì§‘ ì—¬ë¶€
  static const bool enableAggregatorStats = true;

  // ===================================================================
  // 15. âœ… [ì¶”ê°€] TradeAggregator ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œë“¤
  // ===================================================================
  
  /// íŠ¹ì • ìŠ¤íŠ¸ë¦¼ì˜ ë³‘í•© ì°½ ì‹œê°„ ê°€ì ¸ì˜¤ê¸°
  static int getMergeWindowForStream(String streamName) {
    for (final entry in streamMergeWindows.entries) {
      if (streamName.contains(entry.key)) {
        return entry.value;
      }
    }
    return mergeWindowMs; // ê¸°ë³¸ê°’
  }
  
  /// íŠ¹ì • ìŠ¤íŠ¸ë¦¼ì´ ì¦‰ì‹œ ì²˜ë¦¬ë˜ì–´ì•¼ í•˜ëŠ”ì§€ í™•ì¸
  static bool shouldProcessImmediately(String streamName) {
    for (final entry in streamImmediateProcessing.entries) {
      if (streamName.contains(entry.key)) {
        return entry.value;
      }
    }
    return false; // ê¸°ë³¸ê°’: ë³‘í•© í›„ ì²˜ë¦¬
  }
  
  /// ê°€ê²© ê³„ì‚° ë°©ì‹ì— ë”°ë¥¸ ì²˜ë¦¬ ë¡œì§ í™•ì¸
  static bool useWeightedAverage() {
    return priceCalculationMethod == 'weightedAverage';
  }


  /// âœ… [ì¶”ê°€] êµ¬ë… ì•ˆì „ì„± ê²€ì‚¬
  static bool isSafeToSubscribe(List<String> streamNames) {
    final estimatedRate = estimateMessageRate(streamNames);
    final hasHighVolumeStreams = streamNames.any(isHighVolumeStream);
    
    return estimatedRate <= wsMaxInMsgPerSec && 
           (!blockHighVolumeStreams || !hasHighVolumeStreams);
  }
}\n\n// ====== lib/core/bridge/signal_bus.dart ======\n
// ===================================================================
// lib/core/bridge/signal_bus.dart
// ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ ì „ìš© ì´ë²¤íŠ¸ ë²„ìŠ¤ - ì—ëŸ¬ ì²˜ë¦¬ ì¤‘ì‹¬ ì„¤ê³„
// ===================================================================

import 'dart:async';
import 'dart:convert';
import '../event/app_event.dart';
import '../error/app_exception.dart';
import '../extensions/result.dart';

typedef Json = Map<String, dynamic>;

// ===================================================================
// ë°”ì´ë‚¸ìŠ¤ ì´ë²¤íŠ¸ íƒ€ì… ì •ì˜
// ===================================================================

enum BinanceEventType {
  aggTrade('aggTrade'),
  markPrice('markPrice'),
  kline('kline'),
  miniTicker('24hrMiniTicker'),
  ticker('24hrTicker'),
  bookTicker('bookTicker'),
  forceOrder('forceOrder'),
  depthUpdate('depthUpdate'),
  depthPartial('depthPartial'),
  accountUpdate('ACCOUNT_UPDATE'),
  orderUpdate('ORDER_TRADE_UPDATE'),
  accountConfigUpdate('ACCOUNT_CONFIG_UPDATE'),
  unknown('unknown');

  const BinanceEventType(this.value);
  final String value;

  static BinanceEventType fromString(String eventType) {
    for (final type in BinanceEventType.values) {
      if (type.value == eventType) return type;
    }
    return BinanceEventType.unknown;
  }

  static BinanceEventType fromStreamName(String streamName) {
    final lower = streamName.toLowerCase();
    
    if (lower.contains('@aggtrade')) return aggTrade;
    if (lower.contains('@markprice')) return markPrice;
    if (lower.contains('@kline')) return kline;
    if (lower.contains('@miniticker')) return miniTicker;
    if (lower.contains('@ticker')) return ticker;
    if (lower.contains('@bookticker')) return bookTicker;
    if (lower.contains('@forceorder')) return forceOrder;
    if (lower.contains('@depth@')) return depthUpdate;
    if (lower.contains('@depth')) return depthPartial;
    
    return unknown;
  }
}

// ===================================================================
// SignalBus ë©”ì¸ í´ë˜ìŠ¤
// ===================================================================

class SignalBus {
  SignalBus._();
  static final SignalBus _instance = SignalBus._();
  factory SignalBus() => _instance;

  // ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤
  final StreamController<AppEvent> _globalController = 
      StreamController<AppEvent>.broadcast();
  
  final Map<BinanceEventType, StreamController<AppEvent>> _typeControllers = {};
  final Map<String, StreamController<AppEvent>> _symbolControllers = {};
  
  // ì—ëŸ¬ ìŠ¤íŠ¸ë¦¼
  final StreamController<AppException> _errorController = 
      StreamController<AppException>.broadcast();

  // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
  int _messageCount = 0;
  DateTime _lastResetTime = DateTime.now();
  static const int _maxMessagesPerSecond = 1000;

  // ===================================================================
  // ê³µê°œ ìŠ¤íŠ¸ë¦¼ ì ‘ê·¼ì
  // ===================================================================

  Stream<AppEvent> get events => _globalController.stream;
  Stream<AppException> get errors => _errorController.stream;

  Stream<AppEvent> eventsOfType(BinanceEventType type) =>
      _typeControllers.putIfAbsent(type, () =>
          StreamController<AppEvent>.broadcast()).stream;

  Stream<AppEvent> eventsOfSymbol(String symbol) =>
      _symbolControllers.putIfAbsent(symbol.toUpperCase(), () =>
          StreamController<AppEvent>.broadcast()).stream;

  // ===================================================================
  // ë°”ì´ë‚¸ìŠ¤ ì´ë²¤íŠ¸ ë°œìƒ ë©”ì„œë“œë“¤
  // ===================================================================

  void fireAggTrade(Json data) => _fire(BinanceEventType.aggTrade, data);
  void fireMarkPrice(Json data) => _fire(BinanceEventType.markPrice, data);
  void fireKline(Json data) => _fire(BinanceEventType.kline, data);
  void fireMiniTicker(Json data) => _fire(BinanceEventType.miniTicker, data);
  void fireTicker(Json data) => _fire(BinanceEventType.ticker, data);
  void fireBookTicker(Json data) => _fire(BinanceEventType.bookTicker, data);
  void fireDepth5(Json data) => _fire(BinanceEventType.depthPartial, data);
  void fireForceOrder(Json data) => _fire(BinanceEventType.forceOrder, data);
  void fireDepthUpdate(Json data) => _fire(BinanceEventType.depthUpdate, data);
  void fireDepthPartial(Json data) => _fire(BinanceEventType.depthPartial, data);

  // ê¸°ì¡´ í˜¸í™˜ì„±ì„ ìœ„í•œ ì¼ë°˜ trade ì´ë²¤íŠ¸
  void fireTradeEvent(AppEvent event) {
    try {
      if (!_globalController.isClosed) {
        _globalController.add(event);
      }
    } catch (e, stackTrace) {
      _fireError(AppException.business(
        'Failed to fire trade event: $e\nStack: ${stackTrace.toString()}'
      ));
    }
  }

  void fireUserDataUpdate(Json data) {
    final eventType = data['e'] as String?;
    switch (eventType) {
      case 'ACCOUNT_UPDATE':
        _fire(BinanceEventType.accountUpdate, data);
        break;
      case 'ORDER_TRADE_UPDATE':
        _fire(BinanceEventType.orderUpdate, data);
        break;
      case 'ACCOUNT_CONFIG_UPDATE':
        _fire(BinanceEventType.accountConfigUpdate, data);
        break;
      default:
        _fireError(AppException.parsing(
          'Unknown user data event type: $eventType'
        ));
    }
  }

  // ===================================================================
  // ì›¹ì†Œì¼“ ë©”ì‹œì§€ ì²˜ë¦¬
  // ===================================================================

  Result<void, AppException> processWebSocketMessage(String message, {String? streamName}) {
    try {
      if (_shouldDropMessage()) {
        return Err(AppException.business('Message rate limit exceeded'));
      }

      final data = jsonDecode(message) as Json;
      
      // Combined stream ì²˜ë¦¬
      if (data.containsKey('stream') && data.containsKey('data')) {
        final actualStreamName = data['stream'] as String;
        final actualData = data['data'] as Json;
        return _processMessage(actualData, streamName: actualStreamName);
      }
      
      // Raw stream ì²˜ë¦¬
      return _processMessage(data, streamName: streamName);
      
    } catch (e, stackTrace) {
      final exception = AppException.parsing(
        'Failed to parse WebSocket message: $e\nStack: ${stackTrace.toString()}'
      );
      _fireError(exception);
      return Err(exception);
    }
  }

  Result<void, AppException> _processMessage(Json data, {String? streamName}) {
    try {
      final eventType = _determineEventType(data, streamName);
      
      if (eventType == BinanceEventType.unknown) {
        final exception = AppException.parsing(
          'Unknown event type for message'
        );
        _fireError(exception);
        return Err(exception);
      }

      _fire(eventType, data);
      return const Ok(null);
      
    } catch (e, stackTrace) {
      final exception = AppException.business(
        'Failed to process message: $e\nStack: ${stackTrace.toString()}'
      );
      _fireError(exception);
      return Err(exception);
    }
  }

  BinanceEventType _determineEventType(Json data, String? streamName) {
    // 1. ìŠ¤íŠ¸ë¦¼ ì´ë¦„ìœ¼ë¡œ íƒ€ì… ê°ì§€
    if (streamName != null) {
      return BinanceEventType.fromStreamName(streamName);
    }
    
    // 2. ì´ë²¤íŠ¸ íƒ€ì… í•„ë“œë¡œ ê°ì§€
    if (data.containsKey('e')) {
      return BinanceEventType.fromString(data['e'] as String);
    }
    
    // 3. ë°ì´í„° êµ¬ì¡°ë¡œ ì¶”ë¡ 
    return _inferEventTypeFromData(data);
  }

  BinanceEventType _inferEventTypeFromData(Json data) {
    // ì§‘ê³„ ê±°ë˜: a, p, q í•„ë“œ
    if (data.containsKey('a') && data.containsKey('p') && data.containsKey('q')) {
      return BinanceEventType.aggTrade;
    }
    
    // ë§ˆí¬ í”„ë¼ì´ìŠ¤: markPrice ë˜ëŠ” r í•„ë“œ
    if (data.containsKey('markPrice') || data.containsKey('r')) {
      return BinanceEventType.markPrice;
    }
    
    // Kë¼ì¸: k ê°ì²´
    if (data.containsKey('k')) {
      return BinanceEventType.kline;
    }
    
    // ë¶ í‹°ì»¤: b, B, a, A í•„ë“œ
    if (data.containsKey('b') && data.containsKey('B') && 
        data.containsKey('a') && data.containsKey('A')) {
      return BinanceEventType.bookTicker;
    }
    
    // í˜¸ê°€ì°½: bids, asks ë°°ì—´
    if (data.containsKey('bids') && data.containsKey('asks')) {
      return data.containsKey('lastUpdateId') 
          ? BinanceEventType.depthPartial 
          : BinanceEventType.depthUpdate;
    }
    
    return BinanceEventType.unknown;
  }

  // ===================================================================
  // ë‚´ë¶€ ì´ë²¤íŠ¸ ë°œìƒ ë¡œì§
  // ===================================================================

  void _fire(BinanceEventType type, Json data) {
    try {
      final enrichedData = <String, dynamic>{
        ...data,
        'eventType': type.value,
        'platform': 'binance_futures',
      };

      final event = AppEvent.now(enrichedData);
      final symbol = _extractSymbol(data);

      // ê¸€ë¡œë²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
      if (!_globalController.isClosed) {
        _globalController.add(event);
      }

      // íƒ€ì…ë³„ ë¸Œë¡œë“œìºìŠ¤íŠ¸
      final typeCtrl = _typeControllers[type];
      if (typeCtrl != null && !typeCtrl.isClosed) {
        typeCtrl.add(event);
      }

      // ì‹¬ë³¼ë³„ ë¸Œë¡œë“œìºìŠ¤íŠ¸
      if (symbol != null) {
        final symbolCtrl = _symbolControllers[symbol];
        if (symbolCtrl != null && !symbolCtrl.isClosed) {
          symbolCtrl.add(event);
        }
      }

      _messageCount++;
      
    } catch (e, stackTrace) {
      _fireError(AppException.business(
        'Failed to fire event: $e\nStack: ${stackTrace.toString()}'
      ));
    }
  }

  void _fireError(AppException error) {
    if (!_errorController.isClosed) {
      _errorController.add(error);
    }
  }

  String? _extractSymbol(Json data) {
    return data['symbol'] as String? ?? 
           data['s'] as String? ?? 
           data['ps'] as String?;
  }

  bool _shouldDropMessage() {
    final now = DateTime.now();
    if (now.difference(_lastResetTime).inSeconds >= 1) {
      _lastResetTime = now;
      _messageCount = 0;
    }

    return _messageCount > _maxMessagesPerSecond;
  }

  // ===================================================================
  // ìƒíƒœ ê´€ë¦¬ ë° ì •ë¦¬
  // ===================================================================

  int get messageCountPerSecond => _messageCount;
  
  int getListenerCount(BinanceEventType type) {
    return _typeControllers[type]?.hasListener == true ? 1 : 0;
  }

  List<BinanceEventType> getActiveStreams() {
    return _typeControllers.keys
        .where((type) => _typeControllers[type]?.hasListener == true)
        .toList();
  }

  void dispose() {
    // íƒ€ì…ë³„ ì»¨íŠ¸ë¡¤ëŸ¬ ì •ë¦¬
    for (final controller in _typeControllers.values) {
      if (!controller.isClosed) controller.close();
    }
    _typeControllers.clear();

    // ì‹¬ë³¼ë³„ ì»¨íŠ¸ë¡¤ëŸ¬ ì •ë¦¬
    for (final controller in _symbolControllers.values) {
      if (!controller.isClosed) controller.close();
    }
    _symbolControllers.clear();

    // ê¸€ë¡œë²Œ ì»¨íŠ¸ë¡¤ëŸ¬ ì •ë¦¬
    if (!_globalController.isClosed) _globalController.close();
    if (!_errorController.isClosed) _errorController.close();

    _messageCount = 0;
  }
}\n\n// ====== lib/core/network/binance_auth_interceptor.dart ======\n
// lib/core/network/binance_auth_interceptor.dart

import 'dart:convert';
import 'package:crypto/crypto.dart';
import 'package:dio/dio.dart';
import '../config/app_config.dart';

/// ë°”ì´ë‚¸ìŠ¤ API ìš”ì²­ì— HMAC-SHA256 ì‹œê·¸ë‹ˆì²˜ë¥¼ ì¶”ê°€í•˜ëŠ” ì¸í„°ì…‰í„°
class BinanceAuthInterceptor extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    // API í‚¤/ì‹œí¬ë¦¿ì´ í•„ìš”í•œ private ì—”ë“œí¬ì¸íŠ¸ì—ë§Œ ì ìš©
    if (AppConfig.apiKey.isEmpty || AppConfig.apiSecret.isEmpty) {
      return handler.next(options);
    }
    
    // Public APIëŠ” ì‹œê·¸ë‹ˆì²˜ ë¶ˆí•„ìš”
    if (!options.path.contains('/v1/order') && !options.path.contains('/v1/account')) {
        options.headers['X-MBX-APIKEY'] = AppConfig.apiKey;
        return handler.next(options);
    }

    // íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    options.queryParameters['timestamp'] = timestamp;

    // ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜
    final query = Uri(queryParameters: options.queryParameters).query;

    // HMAC-SHA256 ì‹œê·¸ë‹ˆì²˜ ìƒì„±
    final key = utf8.encode(AppConfig.apiSecret);
    final bytes = utf8.encode(query);
    final hmac = Hmac(sha256, key);
    final digest = hmac.convert(bytes);
    
    // ì‹œê·¸ë‹ˆì²˜ë¥¼ ì¿¼ë¦¬ì— ì¶”ê°€
    options.queryParameters['signature'] = digest.toString();
    options.headers['X-MBX-APIKEY'] = AppConfig.apiKey;

    return handler.next(options);
  }
}\n\n// ====== lib/core/network/websocket/clients/kline_ws_client.dart ======\n
\n\n// ====== lib/core/network/websocket/clients/ticker_ws_client.dart ======\n
\n\n// ====== lib/core/network/websocket/clients/trade_ws_client.dart ======\n
\n\n// ====== lib/core/network/websocket/clients/orderbook_ws_client.dart ======\n
\n\n// ====== lib/core/network/websocket/trade_ws_client_total.dart ======\n

// TODO: ì„ì‹œ ë¹„í™œì„±í™”
/*

import 'dart:convert';
import 'dart:math';
import '../../config/app_config.dart';
import '../../../domain/entities/trade.dart';
import '../../utils/logger.dart';
import 'base_ws_client.dart';

/// ğŸš€ ë°”ì´ë‚¸ìŠ¤ Futures í† íƒˆ ì™„ì „ì²´ WebSocket í´ë¼ì´ì–¸íŠ¸
/// 25ê°œ ëª¨ë“  ìŠ¤íŠ¸ë¦¼ íƒ€ì… ì§€ì› + ê³ ë¥´ê²Œ ë¶„ë°° ì „ëµ
class TradeWsClient extends BaseWsClient<Trade> {
  
  /// êµ¬ë…í•  ìŠ¤íŠ¸ë¦¼ êµ¬ì„± ì„¤ì • (í† íƒˆ ì™„ì „ì²´)
  final TotalStreamSubscriptionConfig config;
  final bool enableVerboseLogging;

  TradeWsClient({
    void Function(WsStatus status)? onStatusChange,
    this.enableVerboseLogging = false,
    TotalStreamSubscriptionConfig? config,
  }) : config = config ?? TotalStreamSubscriptionConfig.totalBalanced(),
        super(
          url: AppConfig.streamUrl,
          onStatusChange: onStatusChange,
          pongTimeout: AppConfig.wsPongTimeout,
          encodeSubscribe: (markets) => _encodeSubscribeMessage(markets, config ?? TotalStreamSubscriptionConfig.totalBalanced()),
          decode: (json) => _decodeTradeMessage(json, enableVerboseLogging),
        );

  // ===================================================================
  // ğŸ“¨ í† íƒˆ ë©€í‹° ìŠ¤íŠ¸ë¦¼ êµ¬ë… ë©”ì‹œì§€ ì¸ì½”ë”© (25ê°œ ìŠ¤íŠ¸ë¦¼ ì§€ì›)
  // ===================================================================

  static String _encodeSubscribeMessage(List<String> markets, TotalStreamSubscriptionConfig config) {
    final params = <String>[];
    
    // ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜ ê³„ì‚° ë° ì œí•œ ì²´í¬
    final totalStreams = _calculateTotalStreams(markets.length, config);
    if (totalStreams > AppConfig.wsMaxStreams) {
      throw ArgumentError('Too many streams: $totalStreams. '
          'Binance limit: ${AppConfig.wsMaxStreams} streams per connection.');
    }

    // ===================================================================
    // ğŸ¯ ê±°ë˜ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ë“¤
    // ===================================================================
    
    if (config.aggTradeCount > 0) {
      final symbols = markets.take(config.aggTradeCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@aggTrade'));
      log.i('[TradeWS] ğŸ“ˆ Added ${symbols.length} aggTrade streams');
    }

    if (config.tradeCount > 0) {
      final symbols = markets.take(config.tradeCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@trade'));
      log.i('[TradeWS] ğŸ’± Added ${symbols.length} trade streams');
    }

    // ===================================================================
    // ğŸ“Š 24ì‹œê°„ í†µê³„ ìŠ¤íŠ¸ë¦¼ë“¤
    // ===================================================================
    
    if (config.tickerCount > 0) {
      final symbols = markets.take(config.tickerCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@ticker'));
      log.i('[TradeWS] ğŸ“Š Added ${symbols.length} ticker streams');
    }

    if (config.miniTickerCount > 0) {
      final symbols = markets.take(config.miniTickerCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@miniTicker'));
      log.i('[TradeWS] ğŸ“ˆ Added ${symbols.length} miniTicker streams');
    }

    // ===================================================================
    // ğŸ’° í˜¸ê°€ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ë“¤
    // ===================================================================
    
    if (config.bookTickerCount > 0) {
      final symbols = markets.take(config.bookTickerCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@bookTicker'));
      log.i('[TradeWS] ğŸ’° Added ${symbols.length} bookTicker streams');
    }

    if (config.depth5Count > 0) {
      final symbols = markets.take(config.depth5Count);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@depth5'));
      log.i('[TradeWS] ğŸ“‹ Added ${symbols.length} depth5 streams');
    }

    if (config.depth10Count > 0) {
      final symbols = markets.take(config.depth10Count);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@depth10'));
      log.i('[TradeWS] ğŸ“‹ Added ${symbols.length} depth10 streams');
    }

    if (config.depth20Count > 0) {
      final symbols = markets.take(config.depth20Count);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@depth20'));
      log.i('[TradeWS] ğŸ“‹ Added ${symbols.length} depth20 streams');
    }

    if (config.depthCount > 0) {
      final symbols = markets.take(config.depthCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@depth'));
      log.i('[TradeWS] âš¡ Added ${symbols.length} depth (full) streams');
    }

    if (config.depthSpeedCount > 0) {
      final symbols = markets.take(config.depthSpeedCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@depth@100ms'));
      log.i('[TradeWS] ğŸš¨ Added ${symbols.length} depth@100ms streams (HIGH VOLUME!)');
    }

    // ===================================================================
    // ğŸ•¯ï¸ ìº”ë“¤ìŠ¤í‹± ìŠ¤íŠ¸ë¦¼ë“¤
    // ===================================================================
    
    if (config.klineCount > 0) {
      final symbols = markets.take(config.klineCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@kline_1m')); // ê¸°ë³¸ 1ë¶„ë´‰
      log.i('[TradeWS] ğŸ•¯ï¸ Added ${symbols.length} kline streams');
    }

    if (config.continuousKlineCount > 0) {
      final symbols = markets.take(config.continuousKlineCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}_PERP@continuousKline_1m'));
      log.i('[TradeWS] ğŸ”„ Added ${symbols.length} continuousKline streams');
    }

    // ===================================================================
    // âš¡ Futures ì „ìš© ìŠ¤íŠ¸ë¦¼ë“¤
    // ===================================================================
    
    if (config.markPriceCount > 0) {
      final symbols = markets.take(config.markPriceCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@markPrice'));
      log.i('[TradeWS] âš¡ Added ${symbols.length} markPrice streams');
    }

    if (config.fundingRateCount > 0) {
      final symbols = markets.take(config.fundingRateCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@markPrice@1s')); // 1ì´ˆ ë§ˆí¬ê°€ê²©ìœ¼ë¡œ í€ë”© ì¶”ì 
      log.i('[TradeWS] ğŸ’¸ Added ${symbols.length} fundingRate streams');
    }

    // ===================================================================
    // ğŸš¨ íŠ¹ìˆ˜ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ë“¤
    // ===================================================================
    
    if (config.liquidationCount > 0) {
      final symbols = markets.take(config.liquidationCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@forceOrder'));
      log.i('[TradeWS] ğŸš¨ Added ${symbols.length} liquidation streams');
    }

    if (config.compositeIndexCount > 0) {
      final symbols = markets.take(config.compositeIndexCount);
      params.addAll(symbols.map((s) => '${s.toLowerCase()}@compositeIndex'));
      log.i('[TradeWS] ğŸ“ˆ Added ${symbols.length} compositeIndex streams');
    }

    // ===================================================================
    // ğŸ¯ BLVT ìŠ¤íŠ¸ë¦¼ë“¤
    // ===================================================================
    
    if (config.blvtNavCount > 0) {
      // BLVTëŠ” íŠ¹ë³„í•œ ë„¤ì´ë° (ì˜ˆ: BTCUP, BTCDOWN)
      final blvtSymbols = markets.where((s) => s.endsWith('UP') || s.endsWith('DOWN')).take(config.blvtNavCount);
      params.addAll(blvtSymbols.map((s) => '${s.toLowerCase()}@tokenNav'));
      log.i('[TradeWS] ğŸ¯ Added ${blvtSymbols.length} BLVT NAV streams');
    }

    if (config.blvtKlineCount > 0) {
      final blvtSymbols = markets.where((s) => s.endsWith('UP') || s.endsWith('DOWN')).take(config.blvtKlineCount);
      params.addAll(blvtSymbols.map((s) => '${s.toLowerCase()}@nav_kline_1m'));
      log.i('[TradeWS] ğŸ¯ Added ${blvtSymbols.length} BLVT Kline streams');
    }

    // ===================================================================
    // ğŸŒ ì „ì²´ ì‹œì¥ ìŠ¤íŠ¸ë¦¼ë“¤ (ì‹¬ë³¼ ë¬´ê´€)
    // ===================================================================
    
    if (config.allMarketTickerCount > 0) {
      params.add('!ticker@arr');
      log.i('[TradeWS] ğŸŒ Added all market ticker stream');
    }

    if (config.allMarketMiniCount > 0) {
      params.add('!miniTicker@arr');
      log.i('[TradeWS] ğŸŒ Added all market miniTicker stream');
    }

    if (config.allBookTickerCount > 0) {
      params.add('!bookTicker@arr');
      log.i('[TradeWS] ğŸŒ Added all market bookTicker stream');
    }

    if (config.allMarkPriceCount > 0) {
      params.add('!markPrice@arr');
      log.i('[TradeWS] ğŸŒ Added all market markPrice stream');
    }

    if (config.allLiquidationCount > 0) {
      params.add('!forceOrder@arr');
      log.i('[TradeWS] ğŸŒ Added all market liquidation stream');
    }

    final messageId = _generateUniqueMessageId();
    final subscribeMessage = {
      'method': 'SUBSCRIBE',
      'params': params,
      'id': messageId,
    };

    final jsonMessage = jsonEncode(subscribeMessage);

    log.i('[TradeWS] ğŸš€ ì´ ${params.length}ê°œ ìŠ¤íŠ¸ë¦¼ êµ¬ë… ì™„ë£Œ! (Markets: ${markets.length})');
    log.d('[TradeWS] Subscription message: $jsonMessage');

    return jsonMessage;
  }

  /// ì´ ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜ ê³„ì‚°
  static int _calculateTotalStreams(int marketCount, TotalStreamSubscriptionConfig config) {
    final symbolBasedStreams = [
      config.aggTradeCount,
      config.tradeCount,
      config.tickerCount,
      config.miniTickerCount,
      config.bookTickerCount,
      config.depth5Count,
      config.depth10Count,
      config.depth20Count,
      config.depthCount,
      config.depthSpeedCount,
      config.klineCount,
      config.continuousKlineCount,
      config.markPriceCount,
      config.fundingRateCount,
      config.liquidationCount,
      config.compositeIndexCount,
      config.blvtNavCount,
      config.blvtKlineCount,
    ].map((count) => count > marketCount ? marketCount : count).fold(0, (a, b) => a + b);

    final globalStreams = config.allMarketTickerCount +
                         config.allMarketMiniCount +
                         config.allBookTickerCount +
                         config.allMarkPriceCount +
                         config.allLiquidationCount;

    return symbolBasedStreams + globalStreams;
  }

  /// ë°”ì´ë‚¸ìŠ¤ í˜¸í™˜ ê³ ìœ  ë©”ì‹œì§€ ID ìƒì„±
  static String _generateUniqueMessageId() {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final randomPart = Random().nextInt(99999).toString().padLeft(5, '0');
    return '$timestamp$randomPart';
  }

  // ===================================================================
  // ğŸ“¥ í† íƒˆ ë©€í‹° ìŠ¤íŠ¸ë¦¼ ë©”ì‹œì§€ ë””ì½”ë”© (25ê°œ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬)
  // ===================================================================

  static Trade? _decodeTradeMessage(Map<String, dynamic> json, bool verboseLogging) {
    if (json.isEmpty) {
      if (verboseLogging) log.w('[TradeWS] Empty message received');
      return null;
    }

    // êµ¬ë… í™•ì¸ ë©”ì‹œì§€ ì²˜ë¦¬
    if (json.containsKey('result')) {
      if (json['result'] == null) {
        log.i('[TradeWS] âœ… Subscription confirmed: ${json['id']}');
      } else if (json['result'] is List) {
        final subscriptions = json['result'] as List;
        log.i('[TradeWS] ğŸ“‹ Active subscriptions: ${subscriptions.length}');
        if (verboseLogging) {
          log.d('[TradeWS] Subscriptions: $subscriptions');
        }
      }
      return null;
    }

    // Combined Stream ë©”ì‹œì§€ ì²˜ë¦¬
    if (json.containsKey('stream') && json.containsKey('data')) {
      final streamName = json['stream'] as String?;
      final data = json['data'];

      if (streamName == null || data == null) return null;
      return _parseStreamData(streamName, data, verboseLogging);
    }

    // Direct Stream ë©”ì‹œì§€ ì²˜ë¦¬
    if (json.containsKey('e')) {
      final eventType = json['e'] as String;
      return _parseDirectStreamData(eventType, json, verboseLogging);
    }

    // ì „ì²´ ì‹œì¥ ë°°ì—´ ë°ì´í„° ì²˜ë¦¬
    if (json.containsKey('data') && json['data'] is List) {
      return _parseAllMarketArrayData(json, verboseLogging);
    }

    if (verboseLogging) {
      log.w('[TradeWS] Unknown message type: ${json.keys.join(', ')}');
    }
    return null;
  }

  /// Combined Stream ë°ì´í„° íŒŒì‹± (25ê°œ ìŠ¤íŠ¸ë¦¼ íƒ€ì… ì§€ì›)
  static Trade? _parseStreamData(String streamName, dynamic data, bool verboseLogging) {
    try {
      if (data is! Map<String, dynamic>) return null;

      // ìŠ¤íŠ¸ë¦¼ íƒ€ì… íŒë³„ ë° íŒŒì‹±
      if (streamName.endsWith('@aggTrade')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.aggTrade);
      } else if (streamName.endsWith('@trade')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.trade);
      } else if (streamName.endsWith('@ticker')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.ticker);
      } else if (streamName.endsWith('@miniTicker')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.miniTicker);
      } else if (streamName.endsWith('@bookTicker')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.bookTicker);
      } else if (streamName.endsWith('@depth5')) {
        final symbol = _extractSymbolFromStreamName(streamName);
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.depth5, symbol: symbol, levels: 5);
      } else if (streamName.endsWith('@depth10')) {
        final symbol = _extractSymbolFromStreamName(streamName);
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.depth10, symbol: symbol, levels: 10);
      } else if (streamName.endsWith('@depth20')) {
        final symbol = _extractSymbolFromStreamName(streamName);
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.depth20, symbol: symbol, levels: 20);
      } else if (streamName.endsWith('@depth@100ms')) {
        final symbol = _extractSymbolFromStreamName(streamName);
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.depthSpeed, symbol: symbol);
      } else if (streamName.endsWith('@depth')) {
        final symbol = _extractSymbolFromStreamName(streamName);
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.depth, symbol: symbol);
      } else if (streamName.contains('@kline_')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.kline);
      } else if (streamName.contains('@continuousKline_')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.continuousKline);
      } else if (streamName.endsWith('@markPrice') || streamName.endsWith('@markPrice@1s')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.markPrice);
      } else if (streamName.endsWith('@forceOrder')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.liquidation);
      } else if (streamName.endsWith('@compositeIndex')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.compositeIndex);
      } else if (streamName.endsWith('@tokenNav')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.blvtNav);
      } else if (streamName.contains('@nav_kline_')) {
        return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.blvtKline);
      }

      if (verboseLogging) {
        log.w('[TradeWS] Unsupported stream type: $streamName');
      }
      return null;
    } catch (e, st) {
      log.e('[TradeWS] Stream parsing failed ($streamName)', e, st);
      return null;
    }
  }

  /// Direct Stream ë°ì´í„° íŒŒì‹±
  static Trade? _parseDirectStreamData(String eventType, Map<String, dynamic> data, bool verboseLogging) {
    try {
      switch (eventType) {
        case 'aggTrade':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.aggTrade);
        case 'trade':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.trade);
        case '24hrTicker':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.ticker);
        case '24hrMiniTicker':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.miniTicker);
        case 'kline':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.kline);
        case 'continuous_kline':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.continuousKline);
        case 'markPriceUpdate':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.markPrice);
        case 'forceOrder':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.liquidation);
        case 'compositeIndex':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.compositeIndex);
        case 'nav':
          return Trade.fromBinanceStream(json: data, streamType: BinanceStreamType.blvtNav);
        default:
          if (verboseLogging) {
            log.w('[TradeWS] Unsupported event type: $eventType');
          }
          return null;
      }
    } catch (e, st) {
      log.e('[TradeWS] Direct stream parsing failed ($eventType)', e, st);
      return null;
    }
  }

  /// ì „ì²´ ì‹œì¥ ë°°ì—´ ë°ì´í„° íŒŒì‹± (ì²« ë²ˆì§¸ í•­ëª©ë§Œ ë°˜í™˜)
  static Trade? _parseAllMarketArrayData(Map<String, dynamic> json, bool verboseLogging) {
    try {
      final data = json['data'] as List;
      if (data.isEmpty) return null;

      // ìŠ¤íŠ¸ë¦¼ ì´ë¦„ìœ¼ë¡œ íƒ€ì… íŒë³„
      final stream = json['stream'] as String?;
      if (stream == null) return null;

      BinanceStreamType streamType;
      if (stream.contains('ticker@arr')) {
        streamType = BinanceStreamType.allMarketTicker;
      } else if (stream.contains('miniTicker@arr')) {
        streamType = BinanceStreamType.allMarketMini;
      } else if (stream.contains('bookTicker@arr')) {
        streamType = BinanceStreamType.allBookTicker;
      } else if (stream.contains('markPrice@arr')) {
        streamType = BinanceStreamType.allMarkPrice;
      } else if (stream.contains('forceOrder@arr')) {
        streamType = BinanceStreamType.allLiquidation;
      } else {
        return null;
      }

      // ì²« ë²ˆì§¸ í•­ëª©ë§Œ ë°˜í™˜ (ì „ì²´ ì‹œì¥ ë°ì´í„°ëŠ” ë§¤ìš° í´ ìˆ˜ ìˆìŒ)
      final firstItem = data[0] as Map<String, dynamic>;
      return Trade.fromBinanceStream(json: firstItem, streamType: streamType);
    } catch (e, st) {
      log.e('[TradeWS] All market array parsing failed', e, st);
      return null;
    }
  }

  /// ìŠ¤íŠ¸ë¦¼ ì´ë¦„ì—ì„œ ì‹¬ë³¼ ì¶”ì¶œ
  static String _extractSymbolFromStreamName(String streamName) {
    if (streamName.contains('@')) {
      return streamName.split('@')[0].toUpperCase();
    }
    return 'UNKNOWN';
  }

  // ===================================================================
  // ğŸ“Š ë””ë²„ê·¸ ë° ëª¨ë‹ˆí„°ë§
  // ===================================================================

  /// í˜„ì¬ êµ¬ë… ì„¤ì • ì •ë³´
  Map<String, dynamic> getSubscriptionInfo() {
    return {
      'config': config.toMap(),
      'estimatedStreams': _calculateTotalStreams(100, config), // ê°€ì •: 100ê°œ ë§ˆì¼“
      'estimatedMessageRate': _estimateMessageRate(),
      'verboseLogging': enableVerboseLogging,
      'totalStreamTypes': 25,
      'isSafeConfiguration': config.isSafeConfiguration(),
    };
  }

  /// ì˜ˆìƒ ë©”ì‹œì§€ ì†ë„ ê³„ì‚°
  int _estimateMessageRate() {
    return config.aggTradeCount * 50 +       // aggTrade
           config.tradeCount * 100 +         // trade (ë§¤ìš° ë¹ ë¦„)
           config.tickerCount * 1 +          // ticker
           config.miniTickerCount * 1 +      // miniTicker
           config.bookTickerCount * 10 +     // bookTicker
           config.depth5Count * 10 +         // depth5
           config.depth10Count * 10 +        // depth10
           config.depth20Count * 10 +        // depth20
           config.depthCount * 100 +         // depth (ë¹ ë¦„)
           config.depthSpeedCount * 500 +    // depth@100ms (ë§¤ìš° ë¹ ë¦„)
           config.klineCount * 4 +           // kline
           config.continuousKlineCount * 4 + // continuousKline
           config.markPriceCount * 1 +       // markPrice
           config.fundingRateCount * 1 +     // fundingRate
           config.liquidationCount * 5 +     // liquidation
           config.compositeIndexCount * 1 +  // compositeIndex
           config.blvtNavCount * 1 +         // blvtNav
           config.blvtKlineCount * 4 +       // blvtKline
           config.allMarketTickerCount * 200 +   // ì „ì²´ ì‹œì¥ (ë§ì€ ì‹¬ë³¼)
           config.allMarketMiniCount * 200 +     // ì „ì²´ ì‹œì¥
           config.allBookTickerCount * 2000 +    // ì „ì²´ ì‹œì¥ (ë§¤ìš° ë¹ ë¦„)
           config.allMarkPriceCount * 200 +      // ì „ì²´ ì‹œì¥
           config.allLiquidationCount * 100;     // ì „ì²´ ì‹œì¥
  }
}

// ===================================================================
// ğŸ¯ í† íƒˆ ìŠ¤íŠ¸ë¦¼ êµ¬ë… ì„¤ì • í´ë˜ìŠ¤ (25ê°œ ìŠ¤íŠ¸ë¦¼ ì§€ì›)
// ===================================================================

class TotalStreamSubscriptionConfig {
  // === ê±°ë˜ ë°ì´í„° ===
  final int aggTradeCount;        // ì§‘ê³„ ê±°ë˜
  final int tradeCount;           // ê°œë³„ ê±°ë˜
  
  // === 24ì‹œê°„ í†µê³„ ===
  final int tickerCount;          // 24ì‹œê°„ ì „ì²´ í†µê³„
  final int miniTickerCount;      // 24ì‹œê°„ ê°„ì†Œ í†µê³„
  
  // === í˜¸ê°€ ë°ì´í„° ===
  final int bookTickerCount;      // ìµœê³  í˜¸ê°€
  final int depth5Count;          // 5ë‹¨ê³„ í˜¸ê°€ì°½
  final int depth10Count;         // 10ë‹¨ê³„ í˜¸ê°€ì°½
  final int depth20Count;         // 20ë‹¨ê³„ í˜¸ê°€ì°½
  final int depthCount;           // ì „ì²´ í˜¸ê°€ì°½
  final int depthSpeedCount;      // ê³ ì† í˜¸ê°€ì°½ (100ms)
  
  // === ìº”ë“¤ìŠ¤í‹± ===
  final int klineCount;           // ì¼ë°˜ ìº”ë“¤
  final int continuousKlineCount; // ì—°ì† ê³„ì•½ ìº”ë“¤
  
  // === Futures ì „ìš© ===
  final int markPriceCount;       // ë§ˆí¬ ê°€ê²©
  final int fundingRateCount;     // í€ë”© ë¹„ìœ¨
  
  // === íŠ¹ìˆ˜ ë°ì´í„° ===
  final int liquidationCount;     // ê°•ì œì²­ì‚°
  final int compositeIndexCount;  // ë³µí•© ì§€ìˆ˜
  
  // === BLVT ===
  final int blvtNavCount;         // BLVT NAV
  final int blvtKlineCount;       // BLVT ìº”ë“¤
  
  // === ì „ì²´ ì‹œì¥ ===
  final int allMarketTickerCount;    // ì „ì²´ 24h í†µê³„
  final int allMarketMiniCount;      // ì „ì²´ ê°„ì†Œ í†µê³„
  final int allBookTickerCount;      // ì „ì²´ í˜¸ê°€
  final int allMarkPriceCount;       // ì „ì²´ ë§ˆí¬ê°€ê²©
  final int allLiquidationCount;     // ì „ì²´ ê°•ì œì²­ì‚°

  const TotalStreamSubscriptionConfig({
    this.aggTradeCount = 0,
    this.tradeCount = 0,
    this.tickerCount = 0,
    this.miniTickerCount = 0,
    this.bookTickerCount = 0,
    this.depth5Count = 0,
    this.depth10Count = 0,
    this.depth20Count = 0,
    this.depthCount = 0,
    this.depthSpeedCount = 0,
    this.klineCount = 0,
    this.continuousKlineCount = 0,
    this.markPriceCount = 0,
    this.fundingRateCount = 0,
    this.liquidationCount = 0,
    this.compositeIndexCount = 0,
    this.blvtNavCount = 0,
    this.blvtKlineCount = 0,
    this.allMarketTickerCount = 0,
    this.allMarketMiniCount = 0,
    this.allBookTickerCount = 0,
    this.allMarkPriceCount = 0,
    this.allLiquidationCount = 0,
  });

  /// ğŸš€ í† íƒˆ ë°¸ëŸ°ìŠ¤ ì„¤ì • (745ê°œ ìŠ¤íŠ¸ë¦¼, ê³ ë¥´ê²Œ ë¶„ë°°)
  factory TotalStreamSubscriptionConfig.totalBalanced() {
    return const TotalStreamSubscriptionConfig(
      // === ê±°ë˜ ë°ì´í„° (60ê°œ) ===
      aggTradeCount: 30,       // ì§‘ê³„ ê±°ë˜
      tradeCount: 30,          // ê°œë³„ ê±°ë˜
      
      // === 24ì‹œê°„ í†µê³„ (60ê°œ) ===  
      tickerCount: 30,         // ì „ì²´ í†µê³„
      miniTickerCount: 30,     // ê°„ì†Œ í†µê³„
      
      // === í˜¸ê°€ ë°ì´í„° (120ê°œ) ===
      bookTickerCount: 30,     // ìµœê³  í˜¸ê°€
      depth5Count: 30,         // 5ë‹¨ê³„ í˜¸ê°€
      depth10Count: 30,        // 10ë‹¨ê³„ í˜¸ê°€
      depth20Count: 30,        // 20ë‹¨ê³„ í˜¸ê°€
      
      // === ìº”ë“¤ìŠ¤í‹± (60ê°œ) ===
      klineCount: 30,          // ì¼ë°˜ ìº”ë“¤
      continuousKlineCount: 30, // ì—°ì† ê³„ì•½ ìº”ë“¤
      
      // === Futures ì „ìš© (60ê°œ) ===
      markPriceCount: 30,      // ë§ˆí¬ ê°€ê²©
      fundingRateCount: 30,    // í€ë”© ë¹„ìœ¨
      
      // === íŠ¹ìˆ˜ ë°ì´í„° (60ê°œ) ===
      liquidationCount: 30,    // ê°•ì œì²­ì‚°
      compositeIndexCount: 30, // ë³µí•© ì§€ìˆ˜
      
      // === BLVT (60ê°œ) ===
      blvtNavCount: 30,        // BLVT NAV
      blvtKlineCount: 30,      // BLVT ìº”ë“¤
      
      // === ì „ì²´ ì‹œì¥ (5ê°œ) ===
      allMarketTickerCount: 1,     // ì „ì²´ í‹°ì»¤
      allMarketMiniCount: 1,       // ì „ì²´ ë¯¸ë‹ˆ
      allBookTickerCount: 1,       // ì „ì²´ ë¶í‹°ì»¤
      allMarkPriceCount: 1,        // ì „ì²´ ë§ˆí¬ê°€ê²©
      allLiquidationCount: 1,      // ì „ì²´ ì²­ì‚°
      
      // === ìœ„í—˜ ìŠ¤íŠ¸ë¦¼ (0ê°œ) ===
      depthCount: 0,           // ì „ì²´ í˜¸ê°€ (ë¹ ë¦„)
      depthSpeedCount: 0,      // 100ms í˜¸ê°€ (ë§¤ìš° ìœ„í—˜)
    );
  }

  /// ë³´ìˆ˜ì  ì„¤ì • (ì•ˆì „í•œ ìŠ¤íŠ¸ë¦¼ë“¤ë§Œ)
  factory TotalStreamSubscriptionConfig.conservative() {
    return const TotalStreamSubscriptionConfig(
      aggTradeCount: 20,
      tickerCount: 20,
      bookTickerCount: 20,
      depth5Count: 20,
      markPriceCount: 20,
      klineCount: 10,
      liquidationCount: 10,
      // ìœ„í—˜í•œ ìŠ¤íŠ¸ë¦¼ë“¤ì€ 0
      tradeCount: 0,
      depthCount: 0,
      depthSpeedCount: 0,
      allBookTickerCount: 0,
    );
  }

  /// ê±°ë˜ ì¤‘ì‹¬ ì„¤ì • (íŠ¸ë ˆì´ë”©ìš©)
  factory TotalStreamSubscriptionConfig.tradingFocused() {
    return const TotalStreamSubscriptionConfig(
      aggTradeCount: 50,       // ê±°ë˜ ë°ì´í„° ì¤‘ì‹¬
      bookTickerCount: 50,     // í˜¸ê°€ ë°ì´í„°
      depth5Count: 30,         // í˜¸ê°€ì°½
      markPriceCount: 30,      // ë§ˆí¬ê°€ê²©
      tickerCount: 20,         // ê¸°ë³¸ í†µê³„
      liquidationCount: 20,    // ì²­ì‚° ëª¨ë‹ˆí„°ë§
    );
  }

  /// ë¶„ì„ ì¤‘ì‹¬ ì„¤ì • (ë¦¬ì„œì¹˜ìš©)
  factory TotalStreamSubscriptionConfig.analysisFocused() {
    return const TotalStreamSubscriptionConfig(
      tickerCount: 50,         // í†µê³„ ë°ì´í„°
      klineCount: 50,          // ìº”ë“¤ ë°ì´í„°
      markPriceCount: 30,      // ê°€ê²© ë°ì´í„°
      liquidationCount: 30,    // ì‹œì¥ ë™í–¥
      compositeIndexCount: 20, // ì§€ìˆ˜ ë¶„ì„
      allMarketTickerCount: 1, // ì „ì²´ ì‹œì¥
      allMarkPriceCount: 1,    // ì „ì²´ ë§ˆí¬ê°€ê²©
    );
  }

  /// ê¸°ì¡´ í˜¸í™˜ìš© (aggTradeë§Œ)
  factory TotalStreamSubscriptionConfig.aggTradeOnly(int count) {
    return TotalStreamSubscriptionConfig(aggTradeCount: count);
  }

  /// ì´ ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜
  int get totalCount {
    return aggTradeCount + tradeCount + tickerCount + miniTickerCount +
           bookTickerCount + depth5Count + depth10Count + depth20Count +
           depthCount + depthSpeedCount + klineCount + continuousKlineCount +
           markPriceCount + fundingRateCount + liquidationCount + compositeIndexCount +
           blvtNavCount + blvtKlineCount + allMarketTickerCount + allMarketMiniCount +
           allBookTickerCount + allMarkPriceCount + allLiquidationCount;
  }

  /// ìœ„í—˜í•œ ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜
  int get highVolumeStreamCount {
    return tradeCount + depthCount + depthSpeedCount + allBookTickerCount;
  }

  /// ì•ˆì „í•œ êµ¬ì„±ì¸ì§€ í™•ì¸
  bool isSafeConfiguration() {
    final hasHighVolumeStreams = highVolumeStreamCount > 0;
    final totalStreams = totalCount;
    
    return !hasHighVolumeStreams && 
           totalStreams <= AppConfig.wsMaxStreams * 0.8; // 80% ì´í•˜
  }

  /// ì˜ˆìƒ ë©”ì‹œì§€ ì†ë„ (ê°„ë‹¨ ê³„ì‚°)
  int get estimatedMessageRate {
    return aggTradeCount * 50 + tradeCount * 100 + tickerCount * 1 +
           miniTickerCount * 1 + bookTickerCount * 10 + depth5Count * 10 +
           depth10Count * 10 + depth20Count * 10 + depthCount * 100 +
           depthSpeedCount * 500 + klineCount * 4 + continuousKlineCount * 4 +
           markPriceCount * 1 + fundingRateCount * 1 + liquidationCount * 5 +
           compositeIndexCount * 1 + blvtNavCount * 1 + blvtKlineCount * 4 +
           allMarketTickerCount * 200 + allMarketMiniCount * 200 +
           allBookTickerCount * 2000 + allMarkPriceCount * 200 +
           allLiquidationCount * 100;
  }

  /// ë§µìœ¼ë¡œ ë³€í™˜
  Map<String, dynamic> toMap() {
    return {
      // ê±°ë˜ ë°ì´í„°
      'aggTradeCount': aggTradeCount,
      'tradeCount': tradeCount,
      
      // 24ì‹œê°„ í†µê³„
      'tickerCount': tickerCount,
      'miniTickerCount': miniTickerCount,
      
      // í˜¸ê°€ ë°ì´í„°
      'bookTickerCount': bookTickerCount,
      'depth5Count': depth5Count,
      'depth10Count': depth10Count,
      'depth20Count': depth20Count,
      'depthCount': depthCount,
      'depthSpeedCount': depthSpeedCount,
      
      // ìº”ë“¤ìŠ¤í‹±
      'klineCount': klineCount,
      'continuousKlineCount': continuousKlineCount,
      
      // Futures ì „ìš©
      'markPriceCount': markPriceCount,
      'fundingRateCount': fundingRateCount,
      
      // íŠ¹ìˆ˜ ë°ì´í„°
      'liquidationCount': liquidationCount,
      'compositeIndexCount': compositeIndexCount,
      
      // BLVT
      'blvtNavCount': blvtNavCount,
      'blvtKlineCount': blvtKlineCount,
      
      // ì „ì²´ ì‹œì¥
      'allMarketTickerCount': allMarketTickerCount,
      'allMarketMiniCount': allMarketMiniCount,
      'allBookTickerCount': allBookTickerCount,
      'allMarkPriceCount': allMarkPriceCount,
      'allLiquidationCount': allLiquidationCount,
      
      // ìš”ì•½ ì •ë³´
      'totalCount': totalCount,
      'highVolumeStreamCount': highVolumeStreamCount,
      'estimatedMessageRate': estimatedMessageRate,
      'isSafe': isSafeConfiguration(),
    };
  }

  /// ìŠ¤íŠ¸ë¦¼ ì¹´í…Œê³ ë¦¬ë³„ ê°œìˆ˜
  Map<String, int> getCategoryBreakdown() {
    return {
      'Trade Data': aggTradeCount + tradeCount,
      '24h Statistics': tickerCount + miniTickerCount,
      'Order Book': bookTickerCount + depth5Count + depth10Count + depth20Count + depthCount + depthSpeedCount,
      'Candlestick': klineCount + continuousKlineCount,
      'Futures Price': markPriceCount + fundingRateCount,
      'Special Data': liquidationCount + compositeIndexCount,
      'BLVT': blvtNavCount + blvtKlineCount,
      'All Market': allMarketTickerCount + allMarketMiniCount + allBookTickerCount + allMarkPriceCount + allLiquidationCount,
    };
  }

  @override
  String toString() {
    return 'TotalStreamConfig(ì´ ${totalCount}ê°œ ìŠ¤íŠ¸ë¦¼, ì˜ˆìƒ ${estimatedMessageRate}msg/sec, ì•ˆì „ì„±: ${isSafeConfiguration() ? "ì•ˆì „" : "ì£¼ì˜"})';
  }
}

// ì „ì²´ ì½”ë“œê°€ ì—¬ê¸°ì—...
*/\n\n// ====== lib/core/network/websocket/trade_ws_client.dart ======\n
import 'dart:convert';
import 'dart:math';
import '../../config/app_config.dart';
import '../../../domain/entities/trade.dart';
import '../../utils/logger.dart';
import 'base_ws_client.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ ë©€í‹° ìŠ¤íŠ¸ë¦¼ í´ë¼ì´ì–¸íŠ¸ (ë°±ì„œ 100% ì¤€ìˆ˜)
/// aggTrade + ticker + bookTicker + depth5 í†µí•© ì§€ì›
class TradeWsClient extends BaseWsClient<Trade> {
  
  /// âœ… [ì¶”ê°€] êµ¬ë…í•  ìŠ¤íŠ¸ë¦¼ êµ¬ì„± ì„¤ì •
  final StreamSubscriptionConfig config;
  final bool enableVerboseLogging;

  TradeWsClient({
    void Function(WsStatus status)? onStatusChange,
    this.enableVerboseLogging = false,
    StreamSubscriptionConfig? config,
  }) : config = config ?? StreamSubscriptionConfig.defaultConfig(),
        super(
          url: AppConfig.streamUrl,
          onStatusChange: onStatusChange,
          pongTimeout: AppConfig.wsPongTimeout,
          // âœ… maxStreams, maxMessagesPerSec ì œê±° (AppConfig ê¸°ë³¸ê°’ ìë™ ì‚¬ìš©)
          encodeSubscribe: (markets) => _encodeSubscribeMessage(markets, config ?? StreamSubscriptionConfig.defaultConfig()),
          decode: (json) => _decodeTradeMessage(json, enableVerboseLogging),
        );

  // ===================================================================
  // ğŸ“¨ ê³„ì¸µì  ë©€í‹° ìŠ¤íŠ¸ë¦¼ êµ¬ë… ë©”ì‹œì§€ ì¸ì½”ë”© (ì¤‘ë³µ ë°©ì§€)
  // ===================================================================

  static String _encodeSubscribeMessage(List<String> markets, StreamSubscriptionConfig config) {
    final params = <String>[];
    
    // ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜ ê³„ì‚° ë° ì œí•œ ì²´í¬
    final totalStreams = _calculateTotalStreams(markets.length, config);
    if (totalStreams > AppConfig.wsMaxStreams) {
      throw ArgumentError('Too many streams: $totalStreams. '
          'Binance limit: ${AppConfig.wsMaxStreams} streams per connection.');
    }

    // ===================================================================
    // ğŸ¯ ê³„ì¸µì  êµ¬ë… ì „ëµ (Tiered Subscription)
    // ===================================================================
    
    // ìƒìœ„ ì‹¬ë³¼ë“¤: ëª¨ë“  ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì™„ì „ ë¶„ì„
    final coreSymbols = markets.take(config.aggTradeCount);
    final coreSymbolsList = coreSymbols.toList();
    
    log.i('[TradeWS] ğŸ¯ Core symbols (ì™„ì „ ë¶„ì„): ${coreSymbolsList.length}ê°œ');
    
    // âœ… 1. aggTrade ìŠ¤íŠ¸ë¦¼ (ìƒìœ„ ì‹¬ë³¼ë§Œ - ìƒì„¸ ê±°ë˜ ë°ì´í„°)
    if (config.aggTradeCount > 0) {
      params.addAll(
        coreSymbolsList.map((symbol) => '${symbol.toLowerCase()}@aggTrade'),
      );
      log.i('[TradeWS] ğŸ“ˆ Added ${coreSymbolsList.length} aggTrade streams (Core tier)');
    }

    // âœ… 2. ticker ìŠ¤íŠ¸ë¦¼ (ìƒìœ„ + ì¤‘ìœ„ ì‹¬ë³¼ë“¤)
    if (config.tickerCount > 0) {
      final tickerSymbols = markets.take(config.tickerCount).toList();
      params.addAll(
        tickerSymbols.map((symbol) => '${symbol.toLowerCase()}@ticker'),
      );
      log.i('[TradeWS] ğŸ“Š Added ${tickerSymbols.length} ticker streams (Core + Mid tier)');
    }

    // âœ… 3. bookTicker ìŠ¤íŠ¸ë¦¼ (ìƒìœ„ ì‹¬ë³¼ë§Œ - ì •ë°€ í˜¸ê°€ ë°ì´í„°)
    if (config.bookTickerCount > 0) {
      final bookTickerSymbols = coreSymbolsList.take(config.bookTickerCount).toList();
      params.addAll(
        bookTickerSymbols.map((symbol) => '${symbol.toLowerCase()}@bookTicker'),
      );
      log.i('[TradeWS] ğŸ’° Added ${bookTickerSymbols.length} bookTicker streams (Core tier only)');
    }

    // âœ… 4. depth5 ìŠ¤íŠ¸ë¦¼ (ìƒìœ„ ì‹¬ë³¼ë§Œ - ì„¸ë¶€ í˜¸ê°€ì°½)
    if (config.depth5Count > 0) {
      final depth5Symbols = coreSymbolsList.take(config.depth5Count).toList();
      params.addAll(
        depth5Symbols.map((symbol) => '${symbol.toLowerCase()}@depth5'),
      );
      log.i('[TradeWS] ğŸ“‹ Added ${depth5Symbols.length} depth5 streams (Core tier only)');
    }

    final messageId = _generateUniqueMessageId();
    final subscribeMessage = {
      'method': 'SUBSCRIBE',
      'params': params,
      'id': messageId,
    };

    final jsonMessage = jsonEncode(subscribeMessage);

    log.i('[TradeWS] ğŸ¯ ê³„ì¸µì  êµ¬ë… ì™„ë£Œ - ì´ ${params.length}ê°œ ìŠ¤íŠ¸ë¦¼');
    log.i('[TradeWS] - Core tier (${coreSymbolsList.length}ê°œ): ëª¨ë“  ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì™„ì „ ë¶„ì„');
    log.i('[TradeWS] - Mid tier (${config.tickerCount - coreSymbolsList.length}ê°œ): tickerë¡œ ê¸°ë³¸ ëª¨ë‹ˆí„°ë§');
    log.d('[TradeWS] Subscription message: $jsonMessage');

    return jsonMessage;
  }

  /// ì´ ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜ ê³„ì‚° (ê³„ì¸µì  êµ¬ë… ê³ ë ¤)
  static int _calculateTotalStreams(int marketCount, StreamSubscriptionConfig config) {
    // Core tier: aggTrade ê°œìˆ˜ë§Œí¼ì˜ ì‹¬ë³¼ì´ ëª¨ë“  ìŠ¤íŠ¸ë¦¼ êµ¬ë…
    final coreSymbolCount = config.aggTradeCount > marketCount ? marketCount : config.aggTradeCount;
    final coreStreams = coreSymbolCount * 4; // aggTrade + ticker + bookTicker + depth5
    
    // Mid tier: tickerë§Œ ì¶”ê°€ êµ¬ë… (core tier ì œì™¸)
    final midSymbolCount = (config.tickerCount - coreSymbolCount).clamp(0, marketCount - coreSymbolCount);
    final midStreams = midSymbolCount; // tickerë§Œ
    
    return coreStreams + midStreams;
  }

  /// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ í˜¸í™˜ ê³ ìœ  ë©”ì‹œì§€ ID ìƒì„± (String ë°˜í™˜)
  static String _generateUniqueMessageId() {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final randomPart = Random().nextInt(99999).toString().padLeft(5, '0');
    return '$timestamp$randomPart';
  }

  // ===================================================================
  // ğŸ“¥ ë©€í‹° ìŠ¤íŠ¸ë¦¼ ë©”ì‹œì§€ ë””ì½”ë”© (ë°”ì´ë‚¸ìŠ¤ Combined Stream ì²˜ë¦¬)
  // ===================================================================

  static Trade? _decodeTradeMessage(Map<String, dynamic> json, bool verboseLogging) {
    if (json.isEmpty) {
      if (verboseLogging) log.w('[TradeWS] Empty message received');
      return null;
    }

    // êµ¬ë… í™•ì¸ ë©”ì‹œì§€ ì²˜ë¦¬
    if (json.containsKey('result')) {
      if (json['result'] == null) {
        log.i('[TradeWS] âœ… Subscription confirmed: ${json['id']}');
      } else if (json['result'] is List) {
        final subscriptions = json['result'] as List;
        log.i('[TradeWS] ğŸ“‹ Active subscriptions: ${subscriptions.length}');
        if (verboseLogging) {
          log.d('[TradeWS] Subscriptions: $subscriptions');
        }
      }
      return null;
    }

    // Combined Stream ë©”ì‹œì§€ ì²˜ë¦¬
    if (json.containsKey('stream') && json.containsKey('data')) {
      final streamName = json['stream'] as String?;
      final data = json['data'];

      if (streamName == null || data == null) {
        return null;
      }

      return _parseStreamData(streamName, data, verboseLogging);
    }

    // Direct Stream ë©”ì‹œì§€ ì²˜ë¦¬ (Combined ì•„ë‹Œ ê²½ìš°)
    if (json.containsKey('e')) {
      final eventType = json['e'] as String;
      return _parseDirectStreamData(eventType, json, verboseLogging);
    }

    if (verboseLogging) {
      log.w('[TradeWS] Unknown message type: ${json.keys.join(', ')}');
    }
    return null;
  }

  /// âœ… Combined Stream ë°ì´í„° íŒŒì‹±
  static Trade? _parseStreamData(String streamName, dynamic data, bool verboseLogging) {
    try {
      if (data is! Map<String, dynamic>) {
        return null;
      }

      // ìŠ¤íŠ¸ë¦¼ íƒ€ì… íŒë³„
      if (streamName.endsWith('@aggTrade')) {
        return _parseAggTradeData(data, streamName, verboseLogging);
      } else if (streamName.endsWith('@ticker')) {
        return _parseTickerData(data, streamName, verboseLogging);
      } else if (streamName.endsWith('@bookTicker')) {
        return _parseBookTickerData(data, streamName, verboseLogging);
      } else if (streamName.endsWith('@depth5')) {
        return _parseDepth5Data(data, streamName, verboseLogging);
      }

      if (verboseLogging) {
        log.w('[TradeWS] Unsupported stream type: $streamName');
      }
      return null;
    } catch (e, st) {
      log.e('[TradeWS] Stream parsing failed ($streamName)', e, st);
      return null;
    }
  }

  /// âœ… Direct Stream ë°ì´í„° íŒŒì‹±
  static Trade? _parseDirectStreamData(String eventType, Map<String, dynamic> data, bool verboseLogging) {
    try {
      switch (eventType) {
        case 'aggTrade':
          return _parseAggTradeData(data, 'direct', verboseLogging);
        case '24hrTicker':
          return _parseTickerData(data, 'direct', verboseLogging);
        default:
          if (verboseLogging) {
            log.w('[TradeWS] Unsupported event type: $eventType');
          }
          return null;
      }
    } catch (e, st) {
      log.e('[TradeWS] Direct stream parsing failed ($eventType)', e, st);
      return null;
    }
  }

  /// ğŸ¯ aggTrade ë°ì´í„° íŒŒì‹±
  static Trade? _parseAggTradeData(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    if (data['e'] != 'aggTrade') return null;

    final trade = Trade.fromAggTrade(data);

    if (verboseLogging) {
      final symbol = data['s'] as String? ?? 'UNKNOWN';
      final price = data['p'] as String? ?? '0';
      final quantity = data['q'] as String? ?? '0';
      log.d('[TradeWS] ğŸ’° $symbol: $price Ã— $quantity (aggTrade: $streamInfo)');
    }

    return trade;
  }

  /// âœ… ticker ë°ì´í„° íŒŒì‹±
  static Trade? _parseTickerData(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    if (data['e'] != '24hrTicker') return null;

    final trade = Trade.fromTicker(data);

    if (verboseLogging) {
      final symbol = data['s'] as String? ?? 'UNKNOWN';
      final price = data['c'] as String? ?? '0';
      final change = data['P'] as String? ?? '0';
      log.d('[TradeWS] ğŸ“Š $symbol: $price ($change%) (ticker: $streamInfo)');
    }

    return trade;
  }

  /// âœ… bookTicker ë°ì´í„° íŒŒì‹±
  static Trade? _parseBookTickerData(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    // bookTickerì—ëŠ” 'e' í•„ë“œê°€ ì—†ìŒ
    if (!data.containsKey('u') || !data.containsKey('s')) return null;

    final trade = Trade.fromBookTicker(data);

    if (verboseLogging) {
      final symbol = data['s'] as String? ?? 'UNKNOWN';
      final bidPrice = data['b'] as String? ?? '0';
      final askPrice = data['a'] as String? ?? '0';
      log.d('[TradeWS] ğŸ’° $symbol: bid $bidPrice / ask $askPrice (bookTicker: $streamInfo)');
    }

    return trade;
  }

  /// âœ… depth5 ë°ì´í„° íŒŒì‹±
  static Trade? _parseDepth5Data(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    if (!data.containsKey('bids') || !data.containsKey('asks')) return null;

    // streamInfoì—ì„œ ì‹¬ë³¼ ì¶”ì¶œ
    final symbol = _extractSymbolFromStreamName(streamInfo);
    final trade = Trade.fromDepth5(data, symbol);

    if (verboseLogging) {
      final bids = data['bids'] as List;
      final asks = data['asks'] as List;
      final bestBid = bids.isNotEmpty ? bids[0][0] : '0';
      final bestAsk = asks.isNotEmpty ? asks[0][0] : '0';
      log.d('[TradeWS] ğŸ“‹ $symbol: bid $bestBid / ask $bestAsk (depth5: $streamInfo)');
    }

    return trade;
  }

  /// ìŠ¤íŠ¸ë¦¼ ì´ë¦„ì—ì„œ ì‹¬ë³¼ ì¶”ì¶œ
  static String _extractSymbolFromStreamName(String streamName) {
    if (streamName.contains('@')) {
      return streamName.split('@')[0].toUpperCase();
    }
    return 'UNKNOWN';
  }

  // ===================================================================
  // ğŸ“Š ë””ë²„ê·¸ ë° ëª¨ë‹ˆí„°ë§
  // ===================================================================

  /// í˜„ì¬ êµ¬ë… ì„¤ì • ì •ë³´
  Map<String, dynamic> getSubscriptionInfo() {
    return {
      'config': config.toMap(),
      'estimatedStreams': _calculateTotalStreams(100, config), // ê°€ì •: 100ê°œ ë§ˆì¼“
      'estimatedMessageRate': _estimateMessageRate(),
      'verboseLogging': enableVerboseLogging,
    };
  }

  /// ì˜ˆìƒ ë©”ì‹œì§€ ì†ë„ ê³„ì‚°
  int _estimateMessageRate() {
    return config.aggTradeCount * 50 +    // aggTrade: ~50/ì´ˆ
           config.tickerCount * 1 +       // ticker: ~1/ì´ˆ
           config.bookTickerCount * 10 +  // bookTicker: ~10/ì´ˆ
           config.depth5Count * 10;       // depth5: ~10/ì´ˆ
  }
}

/// âœ… ê³„ì¸µì  ìŠ¤íŠ¸ë¦¼ êµ¬ë… ì„¤ì • í´ë˜ìŠ¤
class StreamSubscriptionConfig {
  final int aggTradeCount;     // Core tier ì‹¬ë³¼ ìˆ˜ (ëª¨ë“  ìŠ¤íŠ¸ë¦¼ êµ¬ë…)
  final int tickerCount;       // Core + Mid tier ì‹¬ë³¼ ìˆ˜ (ticker êµ¬ë…)  
  final int bookTickerCount;   // Core tierì—ì„œ bookTicker êµ¬ë…í•  ì‹¬ë³¼ ìˆ˜
  final int depth5Count;       // Core tierì—ì„œ depth5 êµ¬ë…í•  ì‹¬ë³¼ ìˆ˜

  const StreamSubscriptionConfig({
    this.aggTradeCount = 0,
    this.tickerCount = 0,
    this.bookTickerCount = 0,
    this.depth5Count = 0,
  });

  /// ğŸ¯ ê³„ì¸µì  ê¸°ë³¸ ì„¤ì • (Core 30ê°œ ì™„ì „ë¶„ì„ + Mid 120ê°œ ê¸°ë³¸ëª¨ë‹ˆí„°ë§)
  factory StreamSubscriptionConfig.defaultConfig() {
    return const StreamSubscriptionConfig(
      aggTradeCount: 30,    // Core: ìƒìœ„ 30ê°œ ì‹¬ë³¼ (ëª¨ë“  ìŠ¤íŠ¸ë¦¼)
      tickerCount: 150,     // Core 30ê°œ + Mid 120ê°œ (ticker)
      bookTickerCount: 30,  // Core 30ê°œë§Œ (í˜¸ê°€ ë°ì´í„°)
      depth5Count: 30,      // Core 30ê°œë§Œ (ì„¸ë¶€ í˜¸ê°€)
    );
    // ê²°ê³¼: Core 30ê°œëŠ” 4ê°œ ìŠ¤íŠ¸ë¦¼, Mid 120ê°œëŠ” 1ê°œ ìŠ¤íŠ¸ë¦¼
    // ì´ ìŠ¤íŠ¸ë¦¼: (30 * 4) + (120 * 1) = 240ê°œ
  }

  /// ë³´ìˆ˜ì  ì„¤ì • (Core 20ê°œ + Mid 30ê°œ)
  factory StreamSubscriptionConfig.conservative() {
    return const StreamSubscriptionConfig(
      aggTradeCount: 20,    // Core: ìƒìœ„ 20ê°œë§Œ
      tickerCount: 50,      // Core 20ê°œ + Mid 30ê°œ
      bookTickerCount: 20,  // Core 20ê°œë§Œ
      depth5Count: 20,      // Core 20ê°œë§Œ
    );
    // ì´ ìŠ¤íŠ¸ë¦¼: (20 * 4) + (30 * 1) = 110ê°œ
  }

  /// ì§‘ì¤‘ ë¶„ì„ ì„¤ì • (Core 50ê°œ ì™„ì „ë¶„ì„)
  factory StreamSubscriptionConfig.intensive() {
    return const StreamSubscriptionConfig(
      aggTradeCount: 50,    // Core: ìƒìœ„ 50ê°œ ì‹¬ë³¼
      tickerCount: 100,     // Core 50ê°œ + Mid 50ê°œ
      bookTickerCount: 50,  // Core 50ê°œ ì „ì²´
      depth5Count: 50,      // Core 50ê°œ ì „ì²´  
    );
    // ì´ ìŠ¤íŠ¸ë¦¼: (50 * 4) + (50 * 1) = 250ê°œ
  }

  /// aggTradeë§Œ êµ¬ë… (ê¸°ì¡´ í˜¸í™˜)
  factory StreamSubscriptionConfig.aggTradeOnly(int count) {
    return StreamSubscriptionConfig(
      aggTradeCount: count,
      tickerCount: count,    // aggTradeì™€ ê°™ì€ ì‹¬ë³¼ì— tickerë„ ì¶”ê°€
      bookTickerCount: 0,
      depth5Count: 0,
    );
  }

  /// Core tier ì‹¬ë³¼ ê°œìˆ˜ (ëª¨ë“  ìŠ¤íŠ¸ë¦¼ êµ¬ë…)
  int get coreSymbolCount => aggTradeCount;
  
  /// Mid tier ì‹¬ë³¼ ê°œìˆ˜ (tickerë§Œ êµ¬ë…)
  int get midSymbolCount => (tickerCount - aggTradeCount).clamp(0, double.infinity).toInt();

  /// ì´ êµ¬ë… ì‹¬ë³¼ ê°œìˆ˜
  int get totalSymbolCount => tickerCount;

  /// ì´ ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜ (ê³„ì¸µì  ê³„ì‚°)
  int get totalStreamCount {
    final coreStreams = coreSymbolCount * 4; // 4ê°œ ìŠ¤íŠ¸ë¦¼ì”©
    final midStreams = midSymbolCount * 1;   // 1ê°œ ìŠ¤íŠ¸ë¦¼ì”©
    return coreStreams + midStreams;
  }

  /// ê³„ì¸µë³„ êµ¬ì„± ì •ë³´
  Map<String, dynamic> getTierBreakdown() {
    return {
      'core': {
        'symbolCount': coreSymbolCount,
        'streams': ['aggTrade', 'ticker', 'bookTicker', 'depth5'],
        'streamCount': coreSymbolCount * 4,
        'description': 'ì™„ì „ ë¶„ì„ (ëª¨ë“  ìŠ¤íŠ¸ë¦¼)',
      },
      'mid': {
        'symbolCount': midSymbolCount,
        'streams': ['ticker'],
        'streamCount': midSymbolCount * 1,
        'description': 'ê¸°ë³¸ ëª¨ë‹ˆí„°ë§ (tickerë§Œ)',
      },
    };
  }

  /// ë§µìœ¼ë¡œ ë³€í™˜
  Map<String, dynamic> toMap() {
    return {
      'aggTradeCount': aggTradeCount,
      'tickerCount': tickerCount,
      'bookTickerCount': bookTickerCount,
      'depth5Count': depth5Count,
      'coreSymbolCount': coreSymbolCount,
      'midSymbolCount': midSymbolCount,
      'totalSymbolCount': totalSymbolCount,
      'totalStreamCount': totalStreamCount,
      'tierBreakdown': getTierBreakdown(),
    };
  }

  @override
  String toString() {
    return 'StreamConfig(Core: ${coreSymbolCount}ê°œ ì™„ì „ë¶„ì„, Mid: ${midSymbolCount}ê°œ ê¸°ë³¸ëª¨ë‹ˆí„°ë§, ì´ ${totalStreamCount}ê°œ ìŠ¤íŠ¸ë¦¼)';
  }
}\n\n// ====== lib/core/network/websocket/trade_ws_client copy.dart ======\n
import 'dart:convert';
import 'dart:math';
import '../../config/app_config.dart';
import '../../../domain/entities/trade.dart';
import '../../utils/logger.dart';
import 'base_ws_client.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ ë©€í‹° ìŠ¤íŠ¸ë¦¼ í´ë¼ì´ì–¸íŠ¸ (ë°±ì„œ 100% ì¤€ìˆ˜)
/// aggTrade + ticker + bookTicker + depth5 í†µí•© ì§€ì›
class TradeWsClient extends BaseWsClient<Trade> {
  
  /// âœ… [ì¶”ê°€] êµ¬ë…í•  ìŠ¤íŠ¸ë¦¼ êµ¬ì„± ì„¤ì •
  final StreamSubscriptionConfig config;
  final bool enableVerboseLogging;

  TradeWsClient({
    void Function(WsStatus status)? onStatusChange,
    this.enableVerboseLogging = false,
    StreamSubscriptionConfig? config,
  }) : config = config ?? StreamSubscriptionConfig.defaultConfig(),
        super(
          url: AppConfig.streamUrl,
          onStatusChange: onStatusChange,
          pongTimeout: AppConfig.wsPongTimeout,
          // âœ… maxStreams, maxMessagesPerSec ì œê±° (AppConfig ê¸°ë³¸ê°’ ìë™ ì‚¬ìš©)
          encodeSubscribe: (markets) => _encodeSubscribeMessage(markets, config ?? StreamSubscriptionConfig.defaultConfig()),
          decode: (json) => _decodeTradeMessage(json, enableVerboseLogging),
        );

  // ===================================================================
  // ğŸ“¨ ë©€í‹° ìŠ¤íŠ¸ë¦¼ êµ¬ë… ë©”ì‹œì§€ ì¸ì½”ë”© (ë°”ì´ë‚¸ìŠ¤ ë°±ì„œ ì¤€ìˆ˜)
  // ===================================================================

  static String _encodeSubscribeMessage(List<String> markets, StreamSubscriptionConfig config) {
    final params = <String>[];
    
    // ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜ ê³„ì‚° ë° ì œí•œ ì²´í¬
    final totalStreams = _calculateTotalStreams(markets.length, config);
    if (totalStreams > AppConfig.wsMaxStreams) {
      throw ArgumentError('Too many streams: $totalStreams. '
          'Binance limit: ${AppConfig.wsMaxStreams} streams per connection.');
    }

    // âœ… 1. aggTrade ìŠ¤íŠ¸ë¦¼ (ìƒì„¸ ê±°ë˜ ë°ì´í„°)
    if (config.aggTradeCount > 0) {
      final aggTradeMarkets = markets.take(config.aggTradeCount);
      params.addAll(
        aggTradeMarkets.map((symbol) => '${symbol.toLowerCase()}@aggTrade'),
      );
      log.i('[TradeWS] ğŸ“ˆ Added ${aggTradeMarkets.length} aggTrade streams');
    }

    // âœ… 2. ticker ìŠ¤íŠ¸ë¦¼ (24ì‹œê°„ í†µê³„)
    if (config.tickerCount > 0) {
      final tickerMarkets = markets.take(config.tickerCount);
      params.addAll(
        tickerMarkets.map((symbol) => '${symbol.toLowerCase()}@ticker'),
      );
      log.i('[TradeWS] ğŸ“Š Added ${tickerMarkets.length} ticker streams');
    }

    // âœ… 3. bookTicker ìŠ¤íŠ¸ë¦¼ (ìµœê³  í˜¸ê°€)
    if (config.bookTickerCount > 0) {
      final bookTickerMarkets = markets.take(config.bookTickerCount);
      params.addAll(
        bookTickerMarkets.map((symbol) => '${symbol.toLowerCase()}@bookTicker'),
      );
      log.i('[TradeWS] ğŸ’° Added ${bookTickerMarkets.length} bookTicker streams');
    }

    // âœ… 4. depth5 ìŠ¤íŠ¸ë¦¼ (5ë‹¨ê³„ í˜¸ê°€ì°½)
    if (config.depth5Count > 0) {
      final depth5Markets = markets.take(config.depth5Count);
      params.addAll(
        depth5Markets.map((symbol) => '${symbol.toLowerCase()}@depth5'),
      );
      log.i('[TradeWS] ğŸ“‹ Added ${depth5Markets.length} depth5 streams');
    }

    final messageId = _generateUniqueMessageId();
    final subscribeMessage = {
      'method': 'SUBSCRIBE',
      'params': params,
      'id': messageId,
    };

    final jsonMessage = jsonEncode(subscribeMessage);

    log.i('[TradeWS] ğŸ¯ ì´ ${params.length}ê°œ ìŠ¤íŠ¸ë¦¼ êµ¬ë… (Markets: ${markets.length})');
    log.d('[TradeWS] Subscription message: $jsonMessage');

    return jsonMessage;
  }

  /// ì´ ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜ ê³„ì‚°
  static int _calculateTotalStreams(int marketCount, StreamSubscriptionConfig config) {
    return [
      config.aggTradeCount,
      config.tickerCount,
      config.bookTickerCount,
      config.depth5Count,
    ].map((count) => count > marketCount ? marketCount : count).fold(0, (a, b) => a + b);
  }

  /// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ í˜¸í™˜ ê³ ìœ  ë©”ì‹œì§€ ID ìƒì„± (String ë°˜í™˜)
  static String _generateUniqueMessageId() {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final randomPart = Random().nextInt(99999).toString().padLeft(5, '0');
    return '$timestamp$randomPart';
  }

  // ===================================================================
  // ğŸ“¥ ë©€í‹° ìŠ¤íŠ¸ë¦¼ ë©”ì‹œì§€ ë””ì½”ë”© (ë°”ì´ë‚¸ìŠ¤ Combined Stream ì²˜ë¦¬)
  // ===================================================================

  static Trade? _decodeTradeMessage(Map<String, dynamic> json, bool verboseLogging) {
    if (json.isEmpty) {
      if (verboseLogging) log.w('[TradeWS] Empty message received');
      return null;
    }

    // êµ¬ë… í™•ì¸ ë©”ì‹œì§€ ì²˜ë¦¬
    if (json.containsKey('result')) {
      if (json['result'] == null) {
        log.i('[TradeWS] âœ… Subscription confirmed: ${json['id']}');
      } else if (json['result'] is List) {
        final subscriptions = json['result'] as List;
        log.i('[TradeWS] ğŸ“‹ Active subscriptions: ${subscriptions.length}');
        if (verboseLogging) {
          log.d('[TradeWS] Subscriptions: $subscriptions');
        }
      }
      return null;
    }

    // Combined Stream ë©”ì‹œì§€ ì²˜ë¦¬
    if (json.containsKey('stream') && json.containsKey('data')) {
      final streamName = json['stream'] as String?;
      final data = json['data'];

      if (streamName == null || data == null) {
        return null;
      }

      return _parseStreamData(streamName, data, verboseLogging);
    }

    // Direct Stream ë©”ì‹œì§€ ì²˜ë¦¬ (Combined ì•„ë‹Œ ê²½ìš°)
    if (json.containsKey('e')) {
      final eventType = json['e'] as String;
      return _parseDirectStreamData(eventType, json, verboseLogging);
    }

    if (verboseLogging) {
      log.w('[TradeWS] Unknown message type: ${json.keys.join(', ')}');
    }
    return null;
  }

  /// âœ… Combined Stream ë°ì´í„° íŒŒì‹±
  static Trade? _parseStreamData(String streamName, dynamic data, bool verboseLogging) {
    try {
      if (data is! Map<String, dynamic>) {
        return null;
      }

      // ìŠ¤íŠ¸ë¦¼ íƒ€ì… íŒë³„
      if (streamName.endsWith('@aggTrade')) {
        return _parseAggTradeData(data, streamName, verboseLogging);
      } else if (streamName.endsWith('@ticker')) {
        return _parseTickerData(data, streamName, verboseLogging);
      } else if (streamName.endsWith('@bookTicker')) {
        return _parseBookTickerData(data, streamName, verboseLogging);
      } else if (streamName.endsWith('@depth5')) {
        return _parseDepth5Data(data, streamName, verboseLogging);
      }

      if (verboseLogging) {
        log.w('[TradeWS] Unsupported stream type: $streamName');
      }
      return null;
    } catch (e, st) {
      log.e('[TradeWS] Stream parsing failed ($streamName)', e, st);
      return null;
    }
  }

  /// âœ… Direct Stream ë°ì´í„° íŒŒì‹±
  static Trade? _parseDirectStreamData(String eventType, Map<String, dynamic> data, bool verboseLogging) {
    try {
      switch (eventType) {
        case 'aggTrade':
          return _parseAggTradeData(data, 'direct', verboseLogging);
        case '24hrTicker':
          return _parseTickerData(data, 'direct', verboseLogging);
        default:
          if (verboseLogging) {
            log.w('[TradeWS] Unsupported event type: $eventType');
          }
          return null;
      }
    } catch (e, st) {
      log.e('[TradeWS] Direct stream parsing failed ($eventType)', e, st);
      return null;
    }
  }

  /// ğŸ¯ aggTrade ë°ì´í„° íŒŒì‹±
  static Trade? _parseAggTradeData(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    if (data['e'] != 'aggTrade') return null;

    final trade = Trade.fromAggTrade(data);

    if (verboseLogging) {
      final symbol = data['s'] as String? ?? 'UNKNOWN';
      final price = data['p'] as String? ?? '0';
      final quantity = data['q'] as String? ?? '0';
      log.d('[TradeWS] ğŸ’° $symbol: $price Ã— $quantity (aggTrade: $streamInfo)');
    }

    return trade;
  }

  /// âœ… ticker ë°ì´í„° íŒŒì‹±
  static Trade? _parseTickerData(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    if (data['e'] != '24hrTicker') return null;

    final trade = Trade.fromTicker(data);

    if (verboseLogging) {
      final symbol = data['s'] as String? ?? 'UNKNOWN';
      final price = data['c'] as String? ?? '0';
      final change = data['P'] as String? ?? '0';
      log.d('[TradeWS] ğŸ“Š $symbol: $price ($change%) (ticker: $streamInfo)');
    }

    return trade;
  }

  /// âœ… bookTicker ë°ì´í„° íŒŒì‹±
  static Trade? _parseBookTickerData(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    // bookTickerì—ëŠ” 'e' í•„ë“œê°€ ì—†ìŒ
    if (!data.containsKey('u') || !data.containsKey('s')) return null;

    final trade = Trade.fromBookTicker(data);

    if (verboseLogging) {
      final symbol = data['s'] as String? ?? 'UNKNOWN';
      final bidPrice = data['b'] as String? ?? '0';
      final askPrice = data['a'] as String? ?? '0';
      log.d('[TradeWS] ğŸ’° $symbol: bid $bidPrice / ask $askPrice (bookTicker: $streamInfo)');
    }

    return trade;
  }

  /// âœ… depth5 ë°ì´í„° íŒŒì‹±
  static Trade? _parseDepth5Data(Map<String, dynamic> data, String streamInfo, bool verboseLogging) {
    if (!data.containsKey('bids') || !data.containsKey('asks')) return null;

    // streamInfoì—ì„œ ì‹¬ë³¼ ì¶”ì¶œ
    final symbol = _extractSymbolFromStreamName(streamInfo);
    final trade = Trade.fromDepth5(data, symbol);

    if (verboseLogging) {
      final bids = data['bids'] as List;
      final asks = data['asks'] as List;
      final bestBid = bids.isNotEmpty ? bids[0][0] : '0';
      final bestAsk = asks.isNotEmpty ? asks[0][0] : '0';
      log.d('[TradeWS] ğŸ“‹ $symbol: bid $bestBid / ask $bestAsk (depth5: $streamInfo)');
    }

    return trade;
  }

  /// ìŠ¤íŠ¸ë¦¼ ì´ë¦„ì—ì„œ ì‹¬ë³¼ ì¶”ì¶œ
  static String _extractSymbolFromStreamName(String streamName) {
    if (streamName.contains('@')) {
      return streamName.split('@')[0].toUpperCase();
    }
    return 'UNKNOWN';
  }

  // ===================================================================
  // ğŸ“Š ë””ë²„ê·¸ ë° ëª¨ë‹ˆí„°ë§
  // ===================================================================

  /// í˜„ì¬ êµ¬ë… ì„¤ì • ì •ë³´
  Map<String, dynamic> getSubscriptionInfo() {
    return {
      'config': config.toMap(),
      'estimatedStreams': _calculateTotalStreams(100, config), // ê°€ì •: 100ê°œ ë§ˆì¼“
      'estimatedMessageRate': _estimateMessageRate(),
      'verboseLogging': enableVerboseLogging,
    };
  }

  /// ì˜ˆìƒ ë©”ì‹œì§€ ì†ë„ ê³„ì‚°
  int _estimateMessageRate() {
    return config.aggTradeCount * 50 +    // aggTrade: ~50/ì´ˆ
           config.tickerCount * 1 +       // ticker: ~1/ì´ˆ
           config.bookTickerCount * 10 +  // bookTicker: ~10/ì´ˆ
           config.depth5Count * 10;       // depth5: ~10/ì´ˆ
  }
}

/// âœ… ìŠ¤íŠ¸ë¦¼ êµ¬ë… ì„¤ì • í´ë˜ìŠ¤
class StreamSubscriptionConfig {
  final int aggTradeCount;     // aggTrade ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜
  final int tickerCount;       // ticker ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜  
  final int bookTickerCount;   // bookTicker ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜
  final int depth5Count;       // depth5 ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜

  const StreamSubscriptionConfig({
    this.aggTradeCount = 0,
    this.tickerCount = 0,
    this.bookTickerCount = 0,
    this.depth5Count = 0,
  });

  /// ê¸°ë³¸ ì„¤ì • (ìš°ë¦¬ê°€ ê³„íší•œ 400ê°œ ìŠ¤íŠ¸ë¦¼)
  factory StreamSubscriptionConfig.defaultConfig() {
    return const StreamSubscriptionConfig(
      aggTradeCount: 100,    // Trade + Volumeìš©
      tickerCount: 150,      // Surgeìš©
      bookTickerCount: 100,  // í˜¸ê°€ìš©
      depth5Count: 50,       // ì„¸ë¶€ í˜¸ê°€ìš©
    );
  }

  /// aggTradeë§Œ êµ¬ë… (ê¸°ì¡´ ë°©ì‹ í˜¸í™˜)
  factory StreamSubscriptionConfig.aggTradeOnly(int count) {
    return StreamSubscriptionConfig(aggTradeCount: count);
  }

  /// ë³´ìˆ˜ì  ì„¤ì • (ì ì€ ìŠ¤íŠ¸ë¦¼)
  factory StreamSubscriptionConfig.conservative() {
    return const StreamSubscriptionConfig(
      aggTradeCount: 30,
      tickerCount: 50,
      bookTickerCount: 30,
      depth5Count: 20,
    );
  }

  /// ì´ ìŠ¤íŠ¸ë¦¼ ê°œìˆ˜
  int get totalCount => aggTradeCount + tickerCount + bookTickerCount + depth5Count;

  /// ë§µìœ¼ë¡œ ë³€í™˜
  Map<String, dynamic> toMap() {
    return {
      'aggTradeCount': aggTradeCount,
      'tickerCount': tickerCount,
      'bookTickerCount': bookTickerCount,
      'depth5Count': depth5Count,
      'totalCount': totalCount,
    };
  }

  @override
  String toString() {
    return 'StreamConfig(aggTrade: $aggTradeCount, ticker: $tickerCount, '
           'bookTicker: $bookTickerCount, depth5: $depth5Count, total: $totalCount)';
  }
}\n\n// ====== lib/core/network/websocket/base_ws_client.dart ======\n
import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'package:web_socket_channel/web_socket_channel.dart';
import '../../config/app_config.dart';
import '../../utils/logger.dart';
import 'exponential_backoff.dart';

enum WsStatus { 
  connecting, 
  connected, 
  reconnecting, 
  disconnected, 
  banned,
  pongTimeout,    // ì¶”ê°€: ë” êµ¬ì²´ì ì¸ ìƒíƒœ
  rateLimited,    // ì¶”ê°€: 5ê°œ/ì´ˆ ìœ„ë°˜ ì‹œ
  serverError     // ì¶”ê°€: ì„œë²„ ì—ëŸ¬ ì‹œ
}

typedef DecodeFn<T> = T? Function(Map<String, dynamic> json);
typedef EncodeFn = String Function(List<String> symbols);

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ê³µì‹ WebSocket ë°±ì„œ 100% ì¤€ìˆ˜ + ë©”ëª¨ë¦¬ ê´€ë¦¬ ê°•í™” WebSocket í´ë¼ì´ì–¸íŠ¸
class BaseWsClient<T> {
  final String url;
  final DecodeFn<T> decode;
  final EncodeFn encodeSubscribe;
  final Duration pongTimeout;
  
  void Function(WsStatus status)? onStatusChange;

  // Core WebSocket
  WebSocketChannel? _channel;
  final _dataController = StreamController<T>.broadcast();
  List<String> _subscribedSymbols = [];
  bool _isDisposed = false;
  WsStatus _currentStatus = WsStatus.disconnected;

  // ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ë°±ì„œ ì¤€ìˆ˜ ê¸°ëŠ¥ë“¤
  final _backoff = ExponentialBackoff();
  final _outgoingMsgTimestamps = Queue<DateTime>();
  final _incomingMsgTimestamps = Queue<DateTime>();

  // âœ… [ì¶”ê°€] ë©”ëª¨ë¦¬ ê´€ë¦¬ ê°•í™” (ì—…ë¹„íŠ¸ íŒ¨í„´)
  final Set<StreamSubscription> _activeSubscriptions = {};
  Timer? _memoryCleanupTimer;

  // íƒ€ì´ë¨¸ë“¤
  Timer? _pongTimer;
  Timer? _sessionRefreshTimer;
  Timer? _keepAliveTimer;

  // ì—°ê²° í†µê³„
  int _connectionAttempts = 0;
  DateTime? _lastConnectionAttempt;
  DateTime? _sessionStartTime;
  DateTime? _lastMessageTime;

  BaseWsClient({
    required this.url,
    required this.decode,
    required this.encodeSubscribe,
    this.onStatusChange,
    required this.pongTimeout,
  }) {
    _startMemoryCleanup();
  }

  Stream<T> get stream => _dataController.stream;
  WsStatus get currentStatus => _currentStatus;
  bool get isConnected => _currentStatus == WsStatus.connected;

  // ===================================================================
  // ğŸ§¹ ë©”ëª¨ë¦¬ ê´€ë¦¬ (ì—…ë¹„íŠ¸ íŒ¨í„´ ì ìš©)
  // ===================================================================

  /// âœ… [ì¶”ê°€] ì£¼ê¸°ì  ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹œì‘
  void _startMemoryCleanup() {
    _memoryCleanupTimer = Timer.periodic(const Duration(seconds: 30), (_) {
      _cleanupInactiveSubscriptions();
      _cleanupOldTimestamps();
    });
  }

  /// âœ… [ì¶”ê°€] ë¹„í™œì„± êµ¬ë… ì •ë¦¬
  void _cleanupInactiveSubscriptions() {
    final toRemove = _activeSubscriptions.where((sub) => sub.isPaused).toList();
    for (final sub in toRemove) {
      try {
        sub.cancel();
        _activeSubscriptions.remove(sub);
      } catch (e) {
        log.w('[WS] êµ¬ë… ì •ë¦¬ ì¤‘ ì—ëŸ¬: $e');
      }
    }
    if (toRemove.isNotEmpty) {
      log.d('[WS] ğŸ§¹ ë¹„í™œì„± êµ¬ë… ${toRemove.length}ê°œ ì •ë¦¬ ì™„ë£Œ');
    }
  }

  /// âœ… [ì¶”ê°€] ì¬ì—°ê²° ì‹œ ê¸°ì¡´ êµ¬ë…ë“¤ ì•ˆì „í•˜ê²Œ ì •ë¦¬
  void _cleanupActiveSubscriptions() {
    if (_activeSubscriptions.isNotEmpty) {
      log.d('[WS] ğŸ§¹ ê¸°ì¡´ êµ¬ë… ${_activeSubscriptions.length}ê°œ ì •ë¦¬ ì¤‘...');
      
      for (final subscription in _activeSubscriptions) {
        try {
          subscription.cancel();
        } catch (e) {
          log.w('[WS] âš ï¸ êµ¬ë… ì·¨ì†Œ ì¤‘ ì—ëŸ¬: $e');
        }
      }
      
      _activeSubscriptions.clear();
      log.d('[WS] âœ… êµ¬ë… ì •ë¦¬ ì™„ë£Œ');
    }
  }

  /// âœ… [ê°œì„ ] ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ë¥¼ ìœ„í•œ íƒ€ì„ìŠ¤íƒ¬í”„ ì •ë¦¬
  void _cleanupOldTimestamps() {
    _cleanOldTimestamps(_outgoingMsgTimestamps, const Duration(seconds: 5));
    _cleanOldTimestamps(_incomingMsgTimestamps, const Duration(seconds: 5));
    
    // í í¬ê¸° ì œí•œ (100ê°œ ì´ìƒ ì‹œ ê°•ì œ ì •ë¦¬)
    while (_outgoingMsgTimestamps.length > 100) {
      _outgoingMsgTimestamps.removeFirst();
    }
    while (_incomingMsgTimestamps.length > 100) {
      _incomingMsgTimestamps.removeFirst();
    }
  }

  // ===================================================================
  // ğŸš€ ì—°ê²° ê´€ë¦¬ (ê¸°ì¡´ ë¡œì§ + ë©”ëª¨ë¦¬ ê´€ë¦¬ ê°•í™”)
  // ===================================================================

  void connect(List<String> symbols) async {
    if (_isDisposed || symbols.isEmpty || _currentStatus == WsStatus.connecting) {
      return;
    }

    if (!_canAttemptConnection()) {
      log.w('[WS] Connection attempt blocked - too many attempts');
      return;
    }

    _subscribedSymbols = symbols;
    _updateStatus(WsStatus.connecting);
    
    // âœ… [ì¶”ê°€] ì¬ì—°ê²° ì‹œ ê¸°ì¡´ êµ¬ë…ë“¤ ì •ë¦¬
    _cleanupActiveSubscriptions();
    _cleanupConnection(keepSubscribers: true);

    try {
      _channel = WebSocketChannel.connect(Uri.parse(url));
      _sessionStartTime = DateTime.now();
      _connectionAttempts++;
      _lastConnectionAttempt = DateTime.now();

      _sendControlMessage(encodeSubscribe(_subscribedSymbols));

      // âœ… [ì¶”ê°€] êµ¬ë…ì„ Setì— ì¶”ê°€í•˜ì—¬ ê´€ë¦¬
      final subscription = _channel!.stream.listen(
        _handleMessage,
        onDone: () => _scheduleReconnect(reason: 'Stream done'),
        onError: (e) => _scheduleReconnect(reason: 'Stream error: $e'),
        cancelOnError: true,
      );
      _activeSubscriptions.add(subscription);

      _backoff.reset();
      _setupTimers();
      _updateStatus(WsStatus.connected);
      log.i('[WS] ğŸ¯ Connected to $url (Session: ${_sessionStartTime}, Subscriptions: ${_activeSubscriptions.length})');
    } catch (e, st) {
      log.e('[WS] Connection failed', e, st);
      _scheduleReconnect(reason: 'Connection exception');
    }
  }

  // ===================================================================
  // ğŸ“¨ ë©”ì‹œì§€ ì²˜ë¦¬ (ê¸°ì¡´ ë¡œì§ + ì—ëŸ¬ í•¸ë“¤ë§ ê°•í™”)
  // ===================================================================

  void _handleMessage(dynamic message) {
    _trackIncomingMessage();
    _resetPongTimer();
    _lastMessageTime = DateTime.now(); // âœ… [ì¶”ê°€] ë§ˆì§€ë§‰ ë©”ì‹œì§€ ì‹œê°„ ê¸°ë¡

    if (message is! String || message.isEmpty) {
      log.w('[WS] Received non-string or empty message, skipping. Message: $message');
      return;
    }

    if (message == 'ping' || message == 'PING') {
      _sendPong();
      return;
    }

    try {
      final json = jsonDecode(message) as Map<String, dynamic>;

      if (json.containsKey('code') && json['code'] != 0) {
        final errorCode = json['code'] as int;
        final errorMsg = json['msg'] as String? ?? 'Unknown error';
        
        // âœ… [ê°œì„ ] ì—ëŸ¬ ì½”ë“œë³„ ì„¸ë¶„í™”ëœ ì²˜ë¦¬
        _handleServerError(errorCode, errorMsg);
        return;
      }

      final decodedData = decode(json);
      if (decodedData != null) {
        _dataController.add(decodedData);
      }
    } catch (e, st) {
      log.e('[WS] Message decode error, maintaining connection. Message: "$message"', e, st);
    }
  }

  /// âœ… [ì¶”ê°€] ì„œë²„ ì—ëŸ¬ ì„¸ë¶„í™” ì²˜ë¦¬
  void _handleServerError(int errorCode, String errorMsg) {
    log.e('[WS] ğŸš¨ Binance error: $errorMsg (code: $errorCode)');
    
    switch (errorCode) {
      case 1:
        // ì¼ë°˜ì ì¸ ì—ëŸ¬ - ì—°ê²° ìœ ì§€
        log.w('[WS] General server error, maintaining connection');
        break;
      case 2:
        // ì‹¬ê°í•œ ì—ëŸ¬ - ì¬ì—°ê²° í•„ìš”
        _updateStatus(WsStatus.serverError);
        _scheduleReconnect(reason: 'Critical server error: $errorCode');
        break;
      case 3:
        // ìš”ì²­ ì œí•œ ê´€ë ¨
        _updateStatus(WsStatus.rateLimited);
        log.w('[WS] Rate limit error, backing off');
        break;
      default:
        // ì•Œ ìˆ˜ ì—†ëŠ” ì—ëŸ¬ëŠ” ë¡œê·¸ë§Œ ë‚¨ê¸°ê³  ì—°ê²° ìœ ì§€
        log.w('[WS] Unknown error code: $errorCode, maintaining connection');
    }
  }

  // ===================================================================
  // ğŸ›ï¸ ë©”ì‹œì§€ ì†¡ì‹  (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
  // ===================================================================

  void _sendControlMessage(String message) {
    if (!_canSendMessage()) {
      log.w('[WS] ğŸš¨ Outgoing message rate limit - message dropped');
      _updateStatus(WsStatus.rateLimited);
      return;
    }
    _trackOutgoingMessage();
    _channel?.sink.add(message);
    log.d('[WS] ğŸ“¤ Control message sent');
  }

  void _sendPong() {
    if (!_canSendMessage()) return;
    _trackOutgoingMessage();
    _channel?.sink.add('pong');
    log.d('[WS] ğŸ“ PONG sent');
  }

  // ===================================================================
  // ğŸ“Š ì†ë„ ì œí•œ ê´€ë¦¬ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
  // ===================================================================

  bool _canSendMessage() {
    final now = DateTime.now();
    _cleanOldTimestamps(_outgoingMsgTimestamps, const Duration(seconds: 1));
    return _outgoingMsgTimestamps.length < 5;
  }

  void _trackOutgoingMessage() {
    _outgoingMsgTimestamps.addLast(DateTime.now());
  }

  void _trackIncomingMessage() {
    final now = DateTime.now();
    _incomingMsgTimestamps.addLast(now);
    _cleanOldTimestamps(_incomingMsgTimestamps, const Duration(seconds: 1));

    if (_incomingMsgTimestamps.length > AppConfig.wsMaxInMsgPerSec) {
      log.w('[WS] âš ï¸ High incoming message rate: ${_incomingMsgTimestamps.length}/sec');
    }
  }

  void _cleanOldTimestamps(Queue<DateTime> timestamps, Duration window) {
    final cutoff = DateTime.now().subtract(window);
    while (timestamps.isNotEmpty && timestamps.first.isBefore(cutoff)) {
      timestamps.removeFirst();
    }
  }

  // ===================================================================
  // â° íƒ€ì´ë¨¸ ê´€ë¦¬ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
  // ===================================================================

  void _setupTimers() {
    _resetPongTimer();
    _setupSessionRefreshTimer();
    _setupKeepAlive();
  }

  void _resetPongTimer() {
    _pongTimer?.cancel();
    _pongTimer = Timer(pongTimeout, () {
      log.w('[WS] ğŸš¨ Pong timeout - no server message in ${pongTimeout.inSeconds}s');
      _updateStatus(WsStatus.pongTimeout);
      _scheduleReconnect(reason: 'Pong timeout');
    });
  }

  void _setupSessionRefreshTimer() {
    _sessionRefreshTimer?.cancel();
    _sessionRefreshTimer = Timer(AppConfig.wsSessionRefresh, () {
      log.i('[WS] ğŸ”„ 24h session refresh - proactive reconnect');
      _scheduleReconnect(reason: '24h session refresh');
    });
  }

  void _setupKeepAlive() {
    _keepAliveTimer?.cancel();
    _keepAliveTimer = Timer.periodic(AppConfig.wsKeepAliveInterval, (_) {
      if (_currentStatus == WsStatus.connected) {
        log.d('[WS] ğŸ’“ Keep-alive check (Active subs: ${_activeSubscriptions.length})');
      }
    });
  }

  // ===================================================================
  // ğŸ”„ ì¬ì—°ê²° ê´€ë¦¬ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
  // ===================================================================

  void _scheduleReconnect({required String reason}) {
    if (_isDisposed || _currentStatus == WsStatus.reconnecting) return;

    log.w('[WS] ğŸ”„ Disconnected: $reason');
    _updateStatus(WsStatus.reconnecting);
    _cleanupConnection(keepSubscribers: true);

    if (_connectionAttempts >= AppConfig.wsMaxReconnectAttempts) {
      log.w('[WS] ğŸš¨ Too many connection attempts - cooling down');
      _updateStatus(WsStatus.banned);
      Timer(AppConfig.wsReconnectCooldown, () {
        _connectionAttempts = 0;
        if (!_isDisposed) {
          _scheduleReconnect(reason: 'Cooldown complete');
        }
      });
      return;
    }

    _backoff.attempt(() async {
      if (!_isDisposed && _subscribedSymbols.isNotEmpty) {
        connect(_subscribedSymbols);
      }
    });
  }

  bool _canAttemptConnection() {
    final now = DateTime.now();
    if (_lastConnectionAttempt != null) {
      final timeSinceLastAttempt = now.difference(_lastConnectionAttempt!);
      if (timeSinceLastAttempt < const Duration(minutes: 5) &&
          _connectionAttempts >= AppConfig.wsMaxConnectionsPer5Min) {
        return false;
      }
      if (timeSinceLastAttempt >= const Duration(minutes: 5)) {
        _connectionAttempts = 0;
      }
    }
    return _connectionAttempts < AppConfig.wsMaxReconnectAttempts;
  }

  // ===================================================================
  // ğŸ›ï¸ ìƒíƒœ ë° ì •ë¦¬ (ë©”ëª¨ë¦¬ ê´€ë¦¬ ê°•í™”)
  // ===================================================================

  void _updateStatus(WsStatus status) {
    if (_currentStatus == status) return;
    final oldStatus = _currentStatus;
    _currentStatus = status;
    log.i('[WS] ğŸ“Š Status: $oldStatus â†’ $status');
    try {
      onStatusChange?.call(status);
    } catch (e, st) {
      log.e('[WS] Status callback error', e, st);
    }
  }

  void _cleanupConnection({bool keepSubscribers = false}) {
    _pongTimer?.cancel();
    _sessionRefreshTimer?.cancel();
    _keepAliveTimer?.cancel();

    try {
      _channel?.sink.close();
    } catch (e) {
      log.d('[WS] Channel close error (normal): $e');
    }

    if (!keepSubscribers) {
      _subscribedSymbols.clear();
    }
  }

  /// âœ… [ê°œì„ ] async disposeë¡œ ì•ˆì „í•œ ì •ë¦¬
  Future<void> dispose() async {
    if (_isDisposed) return;
    _isDisposed = true;
    
    log.i('[WS] ğŸ”Œ Client disposing...');
    
    // ë°±ì˜¤í”„ ì·¨ì†Œ
    _backoff.cancel();
    
    // ë©”ëª¨ë¦¬ ì •ë¦¬ íƒ€ì´ë¨¸ ì·¨ì†Œ
    _memoryCleanupTimer?.cancel();
    
    // í™œì„± êµ¬ë…ë“¤ ì •ë¦¬
    _cleanupActiveSubscriptions();
    
    // ì—°ê²° ì •ë¦¬
    _cleanupConnection();
    
    // ì»¨íŠ¸ë¡¤ëŸ¬ ë‹«ê¸°
    await _dataController.close();
    
    _updateStatus(WsStatus.disconnected);
    
    final sessionDuration = _sessionStartTime != null
        ? DateTime.now().difference(_sessionStartTime!)
        : null;
    
    log.i('[WS] âœ… Disposed (Session: ${sessionDuration?.inMinutes ?? 0}min, Attempts: $_connectionAttempts, Max subs: ${_activeSubscriptions.length})');
  }

  // ===================================================================
  // ğŸ“Š ë””ë²„ê·¸ ì •ë³´ (ê°•í™”ëœ ëª¨ë‹ˆí„°ë§)
  // ===================================================================

  /// âœ… [í™•ì¥] ë” ìƒì„¸í•œ ë””ë²„ê·¸ ì •ë³´
  Map<String, dynamic> getDebugInfo() {
    return {
      'status': _currentStatus.toString(),
      'subscribedSymbols': _subscribedSymbols.length,
      'connectionAttempts': _connectionAttempts,
      'sessionDuration': _sessionStartTime != null
          ? DateTime.now().difference(_sessionStartTime!).inMinutes
          : 0,
      'outgoingMsgRate': _outgoingMsgTimestamps.length,
      'incomingMsgRate': _incomingMsgTimestamps.length,
      // âœ… [ì¶”ê°€] ìƒˆë¡œìš´ ëª¨ë‹ˆí„°ë§ ì •ë³´
      'activeSubscriptions': _activeSubscriptions.length,
      'lastMessageTime': _lastMessageTime?.toIso8601String(),
      'backoffDelay': _backoff.currentDelay?.inSeconds,
      'memoryFootprint': _calculateMemoryFootprint(),
    };
  }

  /// âœ… [ì¶”ê°€] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¶”ì •
  int _calculateMemoryFootprint() {
    return _outgoingMsgTimestamps.length + 
           _incomingMsgTimestamps.length + 
           _subscribedSymbols.length + 
           _activeSubscriptions.length;
  }

  /// âœ… [ì¶”ê°€] ì—°ê²° ê±´ê°•ì„± ì²´í¬
  bool get isHealthy {
    if (!isConnected) return false;
    
    final now = DateTime.now();
    
    // ë§ˆì§€ë§‰ ë©”ì‹œì§€ë¡œë¶€í„° 2ë¶„ ì´ìƒ ì§€ë‚¬ìœ¼ë©´ ë¹„ê±´ê°•
    if (_lastMessageTime != null && 
        now.difference(_lastMessageTime!).inMinutes > 2) {
      return false;
    }
    
    // Rate limit ìƒíƒœë©´ ë¹„ê±´ê°•
    if (_currentStatus == WsStatus.rateLimited) return false;
    
    return true;
  }
}\n\n// ====== lib/core/network/websocket/exponential_backoff.dart ======\n
import 'dart:async';
import 'dart:math' as math;
import 'package:connectivity_plus/connectivity_plus.dart';
import '../../utils/logger.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ IP Ban ë°©ì§€ + ì—…ë¹„íŠ¸ Adaptive ë¡œì§ ê²°í•© ë°±ì˜¤í”„
/// ë°±ì„œ ì œí•œ: "300 connections per attempt every 5 minutes per IP"
class ExponentialBackoff {
  final Duration initialDelay;
  final Duration maxDelay;
  final double randomizationFactor;
  final int maxRetries;
  
  // âœ… [ì¶”ê°€] ì—…ë¹„íŠ¸ ìŠ¤íƒ€ì¼ adaptive ê¸°ëŠ¥
  final Connectivity _connectivity = Connectivity();

  int _retryCount = 0;
  Timer? _retryTimer;
  DateTime? _firstAttemptTime;
  DateTime? _lastFailureTime; // âœ… [ì¶”ê°€] ë§ˆì§€ë§‰ ì‹¤íŒ¨ ì‹œê°„
  Duration? _currentDelay; // âœ… [ì¶”ê°€] í˜„ì¬ ì ìš© ì¤‘ì¸ delay ì¶”ì 

  // âœ… [ì¶”ê°€] ë„¤íŠ¸ì›Œí¬ë³„ ì§€ì—° ìŠ¹ìˆ˜ (ë°”ì´ë‚¸ìŠ¤ ì •ì±…ì— ë§ê²Œ ì¡°ì •)
  static const Map<ConnectivityResult, double> _networkMultipliers = {
    ConnectivityResult.wifi: 0.9, // WiFiëŠ” ë¹ ë¥¸ ì¬ì—°ê²° (ë°”ì´ë‚¸ìŠ¤ëŠ” ë³´ìˆ˜ì )
    ConnectivityResult.mobile: 1.3, // ëª¨ë°”ì¼ì€ ë” ë³´ìˆ˜ì 
    ConnectivityResult.ethernet: 0.8, // ìœ ì„ ì€ ê°€ì¥ ë¹ ë¦„
    ConnectivityResult.none: 2.5, // ì—°ê²° ì—†ìŒì€ ë§¤ìš° ë³´ìˆ˜ì  (ë°”ì´ë‚¸ìŠ¤ IP ban ê³ ë ¤)
  };

  ExponentialBackoff({
    this.initialDelay = const Duration(seconds: 2),
    this.maxDelay = const Duration(minutes: 5),
    this.randomizationFactor = 0.3,
    this.maxRetries = 10,
  });

  /// ğŸ¯ í˜„ì¬ ì ìš© ì¤‘ì¸ delay (ì¶”ê°€ëœ í”„ë¡œí¼í‹°)
  Duration? get currentDelay => _currentDelay;

  /// ğŸ¯ ë‹¤ìŒ ì¬ì‹œë„ê¹Œì§€ì˜ ëŒ€ê¸° ì‹œê°„ ê³„ì‚° (adaptive ë¡œì§ ì ìš©)
  Future<Duration> get nextDelay async {
    if (_retryCount == 0) return Duration.zero;

    // ê¸°ë³¸ ì§€ìˆ˜ ë°±ì˜¤í”„
    final baseDelay = initialDelay * math.pow(2, _retryCount - 1);

    // ğŸ¯ ë°”ì´ë‚¸ìŠ¤ íŠ¹í™”: 5ë¶„ ê²½ê³„ì—ì„œ ë” ê¸´ ëŒ€ê¸°
    Duration adjustedDelay = baseDelay;
    if (_retryCount >= 5) {
      adjustedDelay = Duration(minutes: 1 + _retryCount);
    }

    // âœ… [ì¶”ê°€] ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ê³ ë ¤ (ì—…ë¹„íŠ¸ ë°©ì‹)
    final connectivityResult = await _connectivity.checkConnectivity();
    final networkMultiplier = _networkMultipliers[connectivityResult] ?? 1.0;

    // âœ… [ì¶”ê°€] ì‹œê°„ ê¸°ë°˜ í˜ë„í‹° ê³„ì‚°
    final failurePenalty = _calculateFailurePenalty();

    // ëœë¤ ì§€í„° ì ìš©
    final random = math.Random();
    final baseMs = adjustedDelay.inMilliseconds.toDouble();
    final jitterRange = baseMs * randomizationFactor;
    final jitter = (random.nextDouble() * 2 - 1) * jitterRange;
    
    // âœ… [ê°œì„ ] ëª¨ë“  factor ì ìš©
    final adaptiveMs = baseMs * networkMultiplier * failurePenalty + jitter;
    final finalMs = adaptiveMs.clamp(
      initialDelay.inMilliseconds.toDouble(), 
      maxDelay.inMilliseconds.toDouble()
    );

    final finalDuration = Duration(milliseconds: finalMs.round());
    
    log.d('[Backoff] ğŸ§® Adaptive calculation: '
        'base=${baseMs.round()}ms, network=$connectivityResultÃ—${networkMultiplier.toStringAsFixed(1)}, '
        'penaltyÃ—${failurePenalty.toStringAsFixed(1)}, final=${finalMs.round()}ms');

    return finalDuration;
  }

  /// âœ… [ì¶”ê°€] ì—…ë¹„íŠ¸ ìŠ¤íƒ€ì¼ ì‹¤íŒ¨ í˜ë„í‹° ê³„ì‚°
  double _calculateFailurePenalty() {
    if (_lastFailureTime == null) return 1.0;

    final timeSinceLastFailure = DateTime.now().difference(_lastFailureTime!);
    
    // 5ë¶„ ì´ìƒ ì§€ë‚˜ë©´ í˜ë„í‹° ë¦¬ì…‹ (ë°”ì´ë‚¸ìŠ¤ 5ë¶„ ì •ì±…ê³¼ ë§ì¶¤)
    if (timeSinceLastFailure > const Duration(minutes: 5)) {
      return 1.0;
    }

    // ë°”ì´ë‚¸ìŠ¤ëŠ” IP banì´ ë” ìœ„í—˜í•˜ë¯€ë¡œ í˜ë„í‹° ë” í¬ê²Œ (1.8ë°°ê¹Œì§€)
    return math.min(1.8, 1.0 + (_retryCount * 0.15));
  }

  /// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ IP ì œí•œ ê³ ë ¤í•œ ì¬ì‹œë„ ì‹œë„ (adaptive ì ìš©)
  void attempt(Future<void> Function() action) async {
    _retryTimer?.cancel();

    if (_retryCount >= maxRetries) {
      log.e('[Backoff] ğŸš¨ Max retry limit reached ($maxRetries). Stopping to prevent IP ban.');
      _resetForCooldown();
      return;
    }

    if (_shouldCooldown()) {
      log.w('[Backoff] ğŸ• 5-minute cooldown activated for IP safety');
      _resetForCooldown();
      return;
    }

    _retryCount++;
    _firstAttemptTime ??= DateTime.now();
    _lastFailureTime = DateTime.now(); // âœ… [ì¶”ê°€] ì‹¤íŒ¨ ì‹œê°„ ê¸°ë¡

    // âœ… [ìˆ˜ì •] adaptive delay ì‚¬ìš©
    final delay = await nextDelay;
    _currentDelay = delay; // âœ… [ì¶”ê°€] í˜„ì¬ delay ì €ì¥
    
    final totalDuration = DateTime.now().difference(_firstAttemptTime!);

    log.i('[Backoff] ğŸ”„ Attempt #$_retryCount after ${delay.inSeconds}s '
        '(Total: ${totalDuration.inMinutes}min)');

    _retryTimer = Timer(delay, () async {
      try {
        await action();
        // ì„±ê³µ ì‹œ ë¦¬ì…‹ì€ ì™¸ë¶€ì—ì„œ í˜¸ì¶œ
      } catch (e) {
        log.w('[Backoff] âŒ Action failed: $e');
        // ì‹¤íŒ¨ ì‹œ ë‹¤ì‹œ ì¬ì‹œë„í•˜ì§€ ì•ŠìŒ
      }
    });
  }

  /// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ 5ë¶„ ì œí•œ ê³ ë ¤ (300 connections per 5 minutes)
  bool _shouldCooldown() {
    if (_firstAttemptTime == null) return false;

    final elapsed = DateTime.now().difference(_firstAttemptTime!);

    // 5ë¶„ ë‚´ì— ë„ˆë¬´ ë§ì€ ì‹œë„ (ë°”ì´ë‚¸ìŠ¤ ì •ì±…)
    if (elapsed < const Duration(minutes: 5) && _retryCount >= 8) {
      return true;
    }

    // ì´ ì‹œë„ ì‹œê°„ì´ ë„ˆë¬´ ê¸¸ë©´ (15ë¶„ ì´ìƒ)
    if (elapsed > const Duration(minutes: 15)) {
      return true;
    }

    return false;
  }

  /// 5ë¶„ ì¿¨ë‹¤ìš´ í›„ ì¬ì‹œì‘
  void _resetForCooldown() {
    const cooldownDuration = Duration(minutes: 5);
    log.i('[Backoff] ğŸ• Starting ${cooldownDuration.inMinutes}min cooldown...');

    _retryTimer?.cancel();
    _retryTimer = Timer(cooldownDuration, () {
      log.i('[Backoff] âœ… Cooldown complete - resetting counters');
      reset();
    });
  }

  /// ì—°ê²° ì„±ê³µ ì‹œ ë°±ì˜¤í”„ ë¦¬ì…‹
  void reset() {
    _retryCount = 0;
    _firstAttemptTime = null;
    _lastFailureTime = null; // âœ… [ì¶”ê°€] ì‹¤íŒ¨ ì‹œê°„ë„ ë¦¬ì…‹
    _currentDelay = null; // âœ… [ì¶”ê°€] í˜„ì¬ delayë„ ë¦¬ì…‹
    _retryTimer?.cancel();
    log.d('[Backoff] âœ… Reset - ready for new attempts');
  }

  /// ë°±ì˜¤í”„ ì™„ì „ ì¤‘ì§€
  void cancel() {
    _retryTimer?.cancel();
    _retryCount = 0;
    _firstAttemptTime = null;
    _lastFailureTime = null; // âœ… [ì¶”ê°€]
    _currentDelay = null; // âœ… [ì¶”ê°€]
    log.d('[Backoff] ğŸ›‘ Cancelled');
  }

  // ===================================================================
  // ğŸ“Š ìƒíƒœ ì •ë³´ (í™•ì¥ë¨)
  // ===================================================================

  int get retryCount => _retryCount;
  bool get isActive => _retryTimer?.isActive ?? false;
  bool get isInCooldown => _retryCount == 0 && isActive;

  Duration? get timeSinceFirstAttempt => _firstAttemptTime != null
      ? DateTime.now().difference(_firstAttemptTime!)
      : null;

  /// âœ… [í™•ì¥] ë” ìƒì„¸í•œ ë””ë²„ê·¸ ì •ë³´
  Map<String, dynamic> getDebugInfo() {
    return {
      'retryCount': _retryCount,
      'isActive': isActive,
      'isInCooldown': isInCooldown,
      'currentDelaySeconds': _currentDelay?.inSeconds,
      'timeSinceFirstAttemptMinutes': timeSinceFirstAttempt?.inMinutes ?? 0,
      'timeSinceLastFailureMinutes': _lastFailureTime != null 
          ? DateTime.now().difference(_lastFailureTime!).inMinutes 
          : null,
      'maxRetries': maxRetries,
      'shouldCooldown': _shouldCooldown(),
      'failurePenalty': _calculateFailurePenalty(),
    };
  }

  /// âœ… [ê°œì„ ] ë°±ì˜¤í”„ ì „ëµ ì„¤ëª…
  String getStrategyDescription() {
    final buf = StringBuffer();
    buf.writeln('ğŸ¯ Binance Adaptive IP Ban Prevention Strategy:');
    buf.writeln('  â€¢ Initial delay: ${initialDelay.inSeconds}s');
    buf.writeln('  â€¢ Max delay: ${maxDelay.inMinutes}min');
    buf.writeln('  â€¢ Max retries: $maxRetries');
    buf.writeln('  â€¢ Jitter factor: ${(randomizationFactor * 100).toInt()}%');
    buf.writeln('  â€¢ Network-aware: YES (WiFiÃ—0.9, MobileÃ—1.3, etc.)');
    buf.writeln('  â€¢ Failure penalty: ${_calculateFailurePenalty().toStringAsFixed(1)}Ã—');
    buf.writeln('  â€¢ 5-minute cooldown: ${_retryCount >= 8 ? "ACTIVE" : "Ready"}');
    return buf.toString();
  }

  /// í˜„ì¬ ë°±ì˜¤í”„ ìƒíƒœ ìš”ì•½
  String getStatusSummary() {
    if (_retryCount == 0) return 'âœ… Ready';
    if (isInCooldown) return 'ğŸ• Cooling down';
    if (_retryCount >= maxRetries) return 'ğŸš¨ Max retries reached';
    return 'ğŸ”„ Retrying (#$_retryCount/${maxRetries})';
  }

  /// âœ… [ì¶”ê°€] ê±´ê°•ì„± ì²´í¬
  bool get isHealthy {
    // ë„ˆë¬´ ë§ì€ ì¬ì‹œë„ëŠ” ë¹„ê±´ê°•
    if (_retryCount >= maxRetries * 0.8) return false;
    
    // ì¿¨ë‹¤ìš´ ì¤‘ì´ë©´ ë¹„ê±´ê°•
    if (isInCooldown) return false;
    
    // ì‹¤íŒ¨ í˜ë„í‹°ê°€ ë„ˆë¬´ ë†’ìœ¼ë©´ ë¹„ê±´ê°•
    if (_calculateFailurePenalty() > 1.5) return false;
    
    return true;
  }
}\n\n// ====== lib/core/network/websocket/binance_ws_utils.dart ======\n
import 'dart:convert';
import 'dart:math';
import '../../config/app_config.dart';
import '../../utils/logger.dart';

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ WebSocket ê³µí†µ ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤
class BinanceWsUtils {
  
  // ===================================================================
  // ğŸ“¨ ë©”ì‹œì§€ ìƒì„±
  // ===================================================================

  /// ê³ ìœ í•œ ë©”ì‹œì§€ ID ìƒì„± (ë°”ì´ë‚¸ìŠ¤ í˜¸í™˜)
  static int generateMessageId() {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final random = Random().nextInt(1000);
    return timestamp * 1000 + random;
  }

  /// ë°”ì´ë‚¸ìŠ¤ êµ¬ë… ë©”ì‹œì§€ ìƒì„±
  static String createSubscribeMessage(List<String> params) {
    if (params.length > AppConfig.wsMaxStreams) {
      throw ArgumentError(
        'Too many streams: ${params.length}. '
        'Binance limit: ${AppConfig.wsMaxStreams} streams per connection.'
      );
    }

    final subscribeMessage = {
      'method': 'SUBSCRIBE',
      'params': params,
      'id': generateMessageId(),
    };

    final jsonMessage = jsonEncode(subscribeMessage);
    log.d('[BinanceWS] ğŸ“¤ Subscribe message: $jsonMessage');
    
    return jsonMessage;
  }

  /// ë°”ì´ë‚¸ìŠ¤ êµ¬ë… í•´ì œ ë©”ì‹œì§€ ìƒì„±
  static String createUnsubscribeMessage(List<String> params) {
    final unsubscribeMessage = {
      'method': 'UNSUBSCRIBE',
      'params': params,
      'id': generateMessageId(),
    };

    final jsonMessage = jsonEncode(unsubscribeMessage);
    log.d('[BinanceWS] ğŸ“¤ Unsubscribe message: $jsonMessage');
    
    return jsonMessage;
  }

  // ===================================================================
  // ğŸ“¥ ë©”ì‹œì§€ ê²€ì¦
  // ===================================================================

  /// Combined Stream ë°ì´í„° ì¶”ì¶œ
  static Map<String, dynamic>? extractCombinedStreamData(
    Map<String, dynamic> json,
    String expectedStreamSuffix,
  ) {
    if (!json.containsKey('stream') || !json.containsKey('data')) {
      return null;
    }

    final streamName = json['stream'] as String?;
    final data = json['data'];

    if (streamName == null || data == null) {
      return null;
    }

    // ìŠ¤íŠ¸ë¦¼ íƒ€ì… í™•ì¸
    if (!streamName.contains(expectedStreamSuffix)) {
      return null;
    }

    if (data is Map<String, dynamic>) {
      return data;
    }

    return null;
  }

  /// Direct Stream ë°ì´í„° í™•ì¸
  static bool isDirectStreamEvent(Map<String, dynamic> json, String eventType) {
    return json.containsKey('e') && json['e'] == eventType;
  }

  // ===================================================================
  // ğŸ“Š í†µê³„ ìœ í‹¸ë¦¬í‹°
  // ===================================================================

  /// ê¸°ë³¸ í†µê³„ ì •ë³´ ìƒì„±
  static Map<String, dynamic> createBaseStatistics({
    required String streamType,
    required String updateSpeed,
    required int totalReceived,
    required int totalErrors,
    required int activeStreams,
    required DateTime? firstTime,
    required DateTime? lastTime,
    Map<String, dynamic>? additionalStats,
  }) {
    final now = DateTime.now();
    final sessionDuration = firstTime != null
        ? now.difference(firstTime)
        : Duration.zero;

    final itemsPerMinute = sessionDuration.inMinutes > 0
        ? (totalReceived / sessionDuration.inMinutes).toStringAsFixed(1)
        : '0';

    final errorRate = totalReceived > 0
        ? '${((totalErrors / (totalReceived + totalErrors)) * 100).toStringAsFixed(2)}%'
        : '0%';

    final baseStats = {
      'streamType': streamType,
      'updateSpeed': updateSpeed,
      'totalReceived': totalReceived,
      'totalErrors': totalErrors,
      'activeStreams': activeStreams,
      'sessionDurationMinutes': sessionDuration.inMinutes,
      'itemsPerMinute': itemsPerMinute,
      'errorRate': errorRate,
      'firstTime': firstTime?.toIso8601String(),
      'lastTime': lastTime?.toIso8601String(),
    };

    if (additionalStats != null) {
      baseStats.addAll(additionalStats);
    }

    return baseStats;
  }

  // ===================================================================
  // ğŸ”§ ìŠ¤íŠ¸ë¦¼ íŒŒë¼ë¯¸í„° ìƒì„±ê¸°
  // ===================================================================

  /// aggTrade ìŠ¤íŠ¸ë¦¼ íŒŒë¼ë¯¸í„° ìƒì„±
  static List<String> createAggTradeStreams(List<String> symbols) {
    return symbols.map((symbol) => '${symbol.toLowerCase()}@aggTrade').toList();
  }

  /// depth ìŠ¤íŠ¸ë¦¼ íŒŒë¼ë¯¸í„° ìƒì„±
  static List<String> createDepthStreams(List<String> symbols, {bool fast = false}) {
    final suffix = fast ? 'depth@100ms' : 'depth';
    return symbols.map((symbol) => '${symbol.toLowerCase()}@$suffix').toList();
  }

  /// bookTicker ìŠ¤íŠ¸ë¦¼ íŒŒë¼ë¯¸í„° ìƒì„±
  static List<String> createBookTickerStreams(List<String> symbols) {
    return symbols.map((symbol) => '${symbol.toLowerCase()}@bookTicker').toList();
  }

  /// kline ìŠ¤íŠ¸ë¦¼ íŒŒë¼ë¯¸í„° ìƒì„±
  static List<String> createKlineStreams(List<String> symbols, String interval) {
    return symbols.map((symbol) => '${symbol.toLowerCase()}@kline_$interval').toList();
  }

  /// ticker ìŠ¤íŠ¸ë¦¼ íŒŒë¼ë¯¸í„° ìƒì„±
  static List<String> createTickerStreams(List<String> symbols, {bool mini = false}) {
    final suffix = mini ? 'miniTicker' : 'ticker';
    return symbols.map((symbol) => '${symbol.toLowerCase()}@$suffix').toList();
  }

  /// ì „ì²´ ticker ìŠ¤íŠ¸ë¦¼ íŒŒë¼ë¯¸í„° ìƒì„± (ëª¨ë“  ì‹¬ë³¼)
  static List<String> createAllTickerStreams({bool mini = false}) {
    final suffix = mini ? '!miniTicker@arr' : '!ticker@arr';
    return [suffix];
  }
}\n\n// ====== lib/core/network/api_client.dart ======\n
// ===================================================================
// lib/core/network/api_client.dart
// ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ REST API í´ë¼ì´ì–¸íŠ¸ - ê³µì‹ ë°±ì„œ 100% ì¤€ìˆ˜
// ===================================================================

import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:math';
import 'package:dio/dio.dart';
import 'package:crypto/crypto.dart';
import '../config/app_config.dart';
import '../error/app_exception.dart';
import '../extensions/result.dart';
import '../utils/logger.dart';

typedef Json = Map<String, dynamic>;

// ===================================================================
// ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ Rate Limiter - ê³µì‹ ë°±ì„œ ê¸°ì¤€
// ===================================================================

/// ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ Rate Limit ì •ë³´
class BinanceRateLimit {
  final String rateLimitType; // REQUEST_WEIGHT, ORDER, RAW_REQUEST
  final String interval;      // SECOND, MINUTE
  final int intervalNum;      // 1, 10, etc
  final int limit;           // ì œí•œê°’

  const BinanceRateLimit({
    required this.rateLimitType,
    required this.interval,
    required this.intervalNum,
    required this.limit,
  });

  factory BinanceRateLimit.fromJson(Json json) {
    return BinanceRateLimit(
      rateLimitType: json['rateLimitType'] as String,
      interval: json['interval'] as String,
      intervalNum: json['intervalNum'] as int,
      limit: json['limit'] as int,
    );
  }

  Duration get duration {
    switch (interval) {
      case 'SECOND':
        return Duration(seconds: intervalNum);
      case 'MINUTE':
        return Duration(minutes: intervalNum);
      case 'HOUR':
        return Duration(hours: intervalNum);
      case 'DAY':
        return Duration(days: intervalNum);
      default:
        return Duration(seconds: intervalNum);
    }
  }

  @override
  String toString() => '$rateLimitType: $limit/$intervalNum$interval';
}

/// ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ ì „ìš© Rate Limiter
class BinanceFuturesRateLimiter {
  final Map<String, Queue<DateTime>> _requestTimes = {};
  final Map<String, BinanceRateLimit> _limits = {};
  
  // ì„œë²„ì—ì„œ ë°›ì€ ì‚¬ìš©ëŸ‰ ì •ë³´
  int _currentWeight = 0;
  int _currentOrderCount = 0;
  DateTime _lastUpdateTime = DateTime.now();

  /// exchangeInfoì—ì„œ ë°›ì€ rate limit ì •ë³´ ì„¤ì •
  void updateLimits(List<BinanceRateLimit> limits) {
    _limits.clear();
    for (final limit in limits) {
      final key = '${limit.rateLimitType}_${limit.interval}_${limit.intervalNum}';
      _limits[key] = limit;
    }
    log.i('Rate limits updated: ${_limits.length} rules');
  }

  /// ì‘ë‹µ í—¤ë”ì—ì„œ ì‚¬ìš©ëŸ‰ ì •ë³´ ì—…ë°ì´íŠ¸
  void updateFromHeaders(Map<String, List<String>> headers) {
    try {
      // X-MBX-USED-WEIGHT-1M í˜•íƒœì˜ í—¤ë” íŒŒì‹±
      for (final entry in headers.entries) {
        final key = entry.key.toLowerCase();
        final value = entry.value.isNotEmpty ? entry.value.first : '';
        
        if (key.startsWith('x-mbx-used-weight') && value.isNotEmpty) {
          _currentWeight = int.tryParse(value) ?? _currentWeight;
        } else if (key.startsWith('x-mbx-order-count') && value.isNotEmpty) {
          _currentOrderCount = int.tryParse(value) ?? _currentOrderCount;
        }
      }
      
      _lastUpdateTime = DateTime.now();
    } catch (e) {
      log.w('Failed to parse rate limit headers: $e');
    }
  }

  /// Rate limit ì²´í¬ ë° ëŒ€ê¸°
  Future<void> throttle({
    required String endpoint,
    required int weight,
    bool isOrder = false,
  }) async {
    final now = DateTime.now();
    
    // REQUEST_WEIGHT ì²´í¬ (1ë¶„ë‹¹ 2400)
    await _throttleByType('REQUEST_WEIGHT_MINUTE_1', weight, now);
    
    // ORDER ì œí•œ ì²´í¬ (í•„ìš”ì‹œ)
    if (isOrder) {
      await _throttleByType('ORDERS_SECOND_10', 1, now);
      await _throttleByType('ORDERS_MINUTE_1', 1, now);
    }
    
    // RAW_REQUEST ì²´í¬ (ì´ˆë‹¹ ì œí•œ)
    await _throttleByType('RAW_REQUEST_SECOND_1', 1, now);
  }

  Future<void> _throttleByType(String limitKey, int cost, DateTime now) async {
    final limit = _limits[limitKey];
    if (limit == null) return;

    final queue = _requestTimes.putIfAbsent(limitKey, () => Queue<DateTime>());
    
    // ì˜¤ë˜ëœ ìš”ì²­ ì •ë¦¬
    while (queue.isNotEmpty && 
           now.difference(queue.first) > limit.duration) {
      queue.removeFirst();
    }

    // í˜„ì¬ ì‚¬ìš©ëŸ‰ ê³„ì‚°
    final currentUsage = queue.length * cost;
    
    // ì œí•œ ì´ˆê³¼ì‹œ ëŒ€ê¸°
    if (currentUsage + cost > limit.limit) {
      final waitTime = limit.duration - now.difference(queue.first);
      if (waitTime > Duration.zero) {
        log.d('Rate limit wait: ${waitTime.inMilliseconds}ms for $limitKey');
        await Future.delayed(waitTime);
      }
      
      // ë‹¤ì‹œ ì •ë¦¬
      final newNow = DateTime.now();
      while (queue.isNotEmpty && 
             newNow.difference(queue.first) > limit.duration) {
        queue.removeFirst();
      }
    }

    // ìš”ì²­ ê¸°ë¡
    queue.addLast(now);
  }

  /// í˜„ì¬ ì‚¬ìš©ë¥  ì •ë³´
  Map<String, dynamic> getUsageInfo() {
    return {
      'currentWeight': _currentWeight,
      'currentOrderCount': _currentOrderCount,
      'lastUpdate': _lastUpdateTime.toIso8601String(),
      'activeLimits': _limits.keys.toList(),
      'requestQueues': {
        for (final entry in _requestTimes.entries)
          entry.key: entry.value.length,
      },
    };
  }

  void dispose() {
    _requestTimes.clear();
    _limits.clear();
  }
}

// ===================================================================
// ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ ì¸ì¦ ì²˜ë¦¬
// ===================================================================

class BinanceFuturesAuth {
  final String apiKey;
  final String secretKey;

  const BinanceFuturesAuth({
    required this.apiKey,
    required this.secretKey,
  });

  /// HMAC SHA256 ì„œëª… ìƒì„±
  String generateSignature(String queryString) {
    final key = utf8.encode(secretKey);
    final bytes = utf8.encode(queryString);
    final hmacSha256 = Hmac(sha256, key);
    final digest = hmacSha256.convert(bytes);
    return digest.toString();
  }

  /// íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€ëœ ì¿¼ë¦¬ ìŠ¤íŠ¸ë§ ìƒì„±
  String addTimestamp(String? queryString, {int? recvWindow}) {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final params = <String>[];
    
    if (queryString != null && queryString.isNotEmpty) {
      params.add(queryString);
    }
    
    if (recvWindow != null) {
      params.add('recvWindow=$recvWindow');
    }
    
    params.add('timestamp=$timestamp');
    
    return params.join('&');
  }
}

// ===================================================================
// ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ API í´ë¼ì´ì–¸íŠ¸
// ===================================================================

class ApiClient {
  final Dio _dio;
  final BinanceFuturesRateLimiter _rateLimiter;
  final BinanceFuturesAuth? _auth;
  
  // ìºì‹œ
  final Map<String, _CacheEntry> _cache = {};
  static const int _maxCacheSize = 100;
  
  ApiClient({
    Dio? dio,
    String? apiKey,
    String? secretKey,
  }) : _dio = dio ?? Dio(BaseOptions(
          baseUrl: AppConfig.restBaseUrl,
          connectTimeout: AppConfig.restTimeout,
          receiveTimeout: AppConfig.restTimeout,
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
        )),
        _rateLimiter = BinanceFuturesRateLimiter(),
        _auth = (apiKey != null && secretKey != null) 
            ? BinanceFuturesAuth(apiKey: apiKey, secretKey: secretKey)
            : null {
    
    _dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) async {
          // API í‚¤ í—¤ë” ì¶”ê°€
          if (_auth != null) {
            options.headers['X-MBX-APIKEY'] = _auth!.apiKey;
          }
          
          handler.next(options);
        },
        onResponse: (response, handler) {
          // Rate limit ì •ë³´ ì—…ë°ì´íŠ¸
          _rateLimiter.updateFromHeaders(response.headers.map);
          handler.next(response);
        },
        onError: (error, handler) {
          log.e('API Request failed: ${error.message}');
          handler.next(error);
        },
      ),
    );
    
    // ì‹œì‘ ì‹œ rate limit ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    _initializeRateLimits();
  }

  /// Rate limit ì •ë³´ ì´ˆê¸°í™”
  Future<void> _initializeRateLimits() async {
    try {
      final result = await get('/fapi/v1/exchangeInfo');
      result.when(
        ok: (data) {
          final rateLimitsJson = data['rateLimits'] as List?;
          if (rateLimitsJson != null) {
            final limits = rateLimitsJson
                .map((json) => BinanceRateLimit.fromJson(json as Json))
                .toList();
            _rateLimiter.updateLimits(limits);
          }
        },
        err: (error) {
          log.w('Failed to fetch rate limits: $error');
          // ê¸°ë³¸ê°’ ì„¤ì •
          _rateLimiter.updateLimits([
            const BinanceRateLimit(
              rateLimitType: 'REQUEST_WEIGHT',
              interval: 'MINUTE',
              intervalNum: 1,
              limit: 2400,
            ),
            const BinanceRateLimit(
              rateLimitType: 'ORDERS',
              interval: 'SECOND',
              intervalNum: 10,
              limit: 300,
            ),
            const BinanceRateLimit(
              rateLimitType: 'ORDERS',
              interval: 'MINUTE',
              intervalNum: 1,
              limit: 1200,
            ),
          ]);
        },
      );
    } catch (e) {
      log.w('Rate limit initialization failed: $e');
    }
  }

  /// GET ìš”ì²­ (ê³µê°œ API)
  Future<Result<dynamic, AppException>> get(
    String path, {
    Json? query,
    Duration? cacheDur,
    int weight = 1,
  }) async {
    // ìºì‹œ í™•ì¸
    if (cacheDur != null) {
      final cached = _getFromCache(path, query);
      if (cached != null) {
        return Ok(cached);
      }
    }

    try {
      // Rate limiting
      await _rateLimiter.throttle(
        endpoint: path,
        weight: weight,
        isOrder: false,
      );

      final response = await _dio.get(
        path,
        queryParameters: query,
      );

      final data = response.data;
      
      // ìºì‹œ ì €ì¥
      if (cacheDur != null && data != null) {
        _putToCache(path, query, data, cacheDur);
      }

      return Ok(data);

    } on DioException catch (e) {
      return Err(_handleDioException(e));
    } catch (e, stackTrace) {
      return Err(AppException.network(
        'Unexpected error: $e\nStack: ${stackTrace.toString()}'
      ));
    }
  }

  /// POST ìš”ì²­ (ì¸ì¦ í•„ìš”)
  Future<Result<dynamic, AppException>> post(
    String path, {
    Json? query,
    Json? body,
    int weight = 1,
    bool isOrder = false,
    int? recvWindow,
  }) async {
    if (_auth == null) {
      return Err(AppException.config('API authentication required'));
    }

    try {
      // Rate limiting
      await _rateLimiter.throttle(
        endpoint: path,
        weight: weight,
        isOrder: isOrder,
      );

      // ì„œëª… ìƒì„±
      final queryString = _buildQueryString(query);
      final bodyString = _buildQueryString(body);
      final allParams = [queryString, bodyString]
          .where((s) => s.isNotEmpty)
          .join('&');
      
      final signedParams = _auth!.addTimestamp(allParams, recvWindow: recvWindow);
      final signature = _auth!.generateSignature(signedParams);
      
      // ìµœì¢… ë°ì´í„° ì¤€ë¹„
      final finalData = '$signedParams&signature=$signature';

      final response = await _dio.post(
        path,
        data: finalData,
        queryParameters: query,
      );

      return Ok(response.data);

    } on DioException catch (e) {
      return Err(_handleDioException(e));
    } catch (e, stackTrace) {
      return Err(AppException.network(
        'Unexpected error: $e\nStack: ${stackTrace.toString()}'
      ));
    }
  }

  /// DELETE ìš”ì²­ (ì£¼ë¬¸ ì·¨ì†Œ ë“±)
  Future<Result<dynamic, AppException>> delete(
    String path, {
    Json? query,
    int weight = 1,
    int? recvWindow,
  }) async {
    if (_auth == null) {
      return Err(AppException.config('API authentication required'));
    }

    try {
      // Rate limiting
      await _rateLimiter.throttle(
        endpoint: path,
        weight: weight,
        isOrder: true,
      );

      // ì„œëª… ìƒì„±
      final queryString = _buildQueryString(query);
      final signedParams = _auth!.addTimestamp(queryString, recvWindow: recvWindow);
      final signature = _auth!.generateSignature(signedParams);
      
      final response = await _dio.delete(
        '$path?$signedParams&signature=$signature',
      );

      return Ok(response.data);

    } on DioException catch (e) {
      return Err(_handleDioException(e));
    } catch (e, stackTrace) {
      return Err(AppException.network(
        'Unexpected error: $e\nStack: ${stackTrace.toString()}'
      ));
    }
  }

  // ===================================================================
  // í—¬í¼ ë©”ì„œë“œë“¤
  // ===================================================================

  String _buildQueryString(Json? params) {
    if (params == null || params.isEmpty) return '';
    
    return params.entries
        .where((e) => e.value != null)
        .map((e) => '${e.key}=${Uri.encodeComponent(e.value.toString())}')
        .join('&');
  }

  AppException _handleDioException(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        return AppException.network(
          'Connection timeout: ${e.message}',
          code: 'TIMEOUT',
        );

      case DioExceptionType.badResponse:
        final statusCode = e.response?.statusCode;
        final responseData = e.response?.data;

        // ë°”ì´ë‚¸ìŠ¤ API ì—ëŸ¬ ì²˜ë¦¬
        if (responseData is Map && responseData.containsKey('code')) {
          return AppException.binanceApi(
            responseData['msg'] ?? 'Binance API error',
            responseData['code'] as int?,
          );
        }

        // HTTP ìƒíƒœì½”ë“œë³„ ì²˜ë¦¬
        switch (statusCode) {
          case 403:
            return AppException.network(
              'WAF Limit violated - IP temporarily banned',
              code: 'WAF_LIMIT',
            );
          case 418:
            return AppException.network(
              'IP auto-banned for rate limit violations',
              code: 'IP_BANNED',
            );
          case 429:
            return AppException.network(
              'Rate limit exceeded - backing off required',
              code: 'RATE_LIMIT',
            );
          case 503:
            return AppException.network(
              'Service unavailable - retry later',
              code: 'SERVICE_UNAVAILABLE',
            );
          default:
            return AppException.network(
              'HTTP Error $statusCode: ${e.message}',
              code: 'HTTP_$statusCode',
            );
        }

      case DioExceptionType.connectionError:
        return AppException.network(
          'Connection error: ${e.message}',
          code: 'CONNECTION_ERROR',
        );

      case DioExceptionType.badCertificate:
        return AppException.network(
          'SSL Certificate error: ${e.message}',
          code: 'SSL_ERROR',
        );

      case DioExceptionType.cancel:
        return AppException.network(
          'Request cancelled: ${e.message}',
          code: 'CANCELLED',
        );

      case DioExceptionType.unknown:
      default:
        return AppException.network(
          'Unknown network error: ${e.message}',
          code: 'UNKNOWN_NETWORK_ERROR',
        );
    }
  }

  // ===================================================================
  // ìºì‹œ ê´€ë¦¬
  // ===================================================================

  dynamic _getFromCache(String path, Json? query) {
    final key = _cacheKey(path, query);
    final entry = _cache[key];
    if (entry != null && !entry.isExpired) {
      return entry.data;
    }
    _cache.remove(key);
    return null;
  }

  void _putToCache(String path, Json? query, dynamic data, Duration duration) {
    final key = _cacheKey(path, query);
    
    // ìºì‹œ í¬ê¸° ì œí•œ
    if (_cache.length >= _maxCacheSize) {
      final oldestKey = _cache.keys.first;
      _cache.remove(oldestKey);
    }
    
    _cache[key] = _CacheEntry(data, DateTime.now().add(duration));
  }

  String _cacheKey(String path, Json? query) {
    final queryStr = query?.entries
        .map((e) => '${e.key}=${e.value}')
        .join('&') ?? '';
    return '$path?$queryStr';
  }

  // ===================================================================
  // ìƒíƒœ ì •ë³´
  // ===================================================================

  /// í˜„ì¬ API í´ë¼ì´ì–¸íŠ¸ ìƒíƒœ
  Map<String, dynamic> getStatus() {
    return {
      'baseUrl': _dio.options.baseUrl,
      'hasAuth': _auth != null,
      'cacheSize': _cache.length,
      'rateLimiter': _rateLimiter.getUsageInfo(),
    };
  }

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  void dispose() {
    _rateLimiter.dispose();
    _cache.clear();
    _dio.close();
  }
}

// ===================================================================
// ìºì‹œ ì—”íŠ¸ë¦¬ í´ë˜ìŠ¤
// ===================================================================

class _CacheEntry {
  final dynamic data;
  final DateTime expiry;

  _CacheEntry(this.data, this.expiry);

  bool get isExpired => DateTime.now().isAfter(expiry);
}\n\n// ====== lib/core/utils/logger.dart ======\n
import 'package:logger/logger.dart';

/// ì•± ì „ì²´ì—ì„œ ì‚¬ìš©í•  ì „ì—­ ë¡œê±° ì¸ìŠ¤í„´ìŠ¤
final Logger log = Logger(
  printer: PrettyPrinter(
    methodCount: 1, // ë¡œê·¸ í˜¸ì¶œ ìŠ¤íƒì„ í•œ ì¤„ë§Œ í‘œì‹œ
    errorMethodCount: 8, // ì—ëŸ¬ ë°œìƒ ì‹œ í‘œì‹œí•  ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë¼ì¸ ìˆ˜
    lineLength: 120, // ë¡œê·¸ í•œ ì¤„ì˜ ìµœëŒ€ ê¸¸ì´
    colors: true, // ë¡œê·¸ ë ˆë²¨ë³„ ì»¬ëŸ¬ ì ìš©
    printEmojis: true, // ë¡œê·¸ ë ˆë²¨ë³„ ì´ëª¨ì§€ ì ìš©
    printTime: true, // íƒ€ì„ìŠ¤íƒ¬í”„ ì¶œë ¥
  ),
  // ê°œë°œ ì¤‘ì—ëŠ” ëª¨ë“  ë ˆë²¨ì˜ ë¡œê·¸ë¥¼, ë¦´ë¦¬ì¦ˆ ì‹œì—ëŠ” Level.warning ë“±ìœ¼ë¡œ ë³€ê²½ ê°€ëŠ¥
  level: Level.debug,
);
\n\n// ====== lib/core/extensions/result.dart ======\n
// lib/core/extensions/result.dart

/// ğŸ¯ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° Result íŒ¨í„´ (Rust ìŠ¤íƒ€ì¼)
/// ì„±ê³µ(Ok)ê³¼ ì‹¤íŒ¨(Err)ë¥¼ íƒ€ì… ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
sealed class Result<T, E> {
  const Result();

  /// ì„±ê³µ ì¼€ì´ìŠ¤
  bool get isOk => this is Ok<T, E>;
  
  /// ì‹¤íŒ¨ ì¼€ì´ìŠ¤
  bool get isErr => this is Err<T, E>;

  /// íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ ê²°ê³¼ ì²˜ë¦¬
  R when<R>({
    required R Function(T data) ok,
    required R Function(E error) err,
  }) {
    return switch (this) {
      Ok(value: final data) => ok(data),
      Err(error: final error) => err(error),
    };
  }

  /// ì„±ê³µ ë°ì´í„° ë³€í™˜
  Result<R, E> map<R>(R Function(T data) transform) {
    return when(
      ok: (data) => Ok(transform(data)),
      err: (error) => Err(error),
    );
  }

  /// ì‹¤íŒ¨ ì—ëŸ¬ ë³€í™˜
  Result<T, R> mapError<R>(R Function(E error) transform) {
    return when(
      ok: (data) => Ok(data),
      err: (error) => Err(transform(error)),
    );
  }

  /// ì„±ê³µ ë°ì´í„° ì¶”ì¶œ (ì‹¤íŒ¨ ì‹œ ì˜ˆì™¸)
  T unwrap() {
    return when(
      ok: (data) => data,
      err: (error) => throw Exception('Called unwrap on Err: $error'),
    );
  }

  /// ì„±ê³µ ë°ì´í„° ì¶”ì¶œ (ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ê°’)
  T unwrapOr(T defaultValue) {
    return when(
      ok: (data) => data,
      err: (_) => defaultValue,
    );
  }
}

/// ì„±ê³µ ì¼€ì´ìŠ¤
final class Ok<T, E> extends Result<T, E> {
  final T value;
  const Ok(this.value);

  @override
  String toString() => 'Ok($value)';

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Ok<T, E> && value == other.value;

  @override
  int get hashCode => value.hashCode;
}

/// ì‹¤íŒ¨ ì¼€ì´ìŠ¤
final class Err<T, E> extends Result<T, E> {
  final E error;
  const Err(this.error);

  @override
  String toString() => 'Err($error)';

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Err<T, E> && error == other.error;

  @override
  int get hashCode => error.hashCode;
}\n\n// ====== lib/core/common/time_frame_types.dart ======\n
import 'package:flutter/foundation.dart';

/// ê±°ë˜ í•„í„° Enum (ë‹¨ìœ„: USDT)
///
/// ë°”ì´ë‚¸ìŠ¤ í™˜ê²½ì— ë§ì¶° ê±°ë˜ëŒ€ê¸ˆ í•„í„°ì˜ ê¸°ì¤€ì„ USDTë¡œ ë³€ê²½í•©ë‹ˆë‹¤.
enum TradeFilter {
  usdt10k(10000, '10K USDT'),
  usdt30k(30000, '30K USDT'),
  usdt50k(50000, '50K USDT'),
  usdt100k(100000, '100K USDT'),
  usdt300k(300000, '300K USDT'),
  usdt500k(500000, '500K USDT');

  const TradeFilter(this.value, this.displayName);
  final double value;
  final String displayName;

  static List<TradeFilter> get supportedFilters => values.toList();
}

/// ê±°ë˜ ëª¨ë“œ Enum (ê±°ë˜ì†Œ ë¬´ê´€)
enum TradeMode {
  accumulated('ëˆ„ì '),
  range('êµ¬ê°„');

  const TradeMode(this.displayName);
  final String displayName;

  bool get isAccumulated => this == TradeMode.accumulated;
}

/// ê±°ë˜ ê´€ë ¨ ì„¤ì • (ê±°ë˜ì†Œ ë¬´ê´€)
class TradeConfig {
  /// í•„í„°ë³„ë¡œ UIì— í‘œì‹œí•  ìµœëŒ€ ê±°ë˜ ë‚´ì—­ ê°œìˆ˜
  static const int maxTradesPerFilter = 200;
  
  /// ì¤‘ë³µ ì²´ê²° IDë¥¼ ê±¸ëŸ¬ë‚´ê¸° ìœ„í•œ ìºì‹œ ì‚¬ì´ì¦ˆ
  static const int maxSeenIdsCacheSize = 1000;
}

/// ë°”ì´ë‚¸ìŠ¤ ë§ˆì¼“ ì •ë³´ ì—”í‹°í‹°
///
/// ë°”ì´ë‚¸ìŠ¤ì˜ `/fapi/v1/exchangeInfo` ì—”ë“œí¬ì¸íŠ¸ ì‘ë‹µì„ ê¸°ë°˜ìœ¼ë¡œ ì¬êµ¬ì„±í•©ë‹ˆë‹¤.
@immutable
class MarketInfo {
  final String symbol;
  final String pair;
  final String status;
  final String baseAsset;
  final String quoteAsset;
  final int pricePrecision;
  final int quantityPrecision;

  const MarketInfo({
    required this.symbol,
    required this.pair,
    required this.status,
    required this.baseAsset,
    required this.quoteAsset,
    required this.pricePrecision,
    required this.quantityPrecision,
  });

  factory MarketInfo.fromJson(Map<String, dynamic> json) {
    return MarketInfo(
      symbol: json['symbol'] ?? '',
      pair: json['pair'] ?? '',
      status: json['status'] ?? '',
      baseAsset: json['baseAsset'] ?? '',
      quoteAsset: json['quoteAsset'] ?? '',
      pricePrecision: json['pricePrecision'] ?? 0,
      quantityPrecision: json['quantityPrecision'] ?? 0,
    );
  }
}\n\n// ====== lib/core/error/app_exception.dart ======\n
// lib/core/error/app_exception.dart

/// ğŸ¯ ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ìš© ì˜ˆì™¸ í´ë˜ìŠ¤
/// ë°”ì´ë‚¸ìŠ¤ ê±°ë˜ ì‹œìŠ¤í…œì—ì„œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ëª¨ë“  ì˜ˆì™¸ë¥¼ êµ¬ì¡°í™”
class AppException implements Exception {
  final String message;
  final String? code;
  final Map<String, dynamic>? details;
  final DateTime timestamp;

  AppException(
    this.message, {
    this.code,
    this.details,
  }) : timestamp = DateTime.now();

  /// ë„¤íŠ¸ì›Œí¬ ê´€ë ¨ ì˜ˆì™¸
  factory AppException.network(String message, {String? code}) {
    return AppException(
      message,
      code: code ?? 'NETWORK_ERROR',
      details: {'type': 'network'},
    );
  }

  /// WebSocket ê´€ë ¨ ì˜ˆì™¸
  factory AppException.websocket(String message, {String? code}) {
    return AppException(
      message,
      code: code ?? 'WEBSOCKET_ERROR',
      details: {'type': 'websocket'},
    );
  }

  /// ë°ì´í„° íŒŒì‹± ê´€ë ¨ ì˜ˆì™¸
  factory AppException.parsing(String message, {Map<String, dynamic>? rawData}) {
    return AppException(
      message,
      code: 'PARSING_ERROR',
      details: {'type': 'parsing', 'rawData': rawData},
    );
  }

  /// ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê´€ë ¨ ì˜ˆì™¸
  factory AppException.business(String message, {String? code}) {
    return AppException(
      message,
      code: code ?? 'BUSINESS_ERROR',
      details: {'type': 'business'},
    );
  }

  /// ë°”ì´ë‚¸ìŠ¤ API ê´€ë ¨ ì˜ˆì™¸
  factory AppException.binanceApi(String message, int? errorCode) {
    return AppException(
      message,
      code: 'BINANCE_API_ERROR',
      details: {'type': 'binance_api', 'errorCode': errorCode},
    );
  }

  /// ì„¤ì •/êµ¬ì„± ê´€ë ¨ ì˜ˆì™¸
  factory AppException.config(String message) {
    return AppException(
      message,
      code: 'CONFIG_ERROR',
      details: {'type': 'config'},
    );
  }

  @override
  String toString() {
    final buffer = StringBuffer('AppException: $message');
    if (code != null) buffer.write(' (Code: $code)');
    if (details != null) buffer.write(' Details: $details');
    return buffer.toString();
  }

  /// JSON ì§ë ¬í™”
  Map<String, dynamic> toJson() {
    return {
      'message': message,
      'code': code,
      'details': details,
      'timestamp': timestamp.toIso8601String(),
    };
  }

  /// JSON ì—­ì§ë ¬í™”
  factory AppException.fromJson(Map<String, dynamic> json) {
    return AppException(
      json['message'] as String,
      code: json['code'] as String?,
      details: json['details'] as Map<String, dynamic>?,
    );
  }
}\n\n// ====== lib/core/event/app_event.dart ======\n
// ===================================================================
// lib/core/event/app_event.dart
// ===================================================================

import 'package:equatable/equatable.dart';

typedef Json = Map<String, dynamic>;

/// ğŸ¯ ë°”ì´ë‚¸ìŠ¤ ì „ìš© ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ë²¤íŠ¸
/// - id: ê°„ë‹¨í•œ íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë°˜ ID
/// - ts: UTC ë°€ë¦¬ì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„  
/// - payload: ë°”ì´ë‚¸ìŠ¤ ë°ì´í„°
class AppEvent extends Equatable {
  /// ê³ ìœ  ID (íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë°˜)
  final String id;
  
  /// UTC ë°€ë¦¬ì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„
  final int ts;
  
  /// í˜ì´ë¡œë“œ ë°ì´í„° (ë¶ˆë³€)
  final Json payload;

  const AppEvent({
    required this.id,
    required this.ts,
    required this.payload,
  });

  /// ğŸ¯ í˜„ì¬ ì‹œê°ì„ ê¸°ì¤€ìœ¼ë¡œ ê°„ë‹¨í•œ ID ìƒì„±
  factory AppEvent.now(Json payload) {
    final nowUtcMs = DateTime.now().toUtc().millisecondsSinceEpoch;
    return AppEvent(
      id: 'evt_$nowUtcMs',
      ts: nowUtcMs,
      payload: Map<String, dynamic>.of(payload), // ë°©ì–´ì  ë³µì‚¬
    );
  }

  /// UTC ms â†’ ë¡œì»¬ DateTime
  DateTime get timestamp =>
      DateTime.fromMillisecondsSinceEpoch(ts, isUtc: true).toLocal();

  /// JSON ì§ë ¬í™”
  Json toJson() => {
        'id': id,
        'ts': ts,
        'payload': Map<String, dynamic>.of(payload),
      };

  /// JSON ì—­ì§ë ¬í™”
  factory AppEvent.fromJson(Json json) {
    return AppEvent(
      id: json['id'] as String,
      ts: json['ts'] as int,
      payload: Map<String, dynamic>.of(json['payload'] as Json),
    );
  }

  @override
  List<Object?> get props => [id, ts, payload];
}
